{% extends "base.html" %}
{% block page_title %}Compare | SonusTemper{% endblock %}
{% block title %}Compare{% endblock %}
{% block subtitle %}Compare source vs processed audio (metrics + waveform).{% endblock %}
{% block sidebar %}
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Compare Status</div>
        <div class="muted">Upload + analysis activity.</div>
      </div>
    </div>
    <div class="status-list" id="analyzeStatusList">(waiting)</div>
    <div class="status-progress" id="analyzeStatusProgress">
      <div class="status-progress-bar" id="analyzeStatusProgressBar"></div>
    </div>
  </div>
    <div class="card browse-card">
      <div class="card-head">
        <div>
          <div class="card-title">Song Library</div>
          <div class="muted">Pick a source, run output, or import.</div>
        </div>
      </div>
    <div id="analyzeBrowser" class="library-browser-container" data-module="compare"></div>
    <div class="ai-selected-summary">
      <div class="ai-selected-label">Selected File</div>
      <div class="ai-selected-name" id="compareSelectedName">-</div>
      <div class="ai-selected-meta" id="compareSelectedMeta">No file selected.</div>
    </div>
  </div>
{% endblock %}
{% block content %}
  <div class="card analyze-card">
    <div class="card-head">
      <div>
        <div class="card-title">Compare</div>
        <div class="muted" id="analyzeSubtitle">Source vs Processed</div>
      </div>
      <div class="analyze-actions">
        <input type="file" id="analyzeUploadInput" accept=".wav,.mp3,.flac,.aiff,.aif,.m4a,.ogg,.aac" hidden>
        <button class="btn ghost small" id="openNoiseRemovalBtn">Open in Noise Removal</button>
        <button class="btn ghost small" id="analyzeUploadBtn">Upload</button>
      </div>
    </div>

    <div id="analyzeEmpty" class="analyze-empty">
      <div class="muted">Upload a source file to compare or launch Compare from a mastering output.</div>
    </div>

    <div id="analyzeLoaded" class="analyze-loaded" hidden>
      <div class="metric-pills" id="summaryPills"></div>

      <div class="wave-panel" id="sourcePanel">
        <div class="wave-head">
          <div class="wave-title">Source</div>
          <div class="wave-head-actions">
            <button class="btn ghost tiny" id="soloSourceBtn" type="button">Solo</button>
            <div class="wave-meta" id="sourceName">-</div>
          </div>
        </div>
        <div class="wave-body" id="sourceWaveBody">
          <div class="wave-clip-label" id="sourceClipLabel">
            <span class="wave-clip-text">CLIP</span>
            <span class="wave-clip-meta" id="sourceClipMeta">TP Margin —</span>
          </div>
          <div class="wave-canvas" id="waveSource"></div>
          <div class="spectro-viewport" id="spectroSourceViewport" hidden>
            <div class="spectro-inner" id="spectroSourceInner">
              <div class="spectro-scrub-line" id="spectroSourceScrub"></div>
              <img id="spectroSourceImg" alt="Source spectrogram" draggable="false">
            </div>
          </div>
        </div>
      </div>

      <div class="wave-panel" id="processedPanel">
        <div class="wave-head">
          <div class="wave-title">Processed</div>
          <div class="wave-head-actions">
            <button class="btn ghost tiny" id="soloProcessedBtn" type="button">Solo</button>
            <div class="wave-meta" id="processedName">-</div>
          </div>
        </div>
        <div class="wave-body" id="processedWaveBody">
          <div class="wave-clip-label" id="processedClipLabel">
            <span class="wave-clip-text">CLIP</span>
            <span class="wave-clip-meta" id="processedClipMeta">TP Margin —</span>
          </div>
          <div class="wave-canvas" id="waveProcessed"></div>
          <div class="spectro-viewport" id="spectroProcessedViewport" hidden>
            <div class="spectro-inner" id="spectroProcessedInner">
              <div class="spectro-scrub-line" id="spectroProcessedScrub"></div>
              <img id="spectroProcessedImg" alt="Processed spectrogram" draggable="false">
            </div>
          </div>
        </div>
        <div class="wave-empty muted" id="processedEmpty" hidden>No processed file selected.</div>
      </div>

      <div class="analyze-controls">
        <button class="btn ghost small icon" id="playBtn" type="button" aria-label="Play" title="Play">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M8 6l10 6-10 6V6z"></path>
          </svg>
        </button>
        <button class="btn ghost small icon" id="pauseBtn" type="button" aria-label="Pause" title="Pause">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M7 6h4v12H7zM13 6h4v12h-4z"></path>
          </svg>
        </button>
        <button class="btn ghost small icon" id="stopBtn" type="button" aria-label="Stop" title="Stop">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M7 7h10v10H7z"></path>
          </svg>
        </button>
        <div class="playback-modes">
          <button class="btn ghost small is-active" data-track-mode="both" id="toggleBothBtn" type="button">Both</button>
          <button class="btn ghost small" data-track-mode="source" id="toggleSourceBtn" type="button">Source</button>
          <button class="btn ghost small" id="toggleFlipBtn" type="button" aria-label="A/B Flip" title="A/B Flip">⇄</button>
          <button class="btn ghost small" data-track-mode="processed" id="toggleProcessedBtn" type="button">Processed</button>
        </div>
        <label class="analyze-toggle match-toggle" title="Applies gain so A/B is loudness-matched (playback only).">
          <input type="checkbox" id="toggleMatchLoudness">
          <span>Match Loudness</span>
        </label>
        <div class="playback-modes">
          <button class="btn ghost small is-active" id="toggleViewWaveform" type="button">Waveform</button>
          <button class="btn ghost small" id="toggleViewSpectrogram" type="button">Spectrogram</button>
        </div>
        <div class="zoom-control">
          <span>Zoom</span>
          <span class="zoom-label" id="zoomLabel">1x</span>
          <input type="range" id="zoomRange" min="0" max="5" value="0" step="1">
        </div>
        <div class="analyze-toggles" id="compareOverlayToggles">
          <label class="analyze-toggle is-active">
            <input type="checkbox" id="togglePeakRisk" checked>
            <span>Peak Risk</span>
          </label>
          <label class="analyze-toggle">
            <input type="checkbox" id="toggleHeatmap">
            <span>Loudness Heatmap</span>
          </label>
          <label class="analyze-toggle is-active">
            <input type="checkbox" id="toggleDelta" checked>
            <span>Δ Loudness</span>
          </label>
        </div>
        <div class="analyze-legend" id="compareWaveLegend" aria-label="Waveform legend">
          <span class="legend-title">Legend</span>
          <span class="legend-item"><span class="legend-swatch peak-warn"></span>Peak risk (warn)</span>
          <span class="legend-item"><span class="legend-swatch peak-clip"></span>Peak risk (clip)</span>
          <span class="legend-item"><span class="legend-swatch heatmap"></span>Loudness heatmap</span>
          <span class="legend-item"><span class="legend-swatch delta-plus"></span>Δ Loudness +</span>
          <span class="legend-item"><span class="legend-swatch delta-minus"></span>Δ Loudness -</span>
        </div>
        <div class="spectro-legend" id="compareSpectroLegend" hidden aria-label="Spectrogram legend">
          <span>Low energy (-105 dB)</span>
          <div class="spectro-legend-bar" aria-hidden="true"></div>
          <span>High energy (0 dB)</span>
        </div>
      </div>

      <div class="compare-overview" id="compareOverview">
        <div class="compare-overview-row">
          <div class="compare-overview-title">Overview</div>
          <div class="compare-overview-hint muted">Drag the window to scrub/scroll. Click to jump.</div>
        </div>
        <div class="compare-mini-viewport" id="compareMiniWaveViewport">
          <div class="compare-mini-inner" id="compareMiniWaveInner">
            <div class="compare-mini-wave" id="compareMiniWaveSource"></div>
            <div class="compare-mini-wave" id="compareMiniWaveProcessed"></div>
            <div class="compare-mini-window" id="compareMiniWaveWindow"></div>
          </div>
        </div>
        <div class="compare-mini-viewport compare-mini-viewport--spectro" id="compareMiniSpectroViewport" hidden>
          <div class="compare-mini-inner" id="compareMiniSpectroInner">
            <img id="compareMiniSpectroSourceImg" alt="Source spectrogram overview" draggable="false">
            <img id="compareMiniSpectroProcessedImg" alt="Processed spectrogram overview" draggable="false">
            <div class="compare-mini-window" id="compareMiniSpectroWindow"></div>
          </div>
        </div>
      </div>

      <div class="compare-grid" id="compareGrid"></div>
      <audio id="compareAudioSource" preload="metadata" hidden></audio>
      <audio id="compareAudioProcessed" preload="metadata" hidden></audio>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script src="/static/vendor/wavesurfer.min.js"></script>
<script src="/static/js/library_browser.js"></script>
<script>
(() => {
  const uploadBtn = document.getElementById('analyzeUploadBtn');
  const uploadInput = document.getElementById('analyzeUploadInput');
  const openNoiseRemovalBtn = document.getElementById('openNoiseRemovalBtn');
  const emptyState = document.getElementById('analyzeEmpty');
  const loadedState = document.getElementById('analyzeLoaded');
  const summaryPills = document.getElementById('summaryPills');
  const compareGrid = document.getElementById('compareGrid');
  const sourceName = document.getElementById('sourceName');
  const processedName = document.getElementById('processedName');
  const processedEmpty = document.getElementById('processedEmpty');
  const analyzeSubtitle = document.getElementById('analyzeSubtitle');
  const analyzeStatusList = document.getElementById('analyzeStatusList');
  const analyzeStatusProgressBar = document.getElementById('analyzeStatusProgressBar');
  const compareSelectedName = document.getElementById('compareSelectedName');
  const compareSelectedMeta = document.getElementById('compareSelectedMeta');

  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stopBtn = document.getElementById('stopBtn');
  const zoomRange = document.getElementById('zoomRange');
  const zoomLabel = document.getElementById('zoomLabel');
  const soloSourceBtn = document.getElementById('soloSourceBtn');
  const soloProcessedBtn = document.getElementById('soloProcessedBtn');
  const toggleBothBtn = document.getElementById('toggleBothBtn');
  const toggleSourceBtn = document.getElementById('toggleSourceBtn');
  const toggleFlipBtn = document.getElementById('toggleFlipBtn');
  const toggleProcessedBtn = document.getElementById('toggleProcessedBtn');
  const togglePeakRisk = document.getElementById('togglePeakRisk');
  const toggleHeatmap = document.getElementById('toggleHeatmap');
  const toggleDelta = document.getElementById('toggleDelta');
  const toggleMatchLoudness = document.getElementById('toggleMatchLoudness');
  const toggleViewWaveform = document.getElementById('toggleViewWaveform');
  const toggleViewSpectrogram = document.getElementById('toggleViewSpectrogram');
  const compareOverlayToggles = document.getElementById('compareOverlayToggles');

  const compareAudioSource = document.getElementById('compareAudioSource');
  const compareAudioProcessed = document.getElementById('compareAudioProcessed');

  const waveSourceEl = document.getElementById('waveSource');
  const waveProcessedEl = document.getElementById('waveProcessed');
  const sourceWaveBody = document.getElementById('sourceWaveBody');
  const processedWaveBody = document.getElementById('processedWaveBody');
  const sourceClipMeta = document.getElementById('sourceClipMeta');
  const processedClipMeta = document.getElementById('processedClipMeta');
  const spectroSourceViewport = document.getElementById('spectroSourceViewport');
  const spectroSourceInner = document.getElementById('spectroSourceInner');
  const spectroSourceImg = document.getElementById('spectroSourceImg');
  const spectroSourceScrub = document.getElementById('spectroSourceScrub');
  const spectroProcessedViewport = document.getElementById('spectroProcessedViewport');
  const spectroProcessedInner = document.getElementById('spectroProcessedInner');
  const spectroProcessedImg = document.getElementById('spectroProcessedImg');
  const spectroProcessedScrub = document.getElementById('spectroProcessedScrub');
  const compareMiniWaveViewport = document.getElementById('compareMiniWaveViewport');
  const compareMiniWaveInner = document.getElementById('compareMiniWaveInner');
  const compareMiniWaveSource = document.getElementById('compareMiniWaveSource');
  const compareMiniWaveProcessed = document.getElementById('compareMiniWaveProcessed');
  const compareMiniWaveWindow = document.getElementById('compareMiniWaveWindow');
  const compareMiniSpectroViewport = document.getElementById('compareMiniSpectroViewport');
  const compareMiniSpectroInner = document.getElementById('compareMiniSpectroInner');
  const compareMiniSpectroSourceImg = document.getElementById('compareMiniSpectroSourceImg');
  const compareMiniSpectroProcessedImg = document.getElementById('compareMiniSpectroProcessedImg');
  const compareMiniSpectroWindow = document.getElementById('compareMiniSpectroWindow');
  const compareWaveLegend = document.getElementById('compareWaveLegend');
  const compareSpectroLegend = document.getElementById('compareSpectroLegend');

  let sourceWave = null;
  let processedWave = null;
  let miniSourceWave = null;
  let miniProcessedWave = null;
  let selectedItem = null;
  let analysisData = null;
  let overlayCleanup = [];
  let transportCleanup = [];
  let overviewCleanup = [];
  let transportLock = false;
  let zoomRaf = null;
  let pendingZoom = null;
  let analysisLufs = { source: null, processed: null };
  let audioCtx = null;
  const gainNodes = new Map();
  const volumeRafs = new Map();
  const analyzeBrowser = document.getElementById('analyzeBrowser');
  let libraryBrowser = null;
  let statusLines = [];
  let statusRenderPending = false;
  let viewMode = 'waveform';
  let scrollSyncLock = false;
  let spectroSyncLock = false;
  let waveScrollCleanup = [];
  let spectroScrollCleanup = [];
  let driftTimer = null;
  const MATCH_DEBUG = localStorage.getItem('ST_DEBUG_COMPARE_MATCH') === '1';
  const matchDebug = (...args) => {
    if (MATCH_DEBUG) console.debug('[compare][match]', ...args);
  };
  const DEBUG_COMPARE_SYNC = false;
  const syncDebug = (...args) => {
    if (DEBUG_COMPARE_SYNC) console.debug('[compare][sync]', ...args);
  };

  const zoomSteps = [1, 2, 4, 8, 16, 32];
  let fitMinPxPerSec = 1;
  let currentZoomPxPerSec = 1;
  const ZOOM_DEBUG = localStorage.getItem('ST_DEBUG_COMPARE_ZOOM') === '1';
  const zoomDebug = (...args) => {
    if (ZOOM_DEBUG) console.debug('[compare][zoom]', ...args);
  };
  let trackMode = 'both';

  const metricLabels = [
    { key: 'I', label: 'LUFS-I', suffix: ' LUFS' },
    { key: 'TP', label: 'True Peak', suffix: ' dBTP' },
    { key: 'LRA', label: 'LRA', suffix: ' LU' },
    { key: 'rms_level', label: 'RMS', suffix: ' dB' },
    { key: 'crest_factor', label: 'Crest', suffix: ' dB' },
    { key: 'dynamic_range', label: 'DR', suffix: ' dB' },
  ];

  function fmt(num, decimals){
    if (num === null || num === undefined || Number.isNaN(num)) return '-';
    const fixed = (typeof decimals === 'number') ? num.toFixed(decimals) : num.toFixed(1);
    return fixed.replace(/\.0$/, '');
  }

  function scheduleStatusRender(){
    if (statusRenderPending) return;
    statusRenderPending = true;
    requestAnimationFrame(() => {
      statusRenderPending = false;
      if (!analyzeStatusList) return;
      analyzeStatusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
      analyzeStatusList.scrollTop = analyzeStatusList.scrollHeight;
    });
  }

  function addStatusLine(message){
    if (!message) return;
    const ts = new Date().toLocaleTimeString();
    statusLines.push(`${ts} ${message}`);
    if (statusLines.length > 200) statusLines = statusLines.slice(-200);
    scheduleStatusRender();
  }

  function setStatusProgress(pct, active){
    if (!analyzeStatusProgressBar) return;
    if (pct === null || pct === undefined) {
      analyzeStatusProgressBar.style.width = '0%';
      analyzeStatusProgressBar.classList.remove('active');
      return;
    }
    const clamped = Math.max(0, Math.min(100, pct));
    analyzeStatusProgressBar.style.width = `${clamped}%`;
    if (active) {
      analyzeStatusProgressBar.classList.add('active');
    } else {
      analyzeStatusProgressBar.classList.remove('active');
    }
  }

  function formatDelta(outVal, inVal){
    if (typeof outVal !== 'number' || typeof inVal !== 'number') return '';
    const delta = outVal - inVal;
    const sign = delta > 0 ? '+' : '';
    return ` (${sign}${fmt(delta, 1)})`;
  }

  function displayMetric(value, suffix){
    if (value === null || value === undefined || Number.isNaN(value)) return '-';
    return `${fmt(value, 1)}${suffix}`;
  }

  function currentZoomIndex(){
    if (!zoomRange) return 0;
    const raw = parseInt(zoomRange.value || '0', 10);
    if (Number.isNaN(raw)) return 0;
    return Math.max(0, Math.min(zoomSteps.length - 1, raw));
  }

  function setZoomLevel(level){
    const idx = Math.max(0, Math.min(zoomSteps.length - 1, level));
    const factor = zoomSteps[idx];
    if (zoomLabel) zoomLabel.textContent = `${factor}x`;
    const minPxPerSec = Math.max(1, fitMinPxPerSec) * factor;
    currentZoomPxPerSec = minPxPerSec;
    const prevContent = getContentWidth(sourceWave);
    const prevViewport = getViewportWidth(sourceWave);
    const prevScroll = getScrollLeft(sourceWave);
    const prevCenter = prevContent && prevViewport
      ? (prevScroll + prevViewport / 2) / prevContent
      : 0;
    if (sourceWave) sourceWave.zoom(minPxPerSec);
    if (processedWave) processedWave.zoom(minPxPerSec);
    const miniPxPerSec = Math.max(1, fitMinPxPerSec);
    if (miniSourceWave) miniSourceWave.zoom(miniPxPerSec);
    if (miniProcessedWave) miniProcessedWave.zoom(miniPxPerSec);
    updateZoomClasses(factor);
    const clampScroll = (wave) => {
      const scrollEl = getScrollEl(wave);
      if (!scrollEl) return;
      const max = Math.max(0, scrollEl.scrollWidth - scrollEl.clientWidth);
      if (scrollEl.scrollLeft > max) scrollEl.scrollLeft = max;
    };
    const postZoomWork = () => {
      if (viewMode === 'waveform') {
        ensureWaveContentWidth(sourceWave);
        ensureWaveContentWidth(processedWave);
        forceWaveRedraw(sourceWave);
        forceWaveRedraw(processedWave);
        const nextContent = getContentWidth(sourceWave);
        const nextViewport = getViewportWidth(sourceWave);
        const maxScroll = Math.max(0, nextContent - nextViewport);
        const targetLeft = clamp(prevCenter * nextContent - nextViewport / 2, 0, maxScroll);
        setScrollLeft(sourceWave, targetLeft);
        setScrollLeft(processedWave, targetLeft);
        clampScroll(sourceWave);
        clampScroll(processedWave);
        drawOverlays();
        updateScrollHints();
        syncDebug('zoom', {
          factor,
          pxPerSec: minPxPerSec,
          scrollLeft: getScrollLeft(sourceWave),
          contentWidth: nextContent,
          viewportWidth: nextViewport,
        });
      }
      updateSpectrogramZoom();
      updateMiniSpectrogram();
      updateOverviewWindow();
      if (ZOOM_DEBUG) {
        [sourceWave, processedWave].forEach((wave, idxWave) => {
          if (!wave || typeof wave.getWrapper !== 'function') return;
          const wrapper = wave.getWrapper();
          if (!wrapper) return;
          const canvases = wrapper.querySelectorAll('canvas');
          zoomDebug('zoom', {
            kind: idxWave === 0 ? 'source' : 'processed',
            pxPerSec: minPxPerSec,
            duration: typeof wave.getDuration === 'function' ? wave.getDuration() : 0,
            targetWidth: getContentWidth(wave),
            clientWidth: getViewportWidth(wave),
            scrollWidth: getContentWidth(wave),
            canvases: Array.from(canvases).map((c) => ({ w: c.width, h: c.height })),
          });
        });
      }
    };
    if (sourceWave && typeof sourceWave.once === 'function') {
      let fired = false;
      sourceWave.once('redrawcomplete', () => {
        if (fired) return;
        fired = true;
        postZoomWork();
      });
      setTimeout(() => {
        if (fired) return;
        fired = true;
        postZoomWork();
      }, 80);
    } else {
      setTimeout(postZoomWork, 0);
    }
  }

  function forceWaveRedraw(wave){
    if (!wave) return;
    if (typeof wave.drawBuffer === 'function') {
      wave.drawBuffer();
      return;
    }
    if (wave.renderer && typeof wave.renderer.render === 'function') {
      wave.renderer.render();
      return;
    }
    if (typeof wave.render === 'function') {
      wave.render();
    }
  }

  function clamp(val, minVal, maxVal){
    return Math.max(minVal, Math.min(maxVal, val));
  }

  const MATCH_GAIN_LIMIT_DB = 12;
  const VOLUME_RAMP_MS = 40;

  function getLufsValue(metrics){
    if (!metrics) return null;
    const candidates = [
      metrics.I,
      metrics.lufs_i,
      metrics.lufsI,
      metrics.lufs,
    ];
    for (const val of candidates) {
      if (typeof val === 'number' && !Number.isNaN(val)) return val;
    }
    return null;
  }

  function updateAnalysisLufs(payload, input, output){
    let source = getLufsValue(input);
    let processed = getLufsValue(output);
    const lufsObj = payload?.metrics?.lufs_i;
    if (lufsObj && typeof lufsObj === 'object') {
      if (source === null && typeof lufsObj.source === 'number') source = lufsObj.source;
      if (processed === null && typeof lufsObj.processed === 'number') processed = lufsObj.processed;
    }
    analysisLufs = { source, processed };
  }

  function dbToGain(db){
    return Math.pow(10, db / 20);
  }

  function computeMatchGains(){
    const src = analysisLufs.source;
    const proc = analysisLufs.processed;
    if (typeof src !== 'number' || typeof proc !== 'number') {
      return { source: 1, processed: 1 };
    }
    const target = Math.max(src, proc);
    const sourceDb = clamp(target - src, -MATCH_GAIN_LIMIT_DB, MATCH_GAIN_LIMIT_DB);
    const processedDb = clamp(target - proc, -MATCH_GAIN_LIMIT_DB, MATCH_GAIN_LIMIT_DB);
    return {
      source: dbToGain(sourceDb),
      processed: dbToGain(processedDb),
    };
  }

  function getAudioContext(){
    if (audioCtx) return audioCtx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return null;
    audioCtx = new Ctx();
    return audioCtx;
  }

  function resumeAudioContext(){
    if (!audioCtx || audioCtx.state !== 'suspended') return;
    audioCtx.resume().catch(() => {});
  }

  function ensureGainNodeForAudio(audioEl, key){
    if (!audioEl) return null;
    const existing = gainNodes.get(key);
    if (existing) {
      if (existing.audio === audioEl) return existing;
      matchDebug('replacing gain node', { key });
      try {
        existing.source.disconnect();
      } catch (_err) {
        // ignore disconnect errors
      }
      try {
        existing.gain.disconnect();
      } catch (_err) {
        // ignore disconnect errors
      }
      gainNodes.delete(key);
    }
    const ctx = getAudioContext();
    if (!ctx) return null;
    let source = null;
    try {
      source = ctx.createMediaElementSource(audioEl);
    } catch (_err) {
      matchDebug('ensureGainNode failed', { key, err: _err });
      return null;
    }
    audioEl.muted = false;
    const gain = ctx.createGain();
    gain.gain.value = 1;
    source.connect(gain);
    gain.connect(ctx.destination);
    const state = { source, gain, audio: audioEl };
    gainNodes.set(key, state);
    return state;
  }

  function rampGain(gainNode, target){
    const ctx = gainNode.context;
    const now = ctx.currentTime;
    const clamped = Math.max(0, target);
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
    gainNode.gain.linearRampToValueAtTime(clamped, now + VOLUME_RAMP_MS / 1000);
  }

  function rampMediaVolume(audioEl, target){
    if (!audioEl || typeof audioEl.volume !== 'number') return;
    const start = audioEl.volume;
    const clamped = Math.max(0, Math.min(1, target));
    if (Math.abs(clamped - start) < 0.001) {
      audioEl.volume = clamped;
      return;
    }
    const startTime = performance.now();
    const duration = VOLUME_RAMP_MS;
    const prior = volumeRafs.get(audioEl);
    if (prior) cancelAnimationFrame(prior);
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / duration);
      const next = start + (clamped - start) * t;
      audioEl.volume = next;
      if (t < 1) {
        volumeRafs.set(audioEl, requestAnimationFrame(step));
      } else {
        volumeRafs.delete(audioEl);
      }
    };
    volumeRafs.set(audioEl, requestAnimationFrame(step));
  }

  function setAudioGain(audioEl, key, gain, allowCreate){
    if (!audioEl) return;
    let node = gainNodes.get(key);
    if (node && node.audio !== audioEl) {
      matchDebug('gain node mismatch', { key });
      node = null;
    }
    if (allowCreate && !node) node = ensureGainNodeForAudio(audioEl, key);
    if (node && node.gain) {
      rampGain(node.gain, gain);
      return;
    }
    matchDebug('setAudioGain fallback', { key });
    rampMediaVolume(audioEl, gain);
  }

  function applyMatchLoudness(options = {}){
    const matchOn = toggleMatchLoudness && toggleMatchLoudness.checked;
    const srcLufs = analysisLufs.source;
    const procLufs = analysisLufs.processed;
    const target = (typeof srcLufs === 'number' && typeof procLufs === 'number')
      ? Math.max(srcLufs, procLufs)
      : null;
    const gains = matchOn ? computeMatchGains() : { source: 1, processed: 1 };
    matchDebug('lufs', {
      src: srcLufs,
      proc: procLufs,
      target,
      gains,
      enabled: matchOn,
    });
    const sourceOn = trackMode === 'source' || trackMode === 'both';
    const processedOn = trackMode === 'processed' || trackMode === 'both';
    const sourceGain = (sourceOn ? 1 : 0) * gains.source;
    const processedGain = (processedOn ? 1 : 0) * gains.processed;
    const allowCreate = options.allowCreate || matchOn;
    setAudioGain(compareAudioSource, 'source', sourceGain, allowCreate);
    setAudioGain(compareAudioProcessed, 'processed', processedGain, allowCreate);
  }

  function waveHost(wave){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const wrapper = wave.getWrapper();
    if (!wrapper || !wrapper.getRootNode) return null;
    const root = wrapper.getRootNode();
    return root && root.host ? root.host : null;
  }

  function updateZoomClasses(factor){
    const isZoomed = factor > 1;
    const hosts = [waveHost(sourceWave), waveHost(processedWave)].filter(Boolean);
    hosts.forEach((host) => {
      host.classList.toggle('is-zoomed', isZoomed);
    });
  }

  function ensureScrollHintEls(scrollEl){
    if (!scrollEl) return null;
    scrollEl.style.position = 'relative';
    let left = scrollEl.querySelector('.scroll-hint-left');
    if (!left) {
      left = document.createElement('div');
      left.className = 'scroll-hint-left';
      left.style.position = 'absolute';
      left.style.top = '0';
      left.style.left = '0';
      left.style.height = '100%';
      left.style.width = '28px';
      left.style.pointerEvents = 'none';
      left.style.zIndex = '6';
      left.style.background = 'linear-gradient(90deg, rgba(11,15,20,0.9), rgba(11,15,20,0))';
      scrollEl.appendChild(left);
    }
    let right = scrollEl.querySelector('.scroll-hint-right');
    if (!right) {
      right = document.createElement('div');
      right.className = 'scroll-hint-right';
      right.style.position = 'absolute';
      right.style.top = '0';
      right.style.right = '0';
      right.style.height = '100%';
      right.style.width = '28px';
      right.style.pointerEvents = 'none';
      right.style.zIndex = '6';
      right.style.background = 'linear-gradient(270deg, rgba(11,15,20,0.9), rgba(11,15,20,0))';
      scrollEl.appendChild(right);
    }
    return { left, right };
  }

  function updateScrollHints(){
    if (viewMode !== 'waveform') return;
    const zoomed = zoomSteps[currentZoomIndex()] > 1;
    [sourceWave, processedWave].forEach((wave) => {
      if (!wave || typeof wave.getWrapper !== 'function') return;
      const wrapper = wave.getWrapper();
      const scrollEl = getScrollEl(wave);
      const host = waveHost(wave);
      if (!wrapper || !scrollEl || !host) return;
      const contentWidth = getContentWidth(wave);
      const viewportWidth = getViewportWidth(wave);
      const scrollable = contentWidth > viewportWidth + 1;
      host.classList.toggle('is-scrollable', scrollable);
      const hints = ensureScrollHintEls(scrollEl);
      if (!hints) return;
      const maxScroll = Math.max(0, contentWidth - viewportWidth);
      const show = zoomed && scrollable && maxScroll > 1;
      const atStart = getScrollLeft(wave) <= 1;
      const atEnd = getScrollLeft(wave) >= maxScroll - 1;
      hints.left.style.display = show && !atStart ? 'block' : 'none';
      hints.right.style.display = show && !atEnd ? 'block' : 'none';
    });
  }

  function getScrollEl(wave){
    const raw = wave?.getScroll?.();
    if (raw && typeof raw === 'object' && 'scrollLeft' in raw) return raw;
    const wrapper = wave?.getWrapper?.();
    if (wrapper?.parentElement) return wrapper.parentElement;
    return null;
  }

  function getViewportWidth(wave){
    const scrollEl = getScrollEl(wave);
    if (scrollEl && typeof scrollEl.clientWidth === 'number') return scrollEl.clientWidth;
    const wrapper = wave?.getWrapper?.();
    return wrapper?.clientWidth || 0;
  }

  function getContentWidth(wave){
    const scrollEl = getScrollEl(wave);
    const wrapper = wave?.getWrapper?.();
    const duration = wave?.getDuration ? (wave.getDuration() || 0) : 0;
    const px = currentZoomPxPerSec || wave?.options?.minPxPerSec || fitMinPxPerSec;
    const computed = Math.max(wrapper?.clientWidth || 0, Math.floor(duration * px));
    if (scrollEl && typeof scrollEl.scrollWidth === 'number' && scrollEl.scrollWidth) {
      if (!computed) return scrollEl.scrollWidth;
      const diff = Math.abs(scrollEl.scrollWidth - computed);
      if (diff / computed < 0.1) {
        return scrollEl.scrollWidth;
      }
    }
    return computed || scrollEl?.scrollWidth || 0;
  }

  function ensureWaveContentWidth(wave){
    if (!wave || typeof wave.getWrapper !== 'function') return;
    const wrapper = wave.getWrapper();
    if (!wrapper) return;
    const duration = wave.getDuration ? (wave.getDuration() || 0) : 0;
    if (!duration) return;
    const width = Math.max(wrapper.clientWidth || 0, Math.floor(duration * (currentZoomPxPerSec || fitMinPxPerSec)));
    wrapper.style.width = `${width}px`;
  }

  function getScrollLeft(wave){
    const scrollEl = getScrollEl(wave);
    if (scrollEl && typeof scrollEl.scrollLeft === 'number') return scrollEl.scrollLeft;
    const raw = wave?.getScroll?.();
    return typeof raw === 'number' ? raw : 0;
  }

  function setScrollLeft(wave, x){
    const scrollEl = getScrollEl(wave);
    if (scrollEl && typeof scrollEl.scrollLeft === 'number') {
      scrollEl.scrollLeft = x;
      return;
    }
    if (typeof wave?.setScroll === 'function') {
      wave.setScroll(x);
    }
  }

  function getWaveScrollEl(wave){
    return getScrollEl(wave);
  }

  function setupWaveScrollSync(){
    waveScrollCleanup.forEach((fn) => fn());
    waveScrollCleanup = [];
    const sourceScroll = getWaveScrollEl(sourceWave);
    const processedScroll = getWaveScrollEl(processedWave);
    if (!sourceScroll) return;
    const onSource = () => {
      if (scrollSyncLock) return;
      if (processedScroll) {
        scrollSyncLock = true;
        processedScroll.scrollLeft = sourceScroll.scrollLeft;
        scrollSyncLock = false;
      }
      updateScrollHints();
      updateOverviewWindow();
      syncDebug('scrollSync', { source: sourceScroll.scrollLeft, processed: processedScroll?.scrollLeft || 0 });
    };
    sourceScroll.addEventListener('scroll', onSource, { passive: true });
    waveScrollCleanup.push(() => {
      sourceScroll.removeEventListener('scroll', onSource);
    });
    if (processedScroll) {
      const onProcessed = () => {
        if (scrollSyncLock) return;
        scrollSyncLock = true;
        sourceScroll.scrollLeft = processedScroll.scrollLeft;
        scrollSyncLock = false;
        updateScrollHints();
        updateOverviewWindow();
        syncDebug('scrollSync', { source: sourceScroll.scrollLeft, processed: processedScroll.scrollLeft });
      };
      processedScroll.addEventListener('scroll', onProcessed, { passive: true });
      waveScrollCleanup.push(() => {
        processedScroll.removeEventListener('scroll', onProcessed);
      });
    }
  }

  function spectrogramUrl(rel, width, height){
    if (!rel) return '';
    const params = new URLSearchParams({
      path: rel,
      w: String(Math.round(width)),
      h: String(Math.round(height)),
      scale: 'lin',
      drange: '155',
      stereo: 'combined',
    });
    return `/api/analyze/spectrogram?${params.toString()}`;
  }

  function spectrogramHeight(){
    return 180;
  }

  function updateSpectrogramZoom(){
    if (viewMode !== 'spectrogram') return;
    const factor = zoomSteps[currentZoomIndex()] || 1;
    const height = spectrogramHeight();
    const dpr = window.devicePixelRatio || 1;
    const updateOne = (viewport, inner, img, rel) => {
      if (!viewport || !inner || !img || !rel) return;
      const viewportWidth = Math.max(1, viewport.clientWidth || 0);
      const prevInnerWidth = Math.max(1, inner.clientWidth || viewportWidth);
      const maxPrev = Math.max(1, prevInnerWidth - viewportWidth);
      const ratio = maxPrev > 1 ? (viewport.scrollLeft / maxPrev) : 0;
      const nextInnerWidth = Math.max(1, Math.round(viewportWidth * factor));
      inner.style.width = `${nextInnerWidth}px`;
      inner.style.height = `${height}px`;
      viewport.style.height = `${height}px`;
      const w = Math.max(300, Math.round(nextInnerWidth * dpr));
      const h = Math.max(120, Math.round(height * dpr));
      img.src = spectrogramUrl(rel, w, h);
      const maxNext = Math.max(0, nextInnerWidth - viewportWidth);
      viewport.scrollLeft = maxNext > 0 ? maxNext * ratio : 0;
    };
    updateOne(spectroSourceViewport, spectroSourceInner, spectroSourceImg, analysisData?.source_rel);
    updateOne(spectroProcessedViewport, spectroProcessedInner, spectroProcessedImg, analysisData?.processed_rel);
    syncWaveforms();
    updateOverviewWindow();
  }

  function setupSpectroScrollSync(){
    spectroScrollCleanup.forEach((fn) => fn());
    spectroScrollCleanup = [];
    if (!spectroSourceViewport) return;
    const onSource = () => {
      if (spectroSyncLock) return;
      if (spectroProcessedViewport) {
        spectroSyncLock = true;
        spectroProcessedViewport.scrollLeft = spectroSourceViewport.scrollLeft;
        spectroSyncLock = false;
      }
      updateOverviewWindow();
    };
    spectroSourceViewport.addEventListener('scroll', onSource, { passive: true });
    spectroScrollCleanup.push(() => {
      spectroSourceViewport.removeEventListener('scroll', onSource);
    });
    if (spectroProcessedViewport) {
      const onProcessed = () => {
        if (spectroSyncLock) return;
        spectroSyncLock = true;
        spectroSourceViewport.scrollLeft = spectroProcessedViewport.scrollLeft;
        spectroSyncLock = false;
        updateOverviewWindow();
      };
      spectroProcessedViewport.addEventListener('scroll', onProcessed, { passive: true });
      spectroScrollCleanup.push(() => {
        spectroProcessedViewport.removeEventListener('scroll', onProcessed);
      });
    }
  }

  function getMainScrollState(){
    if (viewMode === 'spectrogram') {
      if (!spectroSourceViewport || !spectroSourceInner) return null;
      return {
        viewport: spectroSourceViewport,
        scrollLeft: spectroSourceViewport.scrollLeft,
        viewportWidth: spectroSourceViewport.clientWidth || 0,
        contentWidth: spectroSourceInner.clientWidth || 0,
      };
    }
    if (!sourceWave || typeof sourceWave.getWrapper !== 'function') return null;
    const scrollEl = getScrollEl(sourceWave);
    if (!scrollEl) return null;
    const contentWidth = getContentWidth(sourceWave);
    return {
      viewport: scrollEl,
      scrollLeft: getScrollLeft(sourceWave),
      viewportWidth: getViewportWidth(sourceWave),
      contentWidth,
    };
  }

  function updateOverviewWindow(){
    const state = getMainScrollState();
    const windowEl = viewMode === 'spectrogram' ? compareMiniSpectroWindow : compareMiniWaveWindow;
    if (!state || !windowEl) return;
    const { scrollLeft, viewportWidth, contentWidth } = state;
    if (!contentWidth || !viewportWidth) return;
    const ratioStart = contentWidth > 0 ? (scrollLeft / contentWidth) : 0;
    const ratioWidth = Math.min(1, viewportWidth / contentWidth);
    windowEl.style.left = `${ratioStart * 100}%`;
    windowEl.style.width = `${ratioWidth * 100}%`;
    syncDebug('overview', { scrollLeft, viewportWidth, contentWidth, ratioStart, ratioWidth });
  }

  function scrollMainToRatio(ratio){
    const state = getMainScrollState();
    if (!state) return;
    const { viewportWidth, contentWidth } = state;
    const maxScroll = Math.max(0, contentWidth - viewportWidth);
    const target = clamp(ratio, 0, 1) * maxScroll;
    if (viewMode === 'spectrogram') {
      if (!spectroSourceViewport) return;
      spectroSyncLock = true;
      spectroSourceViewport.scrollLeft = target;
      if (spectroProcessedViewport) spectroProcessedViewport.scrollLeft = target;
      spectroSyncLock = false;
    } else {
      scrollSyncLock = true;
      setScrollLeft(sourceWave, target);
      setScrollLeft(processedWave, target);
      scrollSyncLock = false;
    }
    updateOverviewWindow();
    syncDebug('scrollMainToRatio', { ratio, target, viewMode });
  }

  function updateMiniSpectrogram(){
    if (!compareMiniSpectroViewport || !compareMiniSpectroInner) return;
    const dpr = window.devicePixelRatio || 1;
    compareMiniSpectroInner.style.width = `${compareMiniSpectroViewport.clientWidth || 0}px`;
    compareMiniSpectroInner.style.height = `${compareMiniSpectroViewport.clientHeight || 0}px`;
    const width = Math.max(240, Math.round(compareMiniSpectroViewport.clientWidth * dpr));
    const height = Math.max(60, Math.round(compareMiniSpectroViewport.clientHeight * dpr));
    if (compareMiniSpectroSourceImg && analysisData?.source_rel) {
      compareMiniSpectroSourceImg.src = spectrogramUrl(analysisData.source_rel, width, height);
    }
    if (compareMiniSpectroProcessedImg && analysisData?.processed_rel) {
      compareMiniSpectroProcessedImg.src = spectrogramUrl(analysisData.processed_rel, width, height);
    }
  }

  function bindOverviewScrub(viewport, windowEl, cleanupList){
    if (!viewport || !windowEl) return;
    let dragging = false;
    let raf = 0;
    let pendingRatio = null;

    const apply = () => {
      raf = 0;
      if (pendingRatio === null) return;
      const ratio = pendingRatio;
      pendingRatio = null;
      scrollMainToRatio(ratio);
      const duration = getDurationBase();
      if (duration) seekBoth(duration * ratio);
    };

    const schedule = (ratio) => {
      pendingRatio = ratio;
      if (!raf) raf = requestAnimationFrame(apply);
    };

    const ratioFromEvent = (evt) => {
      const rect = viewport.getBoundingClientRect();
      return clamp((evt.clientX - rect.left) / rect.width, 0, 1);
    };

    const onPointerDown = (evt) => {
      dragging = true;
      viewport.setPointerCapture?.(evt.pointerId);
      evt.preventDefault();
      schedule(ratioFromEvent(evt));
    };
    const onPointerMove = (evt) => {
      if (!dragging) return;
      schedule(ratioFromEvent(evt));
    };
    const onPointerUp = (evt) => {
      if (!dragging) return;
      dragging = false;
      if (viewport.releasePointerCapture) {
        try {
          viewport.releasePointerCapture(evt.pointerId);
        } catch (_err) {
          // ignore
        }
      }
    };

    viewport.addEventListener('pointerdown', onPointerDown);
    viewport.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    cleanupList.push(() => {
      viewport.removeEventListener('pointerdown', onPointerDown);
      viewport.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
    });
  }

  function handleSpectroClick(evt, viewport, inner){
    if (!analysisData || !viewport || !inner) return;
    const duration = getDurationBase();
    if (!duration) return;
    const rect = viewport.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const fullWidth = Math.max(inner.clientWidth || rect.width, rect.width);
    const t = Math.max(0, Math.min(duration, ((x + viewport.scrollLeft) / fullWidth) * duration));
    seekBoth(t);
  }

  function bindSpectroScrub(viewport, inner){
    if (!viewport || !inner) return;
    let dragging = false;
    const onMove = (evt) => {
      if (!dragging) return;
      handleSpectroClick(evt, viewport, inner);
    };
    const onDown = (evt) => {
      dragging = true;
      evt.preventDefault();
      handleSpectroClick(evt, viewport, inner);
    };
    const onUp = () => {
      dragging = false;
    };
    viewport.addEventListener('mousedown', onDown);
    viewport.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    transportCleanup.push(() => {
      viewport.removeEventListener('mousedown', onDown);
      viewport.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    });
  }


  function bindSpectrogramInteractions(){
    if (spectroSourceViewport) {
      spectroSourceViewport.addEventListener('click', (evt) => {
        handleSpectroClick(evt, spectroSourceViewport, spectroSourceInner);
      });
      bindSpectroScrub(spectroSourceViewport, spectroSourceInner);
    }
    if (spectroProcessedViewport) {
      spectroProcessedViewport.addEventListener('click', (evt) => {
        handleSpectroClick(evt, spectroProcessedViewport, spectroProcessedInner);
      });
      bindSpectroScrub(spectroProcessedViewport, spectroProcessedInner);
    }
  }

  function disableImageDrag(img){
    if (!img) return;
    img.addEventListener('dragstart', (evt) => evt.preventDefault());
  }

  function setViewMode(mode){
    viewMode = mode === 'spectrogram' ? 'spectrogram' : 'waveform';
    if (toggleViewWaveform) toggleViewWaveform.classList.toggle('is-active', viewMode === 'waveform');
    if (toggleViewSpectrogram) toggleViewSpectrogram.classList.toggle('is-active', viewMode === 'spectrogram');
    if (waveSourceEl) waveSourceEl.hidden = viewMode === 'spectrogram';
    if (waveProcessedEl) waveProcessedEl.hidden = viewMode === 'spectrogram';
    if (spectroSourceViewport) spectroSourceViewport.hidden = viewMode !== 'spectrogram';
    if (spectroProcessedViewport) spectroProcessedViewport.hidden = viewMode !== 'spectrogram';
    if (viewMode === 'spectrogram' && !analysisData?.processed_rel && spectroProcessedViewport) {
      spectroProcessedViewport.hidden = true;
    }
    if (compareWaveLegend) {
      compareWaveLegend.hidden = viewMode !== 'waveform';
      compareWaveLegend.style.display = viewMode === 'waveform' ? '' : 'none';
    }
    if (compareSpectroLegend) {
      compareSpectroLegend.hidden = viewMode !== 'spectrogram';
      compareSpectroLegend.style.display = viewMode === 'spectrogram' ? '' : 'none';
    }
    if (compareOverlayToggles) compareOverlayToggles.hidden = viewMode === 'spectrogram';
    setOverlayControlsEnabled(viewMode === 'waveform');
    if (compareMiniWaveViewport) compareMiniWaveViewport.hidden = viewMode !== 'waveform';
    if (compareMiniSpectroViewport) compareMiniSpectroViewport.hidden = viewMode !== 'spectrogram';
    if (viewMode === 'spectrogram') {
      waveScrollCleanup.forEach((fn) => fn());
      waveScrollCleanup = [];
      updateSpectrogramZoom();
      updateMiniSpectrogram();
      setupSpectroScrollSync();
    } else {
      spectroScrollCleanup.forEach((fn) => fn());
      spectroScrollCleanup = [];
      updateScrollHints();
      setupWaveScrollSync();
    }
    updateOverviewWindow();
  }

  function fitPxPerSecFor(wave){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const duration = wave.getDuration();
    if (!duration || duration <= 0) return null;
    const wrapper = wave.getWrapper();
    const scrollEl = getScrollEl(wave);
    const width = scrollEl?.clientWidth || wrapper?.clientWidth || 0;
    if (!width) return null;
    const fit = width / duration;
    return clamp(fit, 1, 200);
  }

  function updateFitBaseline(){
    const fits = [];
    const sourceFit = fitPxPerSecFor(sourceWave);
    if (sourceFit) fits.push(sourceFit);
    const processedFit = fitPxPerSecFor(processedWave);
    if (processedFit) fits.push(processedFit);
    if (!fits.length) return;
    const next = Math.min(...fits);
    if (Math.abs(next - fitMinPxPerSec) < 0.01) return;
    fitMinPxPerSec = next;
    setZoomLevel(currentZoomIndex());
  }

  function cleanupTransport(){
    transportCleanup.forEach((fn) => {
      try {
        fn();
      } catch (_err) {
        // ignore cleanup errors
      }
    });
    transportCleanup = [];
    stopDriftCorrection();
  }

  function setupOverviewScrub(){
    overviewCleanup.forEach((fn) => {
      try {
        fn();
      } catch (_err) {
        // ignore cleanup errors
      }
    });
    overviewCleanup = [];
    bindOverviewScrub(compareMiniWaveViewport, compareMiniWaveWindow, overviewCleanup);
    bindOverviewScrub(compareMiniSpectroViewport, compareMiniSpectroWindow, overviewCleanup);
  }

  function getClockAudio(){
    if (trackMode === 'both' && compareAudioSource?.src) return compareAudioSource;
    if (trackMode === 'source' && compareAudioSource?.src) return compareAudioSource;
    if (trackMode === 'processed' && compareAudioProcessed?.src) return compareAudioProcessed;
    return compareAudioSource?.src ? compareAudioSource : (compareAudioProcessed?.src ? compareAudioProcessed : null);
  }

  function getDurationBase(){
    const base = analysisData?.duration_s
      || compareAudioSource?.duration
      || compareAudioProcessed?.duration;
    return Number.isFinite(base) && base > 0 ? base : 0;
  }

  function updateWaveProgress(wave, time, duration){
    if (!wave) return;
    const renderer = typeof wave.getRenderer === 'function' ? wave.getRenderer() : wave.renderer;
    if (!renderer || typeof renderer.renderProgress !== 'function') return;
    const durRaw = Number.isFinite(duration) && duration > 0 ? duration : wave.getDuration();
    const dur = Number.isFinite(durRaw) && durRaw > 0 ? durRaw : 0.001;
    const rel = Math.max(0, Math.min(1, time / dur));
    renderer.renderProgress(rel, false);
  }

  function updateSpectroScrubLine(scrubEl, innerEl, time, duration){
    if (!scrubEl || !innerEl) return;
    const dur = Number.isFinite(duration) && duration > 0 ? duration : 0.001;
    const rel = Math.max(0, Math.min(1, time / dur));
    const width = Math.max(innerEl.clientWidth || 0, 1);
    scrubEl.style.left = `${rel * width}px`;
  }

  function syncWaveforms(){
    const clock = getClockAudio();
    if (!clock) return;
    const time = clock.currentTime || 0;
    const duration = getDurationBase() || clock.duration || 0;
    updateWaveProgress(sourceWave, time, duration);
    updateWaveProgress(processedWave, time, duration);
    updateSpectroScrubLine(spectroSourceScrub, spectroSourceInner, time, duration);
    updateSpectroScrubLine(spectroProcessedScrub, spectroProcessedInner, time, duration);
  }

  function seekBoth(time){
    if (transportLock) return;
    transportLock = true;
    const duration = getDurationBase();
    const target = duration ? clamp(time, 0, duration) : Math.max(0, time);
    if (compareAudioSource?.src) compareAudioSource.currentTime = target;
    if (compareAudioProcessed?.src) compareAudioProcessed.currentTime = target;
    updateWaveProgress(sourceWave, target, duration);
    updateWaveProgress(processedWave, target, duration);
    updateSpectroScrubLine(spectroSourceScrub, spectroSourceInner, target, duration);
    updateSpectroScrubLine(spectroProcessedScrub, spectroProcessedInner, target, duration);
    syncDebug('seek', { target, duration, trackMode });
    transportLock = false;
  }

  function startDriftCorrection(){
    if (driftTimer || !compareAudioSource || !compareAudioProcessed) return;
    driftTimer = setInterval(() => {
      if (trackMode !== 'both') return;
      if (compareAudioSource.paused || compareAudioProcessed.paused) return;
      const drift = Math.abs(compareAudioSource.currentTime - compareAudioProcessed.currentTime);
      if (drift > 0.06) {
        compareAudioProcessed.currentTime = compareAudioSource.currentTime;
      }
    }, 250);
  }

  function stopDriftCorrection(){
    if (driftTimer) {
      clearInterval(driftTimer);
      driftTimer = null;
    }
  }

  function playTransport(){
    const clock = getClockAudio();
    if (!clock) return;
    if ((toggleMatchLoudness && toggleMatchLoudness.checked) || gainNodes.size) {
      resumeAudioContext();
    }
    const time = clock.currentTime || 0;
    seekBoth(time);
    if ((trackMode === 'source' || trackMode === 'both') && compareAudioSource?.src) {
      compareAudioSource.play().catch(() => {});
    }
    if ((trackMode === 'processed' || trackMode === 'both') && compareAudioProcessed?.src) {
      compareAudioProcessed.play().catch(() => {});
    }
    if (trackMode === 'both') startDriftCorrection();
  }

  function pauseTransport(){
    if (compareAudioSource?.src) compareAudioSource.pause();
    if (compareAudioProcessed?.src) compareAudioProcessed.pause();
    stopDriftCorrection();
  }

  function stopTransport(){
    if (compareAudioSource?.src) {
      compareAudioSource.pause();
      compareAudioSource.currentTime = 0;
    }
    if (compareAudioProcessed?.src) {
      compareAudioProcessed.pause();
      compareAudioProcessed.currentTime = 0;
    }
    stopDriftCorrection();
    updateWaveProgress(sourceWave, 0, getDurationBase());
    updateWaveProgress(processedWave, 0, getDurationBase());
    updateSpectroScrubLine(spectroSourceScrub, spectroSourceInner, 0, getDurationBase());
    updateSpectroScrubLine(spectroProcessedScrub, spectroProcessedInner, 0, getDurationBase());
  }

  function updateTrackToggleUI(){
    const hasSource = Boolean(compareAudioSource?.src || sourceWave);
    const hasProcessed = Boolean(compareAudioProcessed?.src || processedWave);
    const sourceOn = hasSource && (trackMode === 'source' || trackMode === 'both');
    const processedOn = hasProcessed && (trackMode === 'processed' || trackMode === 'both');
    if (toggleSourceBtn) {
      toggleSourceBtn.disabled = !hasSource;
      toggleSourceBtn.classList.toggle('is-active', trackMode === 'source');
    }
    if (toggleProcessedBtn) {
      toggleProcessedBtn.disabled = !hasProcessed;
      toggleProcessedBtn.classList.toggle('is-active', trackMode === 'processed');
    }
    if (toggleBothBtn) {
      toggleBothBtn.disabled = !hasSource || !hasProcessed;
      toggleBothBtn.classList.toggle('is-active', trackMode === 'both');
    }
    if (toggleFlipBtn) {
      toggleFlipBtn.disabled = !hasSource || !hasProcessed;
    }
    if (soloSourceBtn) {
      soloSourceBtn.disabled = !hasSource;
      soloSourceBtn.classList.toggle('is-active', trackMode === 'source');
    }
    if (soloProcessedBtn) {
      soloProcessedBtn.disabled = !hasProcessed;
      soloProcessedBtn.classList.toggle('is-active', trackMode === 'processed');
    }
  }

  function applyTrackState(){
    applyMatchLoudness();
    updateTrackToggleUI();
  }

  function setTrackMode(mode){
    if (mode === 'processed' && !processedWave) {
      trackMode = 'source';
    } else if (mode === 'both' && (!sourceWave || !processedWave)) {
      trackMode = sourceWave ? 'source' : (processedWave ? 'processed' : 'source');
    } else {
      trackMode = mode;
    }
    if (trackMode !== 'both') stopDriftCorrection();
    applyTrackState();
  }

  function flipAudition(){
    if (!sourceWave || !processedWave) return;
    if (trackMode === 'processed') {
      setTrackMode('source');
    } else if (trackMode === 'source') {
      setTrackMode('processed');
    } else {
      setTrackMode('source');
    }
    resumeAudioContext();
  }

  function ignoreShortcut(evt){
    if (evt.repeat) return true;
    const target = evt.target;
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
    return Boolean(target.isContentEditable);
  }

  function setSolo(kind){
    if (kind === 'source' && sourceWave) {
      setTrackMode('source');
    }
    if (kind === 'processed' && processedWave) {
      setTrackMode('processed');
    }
  }

  function bindTransportEvents(wave){
    if (!wave) return;
    transportCleanup.push(
      wave.on('interaction', (time) => {
        if (transportLock) return;
        seekBoth(time);
      })
    );
  }

  function bindAudioEvents(audioEl){
    if (!audioEl) return;
    audioEl.addEventListener('timeupdate', () => {
      if (transportLock) return;
      syncWaveforms();
    });
    audioEl.addEventListener('play', () => {
      if (gainNodes.size) resumeAudioContext();
    });
    audioEl.addEventListener('loadedmetadata', () => {
      syncWaveforms();
    });
    audioEl.addEventListener('ended', () => {
      pauseTransport();
      syncWaveforms();
    });
  }

  function syncToggleStyles(){
    [togglePeakRisk, toggleHeatmap, toggleDelta, toggleMatchLoudness].forEach((el) => {
      if (!el) return;
      const label = el.closest('.analyze-toggle');
      if (label) label.classList.toggle('is-active', el.checked);
    });
  }

  function setOverlayControlsEnabled(enabled){
    [togglePeakRisk, toggleHeatmap, toggleDelta].forEach((el) => {
      if (!el) return;
      el.disabled = !enabled;
      const label = el.closest('.analyze-toggle');
      if (label) label.classList.toggle('is-disabled', !enabled);
    });
  }

  function overlayState(){
    return {
      peak: togglePeakRisk ? togglePeakRisk.checked : true,
      heatmap: toggleHeatmap ? toggleHeatmap.checked : true,
      delta: toggleDelta ? toggleDelta.checked : false,
    };
  }

  function cleanupOverlays(){
    overlayCleanup.forEach((fn) => {
      try {
        fn();
      } catch (_err) {
        // ignore cleanup errors
      }
    });
    overlayCleanup = [];
  }

  function cleanupGainNodes(){
    volumeRafs.forEach((rafId) => cancelAnimationFrame(rafId));
    volumeRafs.clear();
    gainNodes.forEach((state) => {
      try {
        state.source.disconnect();
      } catch (_err) {
        // ignore disconnect errors
      }
      try {
        state.gain.disconnect();
      } catch (_err) {
        // ignore disconnect errors
      }
      if (state.audio) {
        state.audio.muted = false;
        if (typeof state.audio.volume === 'number') {
          state.audio.volume = 1;
        }
      }
    });
    gainNodes.clear();
  }

  function percentile(values, p){
    if (!values.length) return null;
    const sorted = [...values].sort((a, b) => a - b);
    const idx = Math.max(0, Math.min(sorted.length - 1, Math.floor((sorted.length - 1) * p)));
    return sorted[idx];
  }

  function seriesStats(values){
    const clean = (values || []).filter((v) => typeof v === 'number' && !Number.isNaN(v));
    if (!clean.length) return null;
    const sum = clean.reduce((acc, val) => acc + val, 0);
    const avg = sum / clean.length;
    return {
      len: clean.length,
      min: Math.min(...clean),
      max: Math.max(...clean),
      avg,
    };
  }

  function validateSeries(series){
    if (!series) return;
    const srcStats = seriesStats(series.lufs_st_source);
    const procStats = seriesStats(series.lufs_st_processed);
    if (!procStats) {
      console.warn('[compare] processed ST series missing; heatmap will fall back to source');
      return;
    }
    if (srcStats && procStats && srcStats.len === procStats.len) {
      const diff = Math.abs((procStats.avg || 0) - (srcStats.avg || 0));
      if (diff < 0.01) {
        console.info('[compare] ST series are very similar; verify processed series mapping');
      }
    }
  }

  function ensureOverlayCanvas(wave, kind, layer){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const wrapper = wave.getWrapper();
    if (!wrapper) return null;
    const scrollEl = getScrollEl(wave);
    const layerClass = `analysis-overlay-${kind}-${layer}`;
    let canvas = wrapper.querySelector(`canvas.${layerClass}`);
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.className = `analysis-overlay analysis-overlay-${kind} ${layerClass}`;
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.pointerEvents = 'none';
      wrapper.style.position = 'relative';
      if (layer === 'heatmap' && wrapper.firstChild) {
        wrapper.insertBefore(canvas, wrapper.firstChild);
      } else {
        wrapper.appendChild(canvas);
      }
    }
    canvas.style.zIndex = layer === 'heatmap' ? '0' : '5';
    const width = Math.max(scrollEl?.scrollWidth || wrapper.clientWidth || 0, 1);
    const height = Math.max(wrapper.clientHeight || 1, 1);
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(width * ratio));
    canvas.height = Math.max(1, Math.round(height * ratio));
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return { canvas, ctx, wrapper, width, height };
  }

  function ensureReferenceLines(wave, kind){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const wrapper = wave.getWrapper();
    if (!wrapper) return null;
    let box = wrapper.querySelector(`.wave-ref-lines-${kind}`);
    if (!box) {
      box = document.createElement('div');
      box.className = `wave-ref-lines wave-ref-lines-${kind}`;
      box.style.position = 'absolute';
      box.style.top = '0';
      box.style.left = '0';
      box.style.pointerEvents = 'none';
      box.style.zIndex = '4';
      wrapper.style.position = 'relative';
      wrapper.appendChild(box);
      const center = document.createElement('div');
      center.className = 'wave-ref-line center';
      center.style.position = 'absolute';
      center.style.left = '0';
      center.style.right = '0';
      center.style.height = '1px';
      box.appendChild(center);
      const clipTop = document.createElement('div');
      clipTop.className = 'wave-ref-line clip';
      clipTop.style.position = 'absolute';
      clipTop.style.left = '0';
      clipTop.style.right = '0';
      clipTop.style.height = '1px';
      box.appendChild(clipTop);
      const clipBottom = document.createElement('div');
      clipBottom.className = 'wave-ref-line clip';
      clipBottom.style.position = 'absolute';
      clipBottom.style.left = '0';
      clipBottom.style.right = '0';
      clipBottom.style.height = '1px';
      box.appendChild(clipBottom);
      const safeTop = document.createElement('div');
      safeTop.className = 'wave-ref-line safe';
      safeTop.style.position = 'absolute';
      safeTop.style.left = '0';
      safeTop.style.right = '0';
      safeTop.style.height = '0';
      safeTop.style.opacity = '0';
      box.appendChild(safeTop);
      const safeBottom = document.createElement('div');
      safeBottom.className = 'wave-ref-line safe';
      safeBottom.style.position = 'absolute';
      safeBottom.style.left = '0';
      safeBottom.style.right = '0';
      safeBottom.style.height = '0';
      safeBottom.style.opacity = '0';
      box.appendChild(safeBottom);
    }
    return box;
  }

  function updateReferenceLines(wave, kind){
    if (!wave || typeof wave.getWrapper !== 'function') return;
    const wrapper = wave.getWrapper();
    const box = ensureReferenceLines(wave, kind);
    if (!wrapper || !box) return;
    const height = Math.max(wrapper.clientHeight || 0, 1);
    const width = Math.max(getContentWidth(wave) || wrapper.clientWidth || 0, 1);
    box.style.width = `${width}px`;
    box.style.height = `${height}px`;
    const lines = box.querySelectorAll('.wave-ref-line');
    const center = lines[0];
    const clipTop = lines[1];
    const clipBottom = lines[2];
    const safeTop = lines[3];
    const safeBottom = lines[4];
    const half = height * 0.5;
    const padding = 2;
    if (center) center.style.top = `${Math.round(half)}px`;
    if (clipTop) clipTop.style.top = `${padding}px`;
    if (clipBottom) clipBottom.style.top = `${Math.max(padding, height - padding - 1)}px`;
    const amp = Math.pow(10, -1 / 20);
    const safeOffset = amp * (half - padding);
    if (safeTop) safeTop.style.top = `${Math.max(padding, Math.round(half - safeOffset))}px`;
    if (safeBottom) safeBottom.style.top = `${Math.min(height - padding, Math.round(half + safeOffset))}px`;
    if (togglePeakRisk) {
      const showSafe = togglePeakRisk.checked;
      box.classList.toggle('show-safe', showSafe);
      if (safeTop) safeTop.style.opacity = showSafe ? '1' : '0';
      if (safeBottom) safeBottom.style.opacity = showSafe ? '1' : '0';
    }
  }

  function drawHeatmap(ctx, width, height, t, values, duration){
    if (!t.length || !values.length || !duration) return;
    const clean = values.filter((v) => typeof v === 'number' && !Number.isNaN(v));
    if (clean.length < 2) return;
    const minVal = percentile(clean, 0.1);
    const maxVal = percentile(clean, 0.9);
    if (minVal === null || maxVal === null || maxVal <= minVal) return;
    const low = [24, 48, 76];
    const high = [255, 138, 61];
    const step = width / values.length;
    for (let i = 0; i < values.length; i += 1) {
      const val = values[i];
      if (typeof val !== 'number' || Number.isNaN(val)) continue;
      const norm = Math.max(0, Math.min(1, (val - minVal) / (maxVal - minVal)));
      const r = Math.round(low[0] + (high[0] - low[0]) * norm);
      const g = Math.round(low[1] + (high[1] - low[1]) * norm);
      const b = Math.round(low[2] + (high[2] - low[2]) * norm);
      const alpha = 0.08 + norm * 0.32;
      const x = (t[i] / duration) * width;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      ctx.fillRect(x - step * 0.5, 0, step, height);
    }
  }

  function drawDelta(ctx, width, height, t, values, duration){
    if (!t.length || !values.length || !duration) return;
    const clean = values.filter((v) => typeof v === 'number' && !Number.isNaN(v));
    if (!clean.length) return;
    const absVals = clean.map((v) => Math.abs(v));
    let maxAbs = percentile(absVals, 0.9) || Math.max(...absVals);
    if (!maxAbs || maxAbs < 0.1) maxAbs = 0.1;
    const mid = height * 0.5;
    const scale = (height * 0.35) / maxAbs;
    ctx.save();
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.beginPath();
    ctx.moveTo(0, mid);
    ctx.lineTo(width, mid);
    ctx.stroke();
    const drawSign = (sign, color) => {
      ctx.strokeStyle = color;
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < values.length; i += 1) {
        const val = values[i];
        if (typeof val !== 'number' || Number.isNaN(val) || val * sign <= 0) {
          started = false;
          continue;
        }
        const x = (t[i] / duration) * width;
        const y = mid - (val * scale);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    };
    drawSign(1, 'rgba(60, 214, 186, 0.9)');
    drawSign(-1, 'rgba(255, 96, 96, 0.9)');
    ctx.restore();
  }

  function drawMarkers(ctx, width, height, duration, markers){
    if (!duration || !markers || !markers.length) return;
    ctx.save();
    markers.forEach((marker) => {
      if (!marker || typeof marker.t !== 'number') return;
      const x = (marker.t / duration) * width;
      const isClip = marker.severity === 'clip';
      ctx.strokeStyle = isClip ? 'rgba(255, 88, 88, 0.85)' : 'rgba(255, 184, 77, 0.45)';
      ctx.lineWidth = isClip ? 1.4 : 1.0;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    });
    ctx.restore();
  }

  function nearestIndex(arr, t){
    if (!arr || !arr.length) return -1;
    let lo = 0;
    let hi = arr.length - 1;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const val = arr[mid];
      if (val === t) return mid;
      if (val < t) lo = mid + 1;
      else hi = mid - 1;
    }
    const idx = Math.max(0, Math.min(arr.length - 1, lo));
    if (idx > 0 && Math.abs(arr[idx - 1] - t) < Math.abs(arr[idx] - t)) {
      return idx - 1;
    }
    return idx;
  }

  function nearestMarker(markers, t, window){
    if (!markers || !markers.length) return null;
    let lo = 0;
    let hi = markers.length - 1;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const val = markers[mid].t;
      if (val === t) return markers[mid];
      if (val < t) lo = mid + 1;
      else hi = mid - 1;
    }
    const idx = Math.max(0, Math.min(markers.length - 1, lo));
    const candidates = [markers[idx], markers[idx - 1]].filter(Boolean);
    let best = null;
    let bestDist = window;
    candidates.forEach((m) => {
      const dist = Math.abs(m.t - t);
      if (dist <= bestDist) {
        best = m;
        bestDist = dist;
      }
    });
    return best;
  }

  function updateTooltip(evt, kind, scrollEl, wrapper){
    if (!analysisData || !analysisData.series || !scrollEl || !wrapper) return;
    const rect = scrollEl.getBoundingClientRect();
    if (!rect.width) return;
    const duration = analysisData.duration_s || (kind === 'source' ? sourceWave?.getDuration() : processedWave?.getDuration());
    if (!duration) return;
    const x = evt.clientX - rect.left;
    const fullWidth = Math.max(scrollEl.scrollWidth || rect.width, rect.width);
    const scrollLeft = scrollEl.scrollLeft || 0;
    const t = Math.max(0, Math.min(duration, ((x + scrollLeft) / fullWidth) * duration));
    const seriesT = analysisData.series.t || [];
    const idx = nearestIndex(seriesT, t);
    const state = overlayState();
    const lines = [];
    if (state.heatmap && idx >= 0) {
      const sVal = analysisData.series.lufs_st_source?.[idx];
      const pVal = analysisData.series.lufs_st_processed?.[idx];
      if (typeof sVal === 'number') lines.push(`Source ST: ${fmt(sVal, 1)} LUFS`);
      if (typeof pVal === 'number') lines.push(`Processed ST: ${fmt(pVal, 1)} LUFS`);
    }
    if (state.delta && kind === 'processed' && idx >= 0) {
      const dVal = analysisData.series.lufs_st_delta?.[idx];
      if (typeof dVal === 'number') lines.push(`Δ Loudness: ${fmt(dVal, 1)} LU`);
    }
    if (state.peak) {
      const markerList = analysisData.markers?.true_peak?.[kind === 'processed' ? 'processed' : 'source'] || [];
      const marker = nearestMarker(markerList, t, 0.15);
      if (marker) {
        const label = kind === 'processed' ? 'Processed' : 'Source';
        lines.push(`True Peak (${label}): ${fmt(marker.value, 1)} dBTP`);
      }
    }
    wrapper.title = lines.join('\n');
  }

  function drawOverlay(wave, kind){
    if (!wave) return;
    updateReferenceLines(wave, kind);
    const heatmap = ensureOverlayCanvas(wave, kind, 'heatmap');
    const overlay = ensureOverlayCanvas(wave, kind, 'overlay');
    if (!heatmap || !overlay) return;
    const { ctx: heatCtx, width, height } = heatmap;
    const { ctx: overlayCtx } = overlay;
    heatCtx.clearRect(0, 0, width, height);
    overlayCtx.clearRect(0, 0, width, height);
    if (!analysisData || !analysisData.series) return;
    const duration = analysisData.duration_s || wave.getDuration() || 0;
    if (!duration) return;
    const state = overlayState();
    const t = analysisData.series.t || [];
    if (!t.length) return;
    const sourceVals = analysisData.series.lufs_st_source || [];
    const processedVals = analysisData.series.lufs_st_processed || [];
    const deltaVals = analysisData.series.lufs_st_delta || [];
    if (state.heatmap) {
      const values = (kind === 'processed' && processedVals.length) ? processedVals : sourceVals;
      drawHeatmap(heatCtx, width, height, t, values, duration);
    }
    if (state.delta && kind === 'processed' && deltaVals.length) {
      drawDelta(overlayCtx, width, height, t, deltaVals, duration);
    }
    if (state.peak) {
      const markerList = analysisData.markers?.true_peak?.[kind === 'processed' ? 'processed' : 'source'] || [];
      drawMarkers(overlayCtx, width, height, duration, markerList);
    }
  }

  const overlayDrawRaf = { source: 0, processed: 0 };

  function scheduleOverlayDraw(wave, kind){
    if (!wave) return;
    if (overlayDrawRaf[kind]) return;
    overlayDrawRaf[kind] = requestAnimationFrame(() => {
      overlayDrawRaf[kind] = 0;
      drawOverlay(wave, kind);
      updateScrollHints();
    });
  }

  function drawOverlays(){
    scheduleOverlayDraw(sourceWave, 'source');
    scheduleOverlayDraw(processedWave, 'processed');
  }

  function bindDragScroll(wave){
    if (!wave || typeof wave.getWrapper !== 'function') return () => {};
    const scrollEl = getScrollEl(wave);
    const host = waveHost(wave);
    if (!scrollEl || !host) return () => {};
    let dragging = false;
    let dragged = false;
    let startX = 0;
    let startScroll = 0;
    scrollEl.style.cursor = 'grab';

    const onDown = (evt) => {
      if (evt.button !== 0) return;
      dragging = false;
      dragged = false;
      startX = evt.clientX;
      startScroll = scrollEl.scrollLeft;
      host.classList.add('is-dragging');
      scrollEl.style.cursor = 'grabbing';
    };
    const onMove = (evt) => {
      if (!host.classList.contains('is-dragging')) return;
      const dx = evt.clientX - startX;
      if (!dragging && Math.abs(dx) < 4) return;
      dragging = true;
      dragged = true;
      scrollEl.scrollLeft = startScroll - dx;
      evt.preventDefault();
    };
    const onUp = () => {
      if (host.classList.contains('is-dragging')) {
        host.classList.remove('is-dragging');
        scrollEl.style.cursor = 'grab';
      }
      dragging = false;
    };
    const onClick = (evt) => {
      if (!dragged) return;
      evt.preventDefault();
      evt.stopPropagation();
      dragged = false;
    };

    host.addEventListener('pointerdown', onDown);
    host.addEventListener('click', onClick, true);
    window.addEventListener('pointermove', onMove, { passive: false });
    window.addEventListener('pointerup', onUp);
    return () => {
      host.removeEventListener('pointerdown', onDown);
      host.removeEventListener('click', onClick, true);
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
    };
  }

  function bindOverlayEvents(wave, kind){
    if (!wave) return () => {};
    const cleanup = [];
    const draw = () => scheduleOverlayDraw(wave, kind);
    cleanup.push(wave.on('ready', draw));
    cleanup.push(wave.on('redraw', draw));
    cleanup.push(wave.on('zoom', draw));
    cleanup.push(wave.on('resize', draw));
    const onResize = () => scheduleOverlayDraw(wave, kind);
    window.addEventListener('resize', onResize);
    cleanup.push(() => window.removeEventListener('resize', onResize));
    const wrapper = typeof wave.getWrapper === 'function' ? wave.getWrapper() : null;
    const scrollEl = getScrollEl(wave);
    if (scrollEl && wrapper) {
      const onMove = (evt) => updateTooltip(evt, kind, scrollEl, wrapper);
      const onLeave = () => { scrollEl.title = ''; };
      scrollEl.addEventListener('mousemove', onMove);
      scrollEl.addEventListener('mouseleave', onLeave);
      const onScroll = () => updateScrollHints();
      scrollEl.addEventListener('scroll', onScroll, { passive: true });
      cleanup.push(() => {
        scrollEl.removeEventListener('mousemove', onMove);
        scrollEl.removeEventListener('mouseleave', onLeave);
        scrollEl.removeEventListener('scroll', onScroll);
      });
    }
    return () => cleanup.forEach((fn) => fn && fn());
  }

  function setupOverlays(){
    cleanupOverlays();
    if (sourceWave) overlayCleanup.push(bindOverlayEvents(sourceWave, 'source'));
    if (processedWave) overlayCleanup.push(bindOverlayEvents(processedWave, 'processed'));
    drawOverlays();
  }

  function clearWaves(){
    cleanupOverlays();
    cleanupTransport();
    cleanupGainNodes();
    if (sourceWave) {
      sourceWave.destroy();
      sourceWave = null;
    }
    if (processedWave) {
      processedWave.destroy();
      processedWave = null;
    }
    if (miniSourceWave) {
      miniSourceWave.destroy();
      miniSourceWave = null;
    }
    if (miniProcessedWave) {
      miniProcessedWave.destroy();
      miniProcessedWave = null;
    }
    if (compareAudioSource) {
      compareAudioSource.pause();
      compareAudioSource.removeAttribute('src');
      compareAudioSource.load();
    }
    if (compareAudioProcessed) {
      compareAudioProcessed.pause();
      compareAudioProcessed.removeAttribute('src');
      compareAudioProcessed.load();
    }
  }

  function initWave(containerId){
    const el = document.getElementById(containerId);
    if (!el || !window.WaveSurfer) return null;
    const zoomIdx = currentZoomIndex();
    return WaveSurfer.create({
      container: el,
      waveColor: '#2a3a4f',
      progressColor: '#3b4f66',
      cursorColor: '#6b829a',
      height: 180,
      normalize: false,
      backend: 'MediaElement',
      scrollParent: true,
      interact: false,
      dragToSeek: false,
      minPxPerSec: Math.max(1, fitMinPxPerSec) * zoomSteps[zoomIdx],
      fillParent: false,
      autoScroll: false,
      autoCenter: false,
    });
  }

  function initMiniWave(containerId){
    const el = document.getElementById(containerId);
    if (!el || !window.WaveSurfer) return null;
    return WaveSurfer.create({
      container: el,
      waveColor: '#2a3a4f',
      progressColor: '#2a3a4f',
      cursorColor: 'transparent',
      height: 34,
      normalize: false,
      backend: 'MediaElement',
      minPxPerSec: Math.max(1, fitMinPxPerSec),
      fillParent: true,
      autoScroll: false,
      autoCenter: false,
      interact: false,
      cursorWidth: 0,
    });
  }

  async function loadWave(wave, url){
    if (!wave || !url) return;
    return new Promise((resolve) => {
      const done = () => resolve();
      wave.once('ready', done);
      wave.once('error', () => {
        done();
        if (typeof showToast === 'function') {
          showToast('Waveform failed to load');
        }
      });
      wave.load(url);
    });
  }

  async function loadMiniWave(wave, url){
    if (!wave || !url) return;
    return new Promise((resolve) => {
      const done = () => resolve();
      wave.once('ready', done);
      wave.once('error', done);
      wave.load(url);
    });
  }

  function renderPills(input, output){
    if (!summaryPills) return;
    summaryPills.innerHTML = '';
    metricLabels.forEach(meta => {
      const outVal = output ? output[meta.key] : null;
      if (outVal === null || outVal === undefined) return;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      const delta = formatDelta(outVal, input ? input[meta.key] : null);
      pill.textContent = `${meta.label}: ${fmt(outVal, 1)}${meta.suffix}${delta}`;
      summaryPills.appendChild(pill);
    });
  }

  function renderCompare(input, output){
    if (!compareGrid) return;
    compareGrid.innerHTML = '';
    const headers = ['Metric', 'Source', 'Processed', 'Delta'];
    headers.forEach(label => {
      const cell = document.createElement('div');
      cell.className = 'compare-cell compare-head';
      cell.textContent = label;
      compareGrid.appendChild(cell);
    });
    metricLabels.forEach(meta => {
      const inVal = input ? input[meta.key] : null;
      const outVal = output ? output[meta.key] : null;
      const row = [
        meta.label,
        displayMetric(inVal, meta.suffix),
        displayMetric(outVal, meta.suffix),
        formatDelta(outVal, inVal).replace(/[()]/g, '') || '-',
      ];
      row.forEach((value, idx) => {
        const cell = document.createElement('div');
        cell.className = idx === 0 ? 'compare-cell compare-metric' : 'compare-cell';
        cell.textContent = value;
        compareGrid.appendChild(cell);
      });
    });
  }

  function syncPreserveLinks(params){
    const search = params.toString();
    document.querySelectorAll('a[data-preserve-query="true"]').forEach((link) => {
      const href = link.getAttribute('href');
      if (!href) return;
      try {
        const url = new URL(href, window.location.origin);
        url.search = search;
        link.setAttribute('href', `${url.pathname}${url.search}`);
      } catch (_err) {
        return;
      }
    });
  }

  function updateUrl(params){
    const next = new URL(window.location.href);
    next.search = params.toString();
    window.history.pushState({}, '', next.toString());
    syncPreserveLinks(params);
  }

  function openInNoiseRemoval(){
    if (!analysisData?.source_rel) return;
    const url = new URL('/analyze', window.location.origin);
    url.searchParams.set('src', analysisData.source_rel);
    if (analysisData.processed_rel) {
      url.searchParams.set('proc', analysisData.processed_rel);
    }
    window.location.assign(`${url.pathname}${url.search}`);
  }

  function updateControls(){
    const hasSource = Boolean(compareAudioSource?.src || sourceWave);
    const hasProcessed = Boolean(compareAudioProcessed?.src || processedWave);
    const processedCanvas = document.getElementById('waveProcessed');
    if (processedCanvas) processedCanvas.style.display = hasProcessed ? '' : 'none';
    if (playBtn) playBtn.disabled = !hasSource;
    if (pauseBtn) pauseBtn.disabled = !hasSource;
    if (stopBtn) stopBtn.disabled = !hasSource;
    if (zoomRange) zoomRange.disabled = !hasSource;
    if (processedEmpty) processedEmpty.hidden = hasProcessed;
  }

  function extractRelFromUrl(url){
    if (!url) return null;
    try {
      const parsed = new URL(url, window.location.origin);
      return parsed.searchParams.get('path');
    } catch (_err) {
      return null;
    }
  }

  let selectedSummaryLocked = false;

  function setSelectedSummary(name, meta){
    if (!compareSelectedName || !compareSelectedMeta) return;
    compareSelectedName.textContent = name || '-';
    compareSelectedMeta.textContent = meta || 'No file selected.';
  }

  function formatSelectedMeta(kind, format, duration){
    const parts = [];
    if (kind) parts.push(kind);
    if (format) parts.push(String(format).toUpperCase());
    if (typeof duration === 'number' && Number.isFinite(duration)) {
      parts.push(`${Math.round(duration)}s`);
    }
    return parts.join(' • ');
  }

  function normalizeMetrics(metrics){
    if (!metrics || typeof metrics !== 'object') return null;
    if (metrics.output && typeof metrics.output === 'object') return metrics.output;
    if (metrics.input && typeof metrics.input === 'object') return metrics.input;
    return metrics;
  }

  function getMetricValue(metrics, keys){
    const data = normalizeMetrics(metrics);
    if (!data) return null;
    const list = Array.isArray(keys) ? keys : [keys];
    for (const key of list) {
      if (typeof data[key] === 'number' && Number.isFinite(data[key])) return data[key];
    }
    return null;
  }

  function applyClipState(kind, metrics){
    const data = normalizeMetrics(metrics);
    const body = kind === 'processed' ? processedWaveBody : sourceWaveBody;
    const metaEl = kind === 'processed' ? processedClipMeta : sourceClipMeta;
    if (!body) return;
    const tp = getMetricValue(data, ['true_peak_dbtp', 'true_peak_db', 'true_peak', 'TP']);
    const peak = getMetricValue(data, ['peak_db', 'peak_level']);
    const clip = (typeof tp === 'number' && tp >= 0) || (typeof peak === 'number' && peak >= 0);
    body.classList.toggle('is-clip', Boolean(clip));
    if (metaEl) {
      const tpMargin = getMetricValue(data, ['tp_margin']);
      if (typeof tpMargin === 'number') {
        metaEl.textContent = `TP Margin ${tpMargin.toFixed(1)}`;
      } else {
        metaEl.textContent = 'TP Margin —';
      }
    }
  }

  function updateSelectedFromPayload(payload){
    if (selectedSummaryLocked) return;
    if (!payload) return;
    const hasProcessed = Boolean(payload.processed_url);
    const name = hasProcessed ? (payload.processed_name || payload.source_name) : payload.source_name;
    const kind = hasProcessed ? 'Processed' : 'Source';
    setSelectedSummary(name || '-', formatSelectedMeta(kind, null, payload.duration_s));
  }

  async function applyData(payload){
    if (!payload) return;
    const input = payload.metrics?.input || null;
    const output = payload.metrics?.output || null;
    updateAnalysisLufs(payload, input, output);
    const durationFallback = payload.duration_s ?? output?.duration_sec ?? input?.duration_sec ?? null;
    const sourceRel = extractRelFromUrl(payload.source_url);
    const processedRel = extractRelFromUrl(payload.processed_url);
    analysisData = {
      duration_s: durationFallback,
      series: payload.series || null,
      markers: payload.markers || null,
      source_rel: sourceRel,
      processed_rel: processedRel,
    };
    validateSeries(analysisData.series);

    if (analyzeSubtitle) {
      const name = payload.run_id ? `Run ${payload.run_id}` : 'Standalone analysis';
      analyzeSubtitle.textContent = name;
    }
    if (sourceName) sourceName.textContent = payload.source_name || 'Source';
    if (processedName) processedName.textContent = payload.processed_name || '-';

    if (emptyState) emptyState.hidden = true;
    if (loadedState) loadedState.hidden = false;

    renderPills(input, output);
    renderCompare(input, output);
    applyClipState('source', input);
    applyClipState('processed', output);

    clearWaves();
    sourceWave = initWave('waveSource');
    processedWave = payload.processed_url ? initWave('waveProcessed') : null;
    miniSourceWave = initMiniWave('compareMiniWaveSource');
    miniProcessedWave = payload.processed_url ? initMiniWave('compareMiniWaveProcessed') : null;
    if (compareMiniWaveProcessed) {
      compareMiniWaveProcessed.style.display = payload.processed_url ? '' : 'none';
    }
    if (compareMiniSpectroProcessedImg) {
      compareMiniSpectroProcessedImg.style.display = payload.processed_url ? '' : 'none';
    }

    if (compareAudioSource) {
      if (payload.source_url) {
        compareAudioSource.src = payload.source_url;
      } else {
        compareAudioSource.removeAttribute('src');
      }
      compareAudioSource.load();
    }
    if (compareAudioProcessed) {
      if (payload.processed_url) {
        compareAudioProcessed.src = payload.processed_url;
      } else {
        compareAudioProcessed.removeAttribute('src');
      }
      compareAudioProcessed.load();
    }

    await loadWave(sourceWave, payload.source_url);
    if (processedWave) {
      await loadWave(processedWave, payload.processed_url);
    }
    await loadMiniWave(miniSourceWave, payload.source_url);
    if (miniProcessedWave) {
      await loadMiniWave(miniProcessedWave, payload.processed_url);
    }
    updateFitBaseline();
    trackMode = processedWave ? 'both' : 'source';
    applyTrackState();
    cleanupTransport();
    bindTransportEvents(sourceWave);
    bindTransportEvents(processedWave);
    updateControls();
    setupOverlays();
    setupOverviewScrub();
    setViewMode(viewMode);
    updateMiniSpectrogram();
    updateSelectedFromPayload(payload);
    syncWaveforms();
    updateOverviewWindow();
  }

  async function resolveRun(song, out, solo){
    const params = new URLSearchParams();
    params.set('song', song);
    if (out) params.set('out', out);
    if (solo) params.set('solo', '1');
    const res = await fetch(`/api/analyze-resolve?${params.toString()}`);
    if (!res.ok) {
      throw new Error('resolve_failed');
    }
    return res.json();
  }

  async function resolveFile(kind, rel){
    const params = new URLSearchParams();
    if (kind === 'source') {
      params.set('src', rel);
    } else if (kind === 'import') {
      params.set('imp', rel);
    }
    const res = await fetch(`/api/analyze-resolve-file?${params.toString()}`);
    if (!res.ok) {
      throw new Error('resolve_failed');
    }
    return res.json();
  }

  async function resolvePair(srcRel, procRel){
    const params = new URLSearchParams();
    params.set('src', srcRel);
    params.set('proc', procRel);
    const res = await fetch(`/api/analyze-resolve-pair?${params.toString()}`);
    if (!res.ok) {
      throw new Error('resolve_failed');
    }
    return res.json();
  }

  function normalizeLibraryRel(rel){
    if (!rel) return null;
    const raw = String(rel);
    if (raw.startsWith('in/')) return { kind: 'source', rel: raw.slice(3) };
    if (raw.startsWith('analysis/')) return { kind: 'import', rel: raw.slice(9) };
    if (raw.startsWith('library/songs/')) {
      if (raw.includes('/source/')) return { kind: 'source', rel: raw };
      return { kind: 'import', rel: raw };
    }
    return { kind: 'any', rel: raw };
  }

  function primaryRendition(renditions){
    const list = Array.isArray(renditions) ? renditions : [];
    if (!list.length) return null;
    const prefer = ['wav', 'flac', 'aiff', 'aif', 'm4a', 'aac', 'mp3', 'ogg'];
    for (const fmt of prefer) {
      const hit = list.find(item => String(item.format || '').toLowerCase() === fmt);
      if (hit) return hit;
    }
    return list[0];
  }

  async function loadLibrarySelection(song, track, shouldPush){
    if (!track?.rel) return;
    selectedSummaryLocked = true;
    const kindLabel = track.kind === 'version' ? 'Version' : 'Source';
    const format = track.format || primaryRendition(track.renditions)?.format || (track.kind === 'version' ? null : song?.source?.format);
    const duration = track.duration || song?.source?.duration_sec;
    setSelectedSummary(song?.title || track.title || 'Untitled', formatSelectedMeta(kindLabel, format, duration));
    const sourceRel = song?.source?.rel || null;
    if (track.kind === 'version' && sourceRel) {
      addStatusLine(`Loading ${song?.title || 'selection'}...`);
      if (shouldPush) updateUrl(new URLSearchParams({ src: sourceRel, proc: track.rel }));
      const data = await resolvePair(sourceRel, track.rel);
      await applyData(data);
      addStatusLine('Compare ready');
      return;
    }
    const parsed = normalizeLibraryRel(track.rel);
    if (parsed?.kind === 'source' || parsed?.kind === 'import') {
      addStatusLine(`Loading ${parsed.kind}...`);
      const params = new URLSearchParams();
      params.set(parsed.kind === 'source' ? 'src' : 'imp', parsed.rel);
      if (shouldPush) updateUrl(params);
      const data = await resolveFile(parsed.kind, parsed.rel);
      await applyData(data);
      addStatusLine('Compare ready');
      return;
    }
    if (sourceRel) {
      addStatusLine(`Loading ${song?.title || 'selection'}...`);
      if (shouldPush) updateUrl(new URLSearchParams({ src: sourceRel, proc: track.rel }));
      const data = await resolvePair(sourceRel, track.rel);
      await applyData(data);
      addStatusLine('Compare ready');
      return;
    }
    addStatusLine('Compare failed');
  }

  async function selectAndLoad(item, _node, shouldPush){
    if (!item) return;
    selectedItem = item;
    selectedSummaryLocked = false;
    try {
      if (item.kind === 'mastering_output') {
        addStatusLine(`Loading run ${item.song}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (item.out) params.set('out', item.out);
        if (item.solo) params.set('solo', '1');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', item.solo);
        await applyData(data);
        addStatusLine('Compare ready');
      } else if (item.kind === 'mastering_run') {
        addStatusLine(`Loading run ${item.song || item.id}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', false);
        await applyData(data);
        addStatusLine('Compare ready');
      } else if (item.kind === 'source' || item.kind === 'import') {
        addStatusLine(`Loading ${item.kind}...`);
        const params = new URLSearchParams();
        params.set(item.kind === 'source' ? 'src' : 'imp', item.rel);
        if (shouldPush) updateUrl(params);
        const data = await resolveFile(item.kind, item.rel);
        await applyData(data);
        addStatusLine('Compare ready');
      }
    } catch (_err) {
      addStatusLine('Compare failed');
      if (typeof showToast === 'function') showToast('Compare data unavailable');
    }
  }

  async function uploadFile(file){
    return new Promise((resolve, reject) => {
      const fd = new FormData();
      fd.append('file', file, file.name);
      const xhr = new XMLHttpRequest();
      xhr.open('POST', '/api/analyze-upload', true);
      xhr.responseType = 'json';
      xhr.upload.addEventListener('progress', (evt) => {
        if (!evt.lengthComputable) return;
        const pct = (evt.loaded / evt.total) * 100;
        setStatusProgress(pct, true);
      });
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(xhr.response || {});
        } else {
          reject(new Error('upload_failed'));
        }
      });
      xhr.addEventListener('error', () => reject(new Error('upload_failed')));
      xhr.send(fd);
    });
  }

  if (uploadBtn && uploadInput) {
    uploadBtn.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', async () => {
      const file = (uploadInput.files || [])[0];
      if (!file) return;
      selectedSummaryLocked = false;
      try {
        addStatusLine(`Uploading ${file.name}...`);
        setStatusProgress(0, true);
        if (typeof showToast === 'function') showToast('Uploading...');
        const data = await uploadFile(file);
        addStatusLine('Upload complete');
        addStatusLine('Analyzing...');
        if (data.rel) {
          const payload = await resolveFile('source', data.rel);
          await applyData(payload);
        }
        addStatusLine('Compare ready');
        setStatusProgress(100, false);
        if (data.rel) {
          const item = { kind: 'source', rel: data.rel };
          selectedItem = item;
          const params = new URLSearchParams();
          params.set('src', data.rel);
          updateUrl(params);
          if (libraryBrowser) libraryBrowser.reload();
        }
        if (typeof showToast === 'function') showToast('Compare ready');
      } catch (_err) {
        addStatusLine('Upload or analysis failed');
        setStatusProgress(0, false);
        if (typeof showToast === 'function') showToast('Upload failed');
      } finally {
        uploadInput.value = '';
      }
    });
  }
  if (openNoiseRemovalBtn) {
    openNoiseRemovalBtn.addEventListener('click', () => {
      openInNoiseRemoval();
    });
  }

  if (playBtn) {
    playBtn.addEventListener('click', () => {
      playTransport();
    });
  }
  if (pauseBtn) {
    pauseBtn.addEventListener('click', () => {
      pauseTransport();
    });
  }
  if (stopBtn) {
    stopBtn.addEventListener('click', () => {
      stopTransport();
    });
  }
  if (zoomRange) {
    zoomRange.addEventListener('input', () => {
      const val = parseInt(zoomRange.value || '0', 10);
      const next = Number.isNaN(val) ? 0 : val;
      pendingZoom = next;
      if (zoomRaf !== null) return;
      zoomRaf = requestAnimationFrame(() => {
        zoomRaf = null;
        if (pendingZoom === null) return;
        setZoomLevel(pendingZoom);
        pendingZoom = null;
      });
    });
  }

  window.addEventListener('resize', () => {
    if (zoomRaf !== null) return;
    zoomRaf = requestAnimationFrame(() => {
      zoomRaf = null;
      updateFitBaseline();
      if (viewMode === 'spectrogram') updateSpectrogramZoom();
      updateMiniSpectrogram();
      updateOverviewWindow();
    });
  });

  if (toggleSourceBtn) {
    toggleSourceBtn.addEventListener('click', () => {
      setTrackMode('source');
    });
  }
  if (toggleProcessedBtn) {
    toggleProcessedBtn.addEventListener('click', () => {
      setTrackMode('processed');
    });
  }
  if (toggleBothBtn) {
    toggleBothBtn.addEventListener('click', () => {
      setTrackMode('both');
    });
  }
  if (toggleFlipBtn) {
    toggleFlipBtn.addEventListener('click', () => {
      flipAudition();
    });
  }
  window.addEventListener('keydown', (evt) => {
    if (ignoreShortcut(evt)) return;
    if (evt.key && evt.key.toLowerCase() === 'a') {
      evt.preventDefault();
      flipAudition();
    }
  });

  if (soloSourceBtn) {
    soloSourceBtn.addEventListener('click', () => {
      setSolo('source');
    });
  }

  if (soloProcessedBtn) {
    soloProcessedBtn.addEventListener('click', () => {
      setSolo('processed');
    });
  }

  [togglePeakRisk, toggleHeatmap, toggleDelta].forEach((el) => {
    if (!el) return;
    el.addEventListener('change', () => {
      syncToggleStyles();
      drawOverlays();
    });
  });
  if (toggleMatchLoudness) {
    toggleMatchLoudness.addEventListener('change', () => {
      syncToggleStyles();
      applyMatchLoudness();
      resumeAudioContext();
    });
  }
  if (toggleViewWaveform) {
    toggleViewWaveform.addEventListener('click', () => {
      setViewMode('waveform');
    });
  }
  if (toggleViewSpectrogram) {
    toggleViewSpectrogram.addEventListener('click', () => {
      setViewMode('spectrogram');
    });
  }
  syncToggleStyles();
  updateFitBaseline();
  updateTrackToggleUI();
  bindSpectrogramInteractions();
  disableImageDrag(spectroSourceImg);
  disableImageDrag(spectroProcessedImg);
  disableImageDrag(compareMiniSpectroSourceImg);
  disableImageDrag(compareMiniSpectroProcessedImg);
  setupOverviewScrub();
  bindAudioEvents(compareAudioSource);
  bindAudioEvents(compareAudioProcessed);

  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  const out = params.get('out');
  const solo = params.get('solo');
  let src = params.get('src');
  const proc = params.get('proc');
  const imp = params.get('imp');
  if (song) {
    selectedItem = out
      ? { kind: 'mastering_output', id: `${song}::${out}`, song, out, solo: solo === '1' || solo === 'true' }
      : { kind: 'mastering_run', id: song, song };
    selectAndLoad(selectedItem, null, false);
  } else if (src && proc) {
    addStatusLine('Loading selection...');
    resolvePair(src, proc).then((data) => {
      applyData(data);
      addStatusLine('Compare ready');
    }).catch(() => {
      addStatusLine('Compare failed');
      if (typeof showToast === 'function') showToast('Compare data unavailable');
    });
  } else if (src) {
    const parsed = normalizeLibraryRel(src);
    if (parsed?.kind === 'source' || parsed?.kind === 'import') {
      src = parsed.rel;
    }
    selectedItem = { kind: 'source', rel: src };
    selectAndLoad(selectedItem, null, false);
  } else if (imp) {
    selectedItem = { kind: 'import', rel: imp };
    selectAndLoad(selectedItem, null, false);
  }

  if (analyzeBrowser && window.LibraryBrowser) {
    const browser = window.LibraryBrowser.init(analyzeBrowser, { module: 'compare' });
    libraryBrowser = browser;
    analyzeBrowser.addEventListener('library:select', async (evt) => {
      const { song, track } = evt.detail || {};
      try {
        await loadLibrarySelection(song, track, true);
      } catch (_err) {
        addStatusLine('Compare failed');
        if (typeof showToast === 'function') showToast('Compare data unavailable');
      }
    });
    analyzeBrowser.addEventListener('library:action', async (evt) => {
      const { action, song, version, item } = evt.detail || {};
      if (action === 'set-processed' && song?.source?.rel) {
        const rel = primaryRendition(version?.renditions)?.rel || version?.rel;
        if (!rel) return;
        try {
          await loadLibrarySelection(song, { kind: 'version', rel }, true);
        } catch (_err) {
          addStatusLine('Compare failed');
        }
        return;
      }
      if (action === 'open-compare') {
        const rel = primaryRendition(version?.renditions)?.rel || version?.rel;
        if (!rel) return;
        const url = new URL('/compare', window.location.origin);
        if (song?.source?.rel) url.searchParams.set('src', song.source.rel);
        url.searchParams.set('proc', rel);
        window.location.assign(`${url.pathname}${url.search}`);
        return;
      }
      if (action === 'delete-version' && song?.song_id && version?.version_id) {
        await fetch('/api/library/delete_version', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ song_id: song.song_id, version_id: version.version_id }),
        });
        browser.reload();
        return;
      }
      if (action === 'rename-song' && song?.song_id) {
        const next = prompt('Rename song', song.title || '');
        if (!next) return;
        await fetch('/api/library/rename_song', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ song_id: song.song_id, title: next }),
        });
        browser.reload();
        return;
      }
      if (action === 'import-file' && uploadInput) {
        uploadInput.click();
        return;
      }
      if (action === 'add-unsorted' && item?.rel) {
        const res = await fetch('/api/library', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        const songs = Array.isArray(data.songs) ? data.songs : [];
        const list = songs.map((song, idx) => `${idx + 1}) ${song.title || 'Untitled'}`).join('\n');
        const choice = prompt(`Add output to which song?\n${list}\n\nEnter number or type a new title.`, '');
        if (!choice) return;
        const idx = parseInt(choice, 10);
        if (!Number.isNaN(idx) && songs[idx - 1]) {
          const song = songs[idx - 1];
          await fetch('/api/library/add_version', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              song_id: song.song_id,
              kind: 'manual',
              label: item.name || 'Output',
              rel: item.rel,
              summary: {},
              tags: [],
            }),
          });
        } else {
          const title = choice.trim() || item.name || item.rel;
          await fetch('/api/library/import_source', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: item.rel, title }),
          });
        }
        browser.reload();
        return;
      }
      if (action === 'import-file' && uploadInput) {
        uploadInput.click();
      }
    });
  }
})();
</script>
{% endblock %}
