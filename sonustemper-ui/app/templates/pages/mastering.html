{% extends "base.html" %}
{% block page_title %}Mastering | SonusTemper{% endblock %}
{% block title %}Mastering{% endblock %}
{% block subtitle %}Run batch mastering with voicing, loudness profile, tone & space, and output formats.{% endblock %}
{% block sidebar %}
    <div class="card">
      <div class="card-head">
        <div>
          <div class="card-title">Processing Status</div>
          <div class="muted">Live status via event stream.</div>
        </div>
      </div>
      <div class="status-list" id="statusList">(waiting)</div>
      <div class="status-progress" id="statusProgress">
        <div class="status-progress-bar" id="statusProgressBar"></div>
      </div>
    </div>
  <div class="card browse-card">
    <div class="card-head">
      <div>
        <div class="card-title">Browse</div>
        <div class="muted">Mastering runs (song-level).</div>
      </div>
    </div>
    {% set browser_id = "masteringBrowser" %}
    {% set sections = [
      {"key": "mastering_runs", "title": "Mastering Runs", "endpoint": "/partials/library_list?view=mastering_runs", "autoselect": "first"}
    ] %}
    {% include "partials/file_browser.html" %}
  </div>
{% endblock %}

{% block content %}
  <div class="master-grid">
    <div class="card job-card full-width">
      <div class="card-head">
        <div>
          <div class="card-title">Master</div>
          <div class="muted">Pick sources, choose voicing and delivery profile, tune width, and outputs.</div>
        </div>
        <div class="muted hx-indicator" id="jobIndicator">Working…</div>
      </div>
      <form id="masterForm">
        <div class="master-layout">
          <div class="master-left">
            <div class="stage-card input-stage">
              <div class="stage-head">
                <div>
                  <div class="stage-title" id="inputTitle">Input</div>
                </div>
                <div class="stage-search">
                  <input type="search" id="inputSearch" placeholder="Search files" aria-label="Search files">
                </div>
                <div class="stage-actions">
                  <input type="file" id="inputUpload" accept=".wav,.mp3,.flac,.aiff,.aif,.m4a,.ogg,.aac" multiple hidden>
                  <button type="button" class="btn ghost small" id="uploadBtn">Upload</button>
                  <button type="button" class="btn ghost small" id="selectAllBtn">Select All</button>
                  <button type="button" class="btn ghost small" id="clearBtn">Clear</button>
                </div>
              </div>
              <div class="input-list" id="inputList">
                <div class="input-empty muted">Loading…</div>
              </div>
              <div class="input-footer" id="inputFooter">Selected: 0 files, Total duration: —</div>
            </div>

            <div class="stage-card output-stage">
              <div class="stage-title">Output Formats</div>
              <div class="format-box">
                <div class="format-row" data-format="wav">
                  <label class="format-label"><input type="checkbox" id="out_wav" checked> WAV</label>
                  <div class="format-options">
                    <select id="wav_bit_depth">
                      <option value="24">24-bit</option>
                      <option value="16">16-bit</option>
                    </select>
                    <select id="wav_sample_rate">
                      <option value="48000">48 kHz</option>
                      <option value="44100">44.1 kHz</option>
                    </select>
                  </div>
                </div>
                <div class="format-row" data-format="mp3">
                  <label class="format-label"><input type="checkbox" id="out_mp3" checked> MP3</label>
                  <div class="format-options">
                    <select id="mp3_bitrate">
                      <option value="320">320 kbps</option>
                      <option value="256">256 kbps</option>
                      <option value="192">192 kbps</option>
                      <option value="128">128 kbps</option>
                    </select>
                    <select id="mp3_vbr">
                      <option value="none">None (CBR)</option>
                      <option value="V0">V0</option>
                      <option value="V2">V2</option>
                    </select>
                  </div>
                </div>
                <div class="format-row" data-format="aac">
                  <label class="format-label"><input type="checkbox" id="out_aac"> AAC/M4A</label>
                  <div class="format-options">
                    <select id="aac_codec">
                      <option value="aac">AAC (native)</option>
                      <option value="aac">AAC (faac)</option>
                    </select>
                    <select id="aac_container">
                      <option value="m4a">M4A</option>
                      <option value="aac">AAC</option>
                    </select>
                    <select id="aac_bitrate">
                      <option value="256">256 kbps</option>
                      <option value="192">192 kbps</option>
                      <option value="128">128 kbps</option>
                    </select>
                  </div>
                </div>
                <div class="format-row" data-format="ogg">
                  <label class="format-label"><input type="checkbox" id="out_ogg"> OGG</label>
                  <div class="format-options">
                    <select id="ogg_quality">
                      <option value="5">Q5 (~160 kbps)</option>
                      <option value="4">Q4</option>
                      <option value="6">Q6</option>
                    </select>
                  </div>
                </div>
                <div class="format-row" data-format="flac">
                  <label class="format-label"><input type="checkbox" id="out_flac"> FLAC</label>
                  <div class="format-options">
                    <select id="flac_level">
                      <option value="5">Level 5</option>
                      <option value="8">Level 8</option>
                      <option value="1">Level 1</option>
                    </select>
                    <select id="flac_bit_depth">
                      <option value="">Auto bit</option>
                      <option value="24">24-bit</option>
                      <option value="16">16-bit</option>
                    </select>
                    <select id="flac_sample_rate">
                      <option value="">Auto sr</option>
                      <option value="48000">48 kHz</option>
                      <option value="44100">44.1 kHz</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="master-right">
            <div class="stage-card" id="voicingStage">
              <div class="stage-head">
                <div class="stage-title">Voicing</div>
                <div class="stage-actions stage-search">
                  <input type="search" id="voicingFilter" placeholder="Search" aria-label="Search voicings" autocomplete="off">
                </div>
              </div>
              <div class="control-row">
                <select id="voicingSelect" class="full-width-select">
                  <option value="" disabled selected>Loading voicings...</option>
                </select>
              </div>
              <div class="control-row voicing-tags-row" id="voicingTagsWrap" hidden>
                <div class="muted voicing-desc" id="voicingDesc"></div>
                <div class="badge-row compact voicing-tags" id="voicingTags" data-max-rows="2"></div>
              </div>
              <div class="control-row eq-preview-row">
                <div class="eq-preview">
                  <svg id="voicingEqPreview" width="100%" height="64" viewBox="0 0 240 64" role="img" aria-label="EQ Preview"></svg>
                  <div class="muted eq-preview-label" id="voicingEqLabel"></div>
                </div>
              </div>
              <div class="control-row compact-row">
                <div class="control-label">Strength</div>
                <input type="range" id="strength" min="0" max="100" value="80">
                <div class="value-pill" id="strengthVal">80</div>
              </div>
              <div class="control-row preview-row">
                <div class="control-label small-label">Preview</div>
                <audio id="voicingPreviewAudio" class="preview-audio" controls preload="none"></audio>
                <span class="muted" id="previewStatus" aria-live="polite" style="display:none;">Select a source file to preview</span>
              </div>
            </div>

            <div class="stage-card" id="loudnessStage">
              <div class="stage-title">Loudness &amp; Delivery</div>
              <div class="control-row">
                <select id="loudnessMode" class="full-width-select">
                  <option value="manual">Manual</option>
                </select>
              </div>
              <div class="control-subtitle">Overrides (select Manual profile)</div>
              <div class="override-row">
                <label class="control-label inline"><input type="checkbox" id="ov_target_I" checked> Loudness (LUFS)</label>
                <input type="range" id="target_I_range" min="-30" max="-5" step="0.1" value="-16.0">
                <input type="number" step="0.1" id="target_I" value="-16.0">
              </div>
              <div class="override-row">
                <label class="control-label inline"><input type="checkbox" id="ov_target_TP" checked> True Peak (dBTP)</label>
                <input type="range" id="target_TP_range" min="-3.0" max="0.0" step="0.1" value="-1.0">
                <input type="number" step="0.1" id="target_TP" value="-1.0">
              </div>
            </div>

            <div class="stage-card" id="stereoStage">
              <div class="stage-title">Stereo Width</div>
              <div class="control-row compact-row">
                <div class="control-label">Width Override</div>
                <input type="range" id="width" min="0.5" max="1.5" step="0.01" value="1.0">
                <div class="value-pill" id="widthVal">1.00</div>
              </div>
              <div class="control-row guardrails-row">
                <label class="control-label inline"><input type="checkbox" id="guardrails" checked> Guardrails (prevent clipping / over-compression)</label>
              </div>
            </div>

            <div class="stage-card" id="convertOnlyStage">
              <div class="stage-title">Convert Only</div>
              <div class="control-row">
                <label class="control-label inline small-label"><input type="checkbox" id="convertOnly"> Perform only media conversion</label>
              </div>
            </div>
          </div>
        </div>

        <div class="run-summary">
          <div class="run-summary-text" id="runSummaryText">0 files • Voicing: Universal (Strength 80) • Profile: Apple Music • Width: 1.00 • Outputs: WAV, MP3</div>
          <button type="submit" class="btn btn-primary" id="runBtn" disabled>Run Job</button>
        </div>
      </form>
    </div>

    <div class="card full-width" id="outputPaneWrap">
      <div class="card" id="outputPane" style="background:transparent;border:none;padding:0;">
        <div class="card-head">
          <div>
            <div class="card-title">Job Output</div>
            <div class="muted">Select a run to view outputs.</div>
          </div>
        </div>
        <div class="muted">Output list placeholder.</div>
      </div>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  const indicator = document.getElementById('jobIndicator');
  const statusList = document.getElementById('statusList');
  const statusProgressBar = document.getElementById('statusProgressBar');
  const outputPaneWrap = document.getElementById('outputPaneWrap');

  let currentRun = null;
  let statusSource = null;
  let statusLines = [];
  let statusRenderPending = false;
  let statusStages = new Set();
  const state = {
    selectedFiles: [],
    voicing: 'universal',
    strength: 80,
    profile: 'apple_music',
    lufsOverrideEnabled: true,
    lufsValue: -16.0,
    tpOverrideEnabled: true,
    tpValue: -1.0,
    widthValue: 1.0,
    guardrails: true,
    outputs: {
      wav: { enabled: true, bitDepth: '24', sampleRate: '48000' },
      mp3: { enabled: true, bitrate: '320', vbr: 'none' },
      aac: { enabled: false, codec: 'aac', container: 'm4a', bitrate: '256' },
      ogg: { enabled: false, quality: '5' },
      flac: { enabled: false, level: '5', bitDepth: '', sampleRate: '' },
    },
  };
  const outputLabels = {
    wav: 'WAV',
    mp3: 'MP3',
    aac: 'AAC/M4A',
    ogg: 'OGG',
    flac: 'FLAC',
  };
  let loudProfiles = {};
  const voicingSeed = {{ voicing_seed|tojson }};
  let voicingCatalog = [];
  let voicingIndex = {};

  function setBusy(on){
    if(!indicator) return;
    indicator.style.display = on ? 'inline-block' : 'none';
  }
  setBusy(false);

  function scheduleStatusRender(){
    if(statusRenderPending) return;
    statusRenderPending = true;
    requestAnimationFrame(()=>{
      statusRenderPending = false;
      if(!statusList) return;
      statusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
      statusList.scrollTop = statusList.scrollHeight;
    });
  }

  function addStatusLine(message){
    if(!message) return;
    const ts = new Date().toLocaleTimeString();
    statusLines.push(`${ts} ${message}`);
    scheduleStatusRender();
  }

  function setProgress(fraction){
    if (!statusProgressBar) return;
    if (fraction === null || fraction === undefined || Number.isNaN(fraction)) {
      statusProgressBar.style.width = '0%';
      statusProgressBar.classList.remove('active');
      return;
    }
    const pct = Math.max(0, Math.min(1, fraction)) * 100;
    statusProgressBar.style.width = `${pct}%`;
    if (pct > 0 && pct < 100) {
      statusProgressBar.classList.add('active');
    } else {
      statusProgressBar.classList.remove('active');
    }
  }

  function updateProgressFromStages(){
    if (!currentRun || !statusStages.size) {
      setProgress(currentRun ? 0.05 : null);
      return;
    }
    if (statusStages.has('complete') || statusStages.has('error')) {
      setProgress(1);
      return;
    }
    const ordered = [
      'start',
      'metrics_source_start',
      'metrics_source_done',
      'preset_start',
      'preset_done',
      'metrics_start',
      'metrics_done',
      'mp3_done',
      'aac_done',
      'ogg_done',
      'flac_done',
      'playlist',
    ];
    const total = ordered.length;
    let done = 0;
    ordered.forEach(stage => {
      if (statusStages.has(stage)) done += 1;
    });
    const fraction = total ? done / total : 0;
    setProgress(fraction);
  }

  function setCurrentRun(song){
    const next = song || null;
    // Avoid restarting the stream (and clearing the log) if the same run is selected again.
    if(next === currentRun && statusSource){
      return;
    }
    currentRun = next;
    startStatusStream();
  }

  function closeStatusStream(){
    if(statusSource){
      statusSource.close();
      statusSource = null;
    }
    if (!currentRun) {
      setProgress(null);
    }
  }

  function startStatusStream(){
    closeStatusStream();
    statusLines = [];
    statusStages = new Set();
    scheduleStatusRender();
    updateProgressFromStages();
    if(!currentRun){
      return;
    }
    const url = `/api/status-stream?song=${encodeURIComponent(currentRun)}`;
    let es;
    try{
      es = new EventSource(url);
      statusSource = es;
      statusLines.push('(connecting…)');
      scheduleStatusRender();
    }catch(err){
      statusLines.push('Event stream unavailable');
      scheduleStatusRender();
      return;
    }
    es.onmessage = (ev)=>{
      let data;
      try{ data = JSON.parse(ev.data); }catch(_){ data = { detail: ev.data }; }
      const ts = data.ts ? new Date(data.ts*1000).toLocaleTimeString() : '';
      const stage = data.stage || '';
      const detail = data.detail || data.message || '';
      const line = [ts, stage, detail].filter(Boolean).join(' ');
      if(line) statusLines.push(line);
      if (stage) {
        statusStages.add(stage);
        updateProgressFromStages();
      }
      scheduleStatusRender();
      if(data.stage === 'complete' || data.stage === 'error'){
        closeStatusStream();
        // Refresh browser list ONLY (do not auto-click a run, or you'll restart SSE forever)
        refreshMasteringRuns();
        if (currentRun) {
          loadOutput(currentRun);
        }
      }
    };
    es.onerror = ()=>{
      closeStatusStream();
      statusLines.push('(status unavailable)');
      scheduleStatusRender();
    };
  }

  async function loadFiles(){
    try{
      const res = await fetch('/api/files',{cache:'no-store'});
      const data = await res.json();
      const list = document.getElementById('inputList');
      const prevSelected = new Set(state.selectedFiles);
      if (list) {
        list.innerHTML = '';
        const files = data.files || [];
        if (!files.length) {
          const empty = document.createElement('div');
          empty.className = 'input-empty muted';
          empty.textContent = 'No source files found';
          list.appendChild(empty);
        } else {
          files.forEach((f, idx) => {
            const item = document.createElement('label');
            item.className = 'input-item';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.name = 'infiles';
            cb.value = f;
            cb.checked = prevSelected.has(f) || (!prevSelected.size && idx === 0);
            const text = document.createElement('span');
            text.className = 'input-name';
            text.textContent = f;
            const duration = document.createElement('span');
            duration.className = 'input-duration';
            duration.textContent = '—';
            item.appendChild(cb);
            item.appendChild(text);
            item.appendChild(duration);
            list.appendChild(item);
          });
        }
      }
      updateSelectionState();
      applyInputFilter();
    }catch(e){
      showToast('Failed to load files');
    }
  }

  const uploadBtn = document.getElementById('uploadBtn');
  const uploadInput = document.getElementById('inputUpload');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const clearBtn = document.getElementById('clearBtn');
  const inputList = document.getElementById('inputList');
  const inputTitle = document.getElementById('inputTitle');
  const inputFooter = document.getElementById('inputFooter');
  const inputSearch = document.getElementById('inputSearch');
  const runSummaryText = document.getElementById('runSummaryText');
  const voicingStage = document.getElementById('voicingStage');
  const loudnessStage = document.getElementById('loudnessStage');
  const stereoStage = document.getElementById('stereoStage');
  const convertOnly = document.getElementById('convertOnly');

  function triggerUpload(){
    if (uploadInput) uploadInput.click();
  }

  async function uploadFilesSequential(files){
    addStatusLine('Uploading files...');
    for (let i = 0; i < files.length; i++){
      const f = files[i];
      const fd = new FormData();
      fd.append('files', f, f.name);
      const res = await fetch('/api/upload', { method: 'POST', body: fd });
      if (!res.ok){
        const msg = await res.text();
        throw new Error(msg || `Upload failed: ${f.name}`);
      }
      addStatusLine(`${f.name} uploaded...`);
    }
    addStatusLine('Upload complete');
  }

  if (uploadBtn && uploadInput){
    uploadBtn.addEventListener('click', triggerUpload);
    uploadBtn.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        triggerUpload();
      }
    });
  }

  if (uploadInput){
    uploadInput.addEventListener('change', async ()=>{
      const files = [...(uploadInput.files || [])];
      if (!files.length) return;
      try{
        showToast('Uploading…');
        await uploadFilesSequential(files);
        await loadFiles();
        showToast('Upload complete');
      }catch(err){
        showToast('Upload failed');
      }finally{
        uploadInput.value = '';
      }
    });
  }

  function formatDuration(totalSeconds){
    if (!totalSeconds || totalSeconds <= 0) return '—';
    const hrs = Math.floor(totalSeconds / 3600);
    const mins = Math.floor((totalSeconds % 3600) / 60);
    const mm = String(mins).padStart(2, '0');
    return hrs > 0 ? `${hrs}:${mm}` : `0:${mm}`;
  }

  function updateSelectionState(){
    state.selectedFiles = [...document.querySelectorAll('#inputList input[name="infiles"]:checked')].map(cb => cb.value);
    const count = state.selectedFiles.length;
    const label = count === 1 ? 'file' : 'files';
    if (inputTitle) {
      inputTitle.textContent = 'Input';
    }
    const totalDuration = (() => {
      let total = 0;
      let has = false;
      document.querySelectorAll('#inputList input[name="infiles"]:checked').forEach(cb => {
        const d = parseFloat(cb.dataset.duration || '');
        if (!Number.isNaN(d)) {
          total += d;
          has = true;
        }
      });
      return has ? total : null;
    })();
    if (inputFooter) {
      inputFooter.textContent = `Selected: ${count} ${label}, Total duration: ${formatDuration(totalDuration)}`;
    }
    const first = state.selectedFiles[0] || null;
    if (first !== previewSong) {
      previewSong = first;
      resetPreview();
      if (first) {
        schedulePreview();
      }
    }
    updateSummary();
    updateRunButton();
    updatePreviewAvailability();
  }

  function applyInputFilter(){
    if (!inputList || !inputSearch) return;
    const term = inputSearch.value.trim().toLowerCase();
    let visibleCount = 0;
    inputList.querySelectorAll('.input-item').forEach(item => {
      const name = item.querySelector('.input-name')?.textContent?.toLowerCase() || '';
      const match = !term || name.includes(term);
      item.style.display = match ? '' : 'none';
      if (match) visibleCount += 1;
    });
    let empty = inputList.querySelector('.input-empty.filter-empty');
    if (visibleCount === 0 && inputList.querySelectorAll('.input-item').length) {
      if (!empty) {
        empty = document.createElement('div');
        empty.className = 'input-empty filter-empty muted';
        empty.textContent = 'No matches';
        inputList.appendChild(empty);
      }
    } else if (empty) {
      empty.remove();
    }
  }

  if (inputList) {
    inputList.addEventListener('change', updateSelectionState);
  }
  if (selectAllBtn) {
    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('#inputList input[name="infiles"]').forEach(cb => { cb.checked = true; });
      updateSelectionState();
    });
  }
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      document.querySelectorAll('#inputList input[name="infiles"]').forEach(cb => { cb.checked = false; });
      updateSelectionState();
    });
  }
  if (inputSearch) {
    inputSearch.addEventListener('input', applyInputFilter);
  }

  async function loadOutput(song){
    if(!song || !outputPaneWrap) return;
    try{
      const res = await fetch(`/partials/master_output?song=${encodeURIComponent(song)}`, {cache:'no-store'});
      if(!res.ok){
        outputPaneWrap.innerHTML = `
          <div class="card" id="outputPane" style="background:transparent;border:none;padding:0;">
            <div class="card-head">
              <div>
                <div class="card-title">Job Output</div>
                <div class="muted">No output found for <strong>${song}</strong>.</div>
              </div>
            </div>
          </div>`;
        return;
      }
      outputPaneWrap.innerHTML = await res.text();
    }catch(err){
      showToast('Failed to load output');
    }
  }

  function refreshMasteringRuns(){
    const list = document.getElementById('masteringBrowser-list-mastering_runs');
    if (!list) return;
    const endpoint = list.dataset.endpoint;
    if (endpoint && window.htmx) {
      window.htmx.ajax('GET', endpoint, { target: list, swap: 'innerHTML' });
    }
  }

  const form = document.getElementById('masterForm');
  const runBtn = document.getElementById('runBtn');
  const strength = document.getElementById('strength');
  const strengthVal = document.getElementById('strengthVal');
  const voicingSelect = document.getElementById('voicingSelect');
  const voicingFilter = document.getElementById('voicingFilter');
  const loudnessMode = document.getElementById('loudnessMode');
  const ovTargetI = document.getElementById('ov_target_I');
  const ovTargetTp = document.getElementById('ov_target_TP');
  const targetI = document.getElementById('target_I');
  const targetIRange = document.getElementById('target_I_range');
  const targetTp = document.getElementById('target_TP');
  const targetTpRange = document.getElementById('target_TP_range');
  const width = document.getElementById('width');
  const widthVal = document.getElementById('widthVal');
  const guardrails = document.getElementById('guardrails');
  const previewStatus = document.getElementById('previewStatus');
  const previewAudio = document.getElementById('voicingPreviewAudio');
  const eqPreview = document.getElementById('voicingEqPreview');
  const eqPreviewLabel = document.getElementById('voicingEqLabel');
  const voicingTagsWrap = document.getElementById('voicingTagsWrap');
  const voicingDesc = document.getElementById('voicingDesc');
  const voicingTags = document.getElementById('voicingTags');
  let previewTimer = null;
  let previewEventSource = null;
  let previewCurrentId = null;
  let previewRequestId = 0;
  let previewReadyUrl = null;
  let previewSong = null;
  let previewIsBuilding = false;
  let previewLastStatus = null;
  let previewAutoPlay = false;

  function setPreviewStatus(text){
    const msg = text || '';
    if (previewStatus) previewStatus.textContent = msg;
    if (msg && msg !== previewLastStatus) {
      addStatusLine(`Preview: ${msg}`);
      previewLastStatus = msg;
    }
  }

  function setPreviewPlayable(enabled){
    if (!previewAudio) return;
    previewAudio.classList.toggle('is-disabled', !enabled);
    previewAudio.setAttribute('aria-disabled', enabled ? 'false' : 'true');
  }


  function closePreviewStream(){
    if (previewEventSource) {
      previewEventSource.close();
      previewEventSource = null;
    }
  }

  function stopPreview(){
    if (!previewAudio) return;
    previewAudio.pause();
    previewAudio.currentTime = 0;
  }

  function resetPreview(){
    previewIsBuilding = false;
    previewCurrentId = null;
    previewReadyUrl = null;
    closePreviewStream();
    stopPreview();
    setPreviewPlayable(false);
    if (previewAudio) {
      previewAudio.removeAttribute('src');
      previewAudio.load();
    }
  }

  function updatePreviewAvailability(){
    const song = state.selectedFiles[0] || null;
    if (convertOnly?.checked) {
      setPreviewStatus('Preview disabled in Convert Only');
      resetPreview();
      return;
    }
    if (!song) {
      setPreviewStatus('Select a source file to preview');
      resetPreview();
      return;
    }
    if (previewIsBuilding) {
      setPreviewStatus('Generating...');
      setPreviewPlayable(false);
      return;
    }
    if (previewReadyUrl) {
      setPreviewStatus('Ready');
      setPreviewPlayable(true);
    } else {
      setPreviewStatus('Preview idle');
      setPreviewPlayable(false);
    }
  }

  function schedulePreview(){
    if (previewTimer) clearTimeout(previewTimer);
    previewTimer = setTimeout(startPreview, 400);
  }

  function startPreview(){
    const song = state.selectedFiles[0] || null;
    if (convertOnly?.checked) {
      updatePreviewAvailability();
      return;
    }
    if (!song) {
      updatePreviewAvailability();
      return;
    }
    const requestId = ++previewRequestId;
    const voicing = voicingSelect?.value || 'universal';
    const strengthVal = parseInt(strength?.value || '0', 10);
    const widthVal = width?.value ? parseFloat(width.value) : null;
    const activeProfile = loudProfiles[loudnessMode?.value || 'manual'];
    const useProfileTargets = activeProfile && !activeProfile.manual;
    const lufsVal = targetI?.value ? parseFloat(targetI.value) : NaN;
    const tpVal = targetTp?.value ? parseFloat(targetTp.value) : NaN;
    resetPreview();
    previewIsBuilding = true;
    setPreviewStatus('Generating...');
    const payload = { song, voicing, strength: strengthVal };
    if (!Number.isNaN(widthVal) && widthVal !== null) payload.width = widthVal;
    payload.guardrails = Boolean(guardrails?.checked);
    if (useProfileTargets || ovTargetI?.checked) {
      if (!Number.isNaN(lufsVal)) payload.lufs = lufsVal;
    }
    if (useProfileTargets || ovTargetTp?.checked) {
      if (!Number.isNaN(tpVal)) payload.tp = tpVal;
    }
    fetch('/api/preview/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
      .then(async (res) => {
        if (!res.ok) {
          const err = await res.json().catch(()=>({detail:'error'}));
          throw new Error(err.detail || 'preview_failed');
        }
        return res.json();
      })
      .then((data) => {
        if (requestId !== previewRequestId) return;
        const id = data.preview_id;
        previewCurrentId = id;
        previewSong = song;
        const es = new EventSource(`/api/preview/stream?preview_id=${encodeURIComponent(id)}`);
        previewEventSource = es;
        es.onmessage = (ev) => {
          if (requestId !== previewRequestId) return;
          let msg = {};
          try{ msg = JSON.parse(ev.data || '{}'); }catch(_){ msg = {}; }
          if (msg.status === 'ready' && msg.url) {
            previewReadyUrl = `${msg.url}&cb=${Date.now()}`;
            if (previewAudio) previewAudio.src = previewReadyUrl;
            previewIsBuilding = false;
            setPreviewStatus('Ready');
            setPreviewPlayable(true);
            if (previewAutoPlay && previewAudio) {
              previewAudio.play().catch(() => {});
            }
            closePreviewStream();
          } else if (msg.status === 'error') {
            previewIsBuilding = false;
            setPreviewStatus(`Preview failed: ${msg.message || 'error'}`);
            setPreviewPlayable(false);
            closePreviewStream();
          }
        };
        es.onerror = () => {
          if (requestId !== previewRequestId) return;
          previewIsBuilding = false;
          setPreviewStatus('Preview unavailable');
          setPreviewPlayable(false);
          closePreviewStream();
        };
      })
      .catch((err) => {
        if (requestId !== previewRequestId) return;
        previewIsBuilding = false;
        const message = err && err.message ? err.message : 'Preview failed';
        setPreviewStatus(message);
        setPreviewPlayable(false);
      });
  }
  function setStageEnabled(stageEl, enabled){
    if (!stageEl) return;
    stageEl.classList.toggle('disabled', !enabled);
    stageEl.querySelectorAll('input, select, textarea, button').forEach(el => {
      if (el === convertOnly) return;
      el.disabled = !enabled;
    });
  }

  function applyConvertOnly(){
    const enabled = !(convertOnly?.checked);
    setStageEnabled(voicingStage, enabled);
    setStageEnabled(loudnessStage, enabled);
    setStageEnabled(stereoStage, enabled);
    if (!enabled) {
      stopPreview();
      resetPreview();
    }
    updatePreviewAvailability();
  }

  function normalizeText(value){
    return String(value || '').toLowerCase().trim();
  }

  function seedVoicings(){
    if (!Array.isArray(voicingSeed) || !voicingSeed.length) return;
    voicingCatalog = [];
    voicingIndex = {};
    voicingSeed.forEach(entry => {
      if (!entry || !entry.id) return;
      const rawTags = Array.isArray(entry.tags) ? entry.tags : [];
      const tags = rawTags
        .map(tag => String(tag || '').trim())
        .filter(tag => tag.length);
      const parsedWidth = entry.width !== undefined && entry.width !== null ? parseFloat(entry.width) : null;
      const eq = Array.isArray(entry.eq) ? entry.eq : [];
      const item = {
        id: entry.id,
        title: entry.title || entry.id,
        tags,
        origin: entry.origin || 'builtin',
        width: Number.isFinite(parsedWidth) ? parsedWidth : null,
        eq,
      };
      item.searchText = normalizeText([item.title, item.id, tags.join(' ')].join(' '));
      voicingCatalog.push(item);
      voicingIndex[item.id] = item;
    });
    if (voicingCatalog.length) {
      renderVoicingOptions(voicingFilter?.value || '', state.voicing);
    }
    renderEqPreview();
  }

  function updateVoicingTooltip(){
    if (!voicingSelect) return;
    const entry = voicingIndex[voicingSelect.value];
    if (entry && entry.tags && entry.tags.length) {
      voicingSelect.title = `Tags: ${entry.tags.join(', ')}`;
    } else {
      voicingSelect.title = '';
    }
  }

  function updateVoicingTags(){
    if (!voicingTagsWrap || !voicingDesc || !voicingTags) return;
    const entry = voicingIndex[voicingSelect?.value || ''];
    const tags = entry && Array.isArray(entry.tags) ? entry.tags : [];
    const desc = tags.length ? tags[0] : '';
    const pills = tags.length > 1 ? tags.slice(1) : [];
    voicingDesc.textContent = desc || '';
    voicingTags.innerHTML = '';
    pills.forEach(tag => {
      const text = String(tag || '').trim();
      if (!text) return;
      const span = document.createElement('span');
      span.className = 'badge badge-tag';
      span.textContent = text;
      voicingTags.appendChild(span);
    });
    voicingTagsWrap.hidden = !(desc || pills.length);
  }

  function renderEqPreview(){
    if (!eqPreview) return;
    const entry = voicingIndex[voicingSelect?.value || ''];
    const eqBands = entry && Array.isArray(entry.eq) ? entry.eq : [];
    const title = entry ? (entry.title || entry.id) : 'EQ';
    const strengthVal = parseInt(strength?.value || '0', 10);
    const strengthNorm = Math.max(0, Math.min(1, strengthVal / 100));
    const displayBoost = 1 + strengthNorm * 1.2;
    const maxAbs = eqBands.reduce((acc, band) => {
      const gain = parseFloat(band?.gain_db ?? 0);
      return Math.max(acc, Math.abs(Number.isFinite(gain) ? gain : 0));
    }, 0);
    const range = maxAbs > 2.0 ? 8 : 6;
    const w = eqPreview.viewBox?.baseVal?.width || eqPreview.clientWidth || 240;
    const h = eqPreview.viewBox?.baseVal?.height || eqPreview.clientHeight || 64;
    const padding = 8;
    const plotW = w - padding * 2;
    const plotH = h - padding * 2;
    const mid = h / 2;
    const samples = 96;
    const minF = 20;
    const maxF = 20000;
    const logStep = Math.log(maxF / minF);
    const values = [];
    for (let i = 0; i < samples; i += 1) {
      const t = i / (samples - 1);
      const f = minF * Math.exp(logStep * t);
      let y = 0;
      eqBands.forEach(band => {
        if (!band) return;
        const f0 = parseFloat(band.freq_hz);
        if (!Number.isFinite(f0) || f0 <= 0) return;
        const gain = parseFloat(band.gain_db ?? 0);
        if (!Number.isFinite(gain) || gain === 0) return;
        const q = parseFloat(band.q ?? 1.0);
        const qSafe = Math.max(q, 0.2);
        const x = Math.log2(f / f0);
        const type = String(band.type || '').toLowerCase();
        if (type === 'peaking' || type === 'peak' || type === 'bell') {
          const sigma = 0.55 / qSafe;
          const g = gain * Math.exp(-(x * x) / (2 * sigma * sigma));
          y += g;
        } else if (type === 'highshelf') {
          const k = 6 * qSafe;
          const s = 1 / (1 + Math.exp(-k * x));
          y += gain * s;
        } else if (type === 'lowshelf') {
          const k = 6 * qSafe;
          const s = 1 / (1 + Math.exp(-k * x));
          y += gain * (1 - s);
        }
      });
      y *= strengthNorm * displayBoost;
      y = Math.max(-range, Math.min(range, y));
      values.push({ t, y });
    }
    const points = values.map((pt, idx) => {
      const x = padding + pt.t * plotW;
      const yPx = mid - (pt.y / range) * (plotH / 2);
      return `${idx === 0 ? 'M' : 'L'}${x.toFixed(2)},${yPx.toFixed(2)}`;
    }).join(' ');
    const path = points || `M${padding},${mid} L${w - padding},${mid}`;
    const grid = [
      { y: padding, cls: 'eq-grid' },
      { y: mid, cls: 'eq-grid eq-grid-mid' },
      { y: h - padding, cls: 'eq-grid' },
    ];
    const ticks = [100, 1000, 10000].map(freq => {
      const x = padding + (Math.log(freq / minF) / logStep) * plotW;
      return x;
    });
    const gridLines = grid.map(line => (
      `<line class="${line.cls}" x1="${padding}" y1="${line.y}" x2="${w - padding}" y2="${line.y}" />`
    )).join('');
    const tickLines = ticks.map(x => (
      `<line class="eq-grid eq-grid-vert" x1="${x.toFixed(2)}" y1="${padding}" x2="${x.toFixed(2)}" y2="${h - padding}" />`
    )).join('');
    const fillPath = `${path} L${w - padding},${mid} L${padding},${mid} Z`;
    eqPreview.innerHTML = `
      ${gridLines}
      ${tickLines}
      <path class="eq-fill" d="${fillPath}"></path>
      <path class="eq-curve" d="${path}"></path>
    `;
    if (eqPreviewLabel) {
      eqPreviewLabel.textContent = '';
    }
  }

  function applyVoicingWidth(){
    if (!width || !voicingSelect) return false;
    const entry = voicingIndex[voicingSelect.value];
    if (!entry || !Number.isFinite(entry.width)) return false;
    const minVal = parseFloat(width.min || '0.5');
    const maxVal = parseFloat(width.max || '1.5');
    const nextVal = Math.max(minVal, Math.min(maxVal, entry.width));
    if (parseFloat(width.value) === nextVal) return false;
    width.value = String(nextVal);
    return true;
  }

  function renderVoicingOptions(filterTerm, preferredId){
    if (!voicingSelect) return;
    const term = normalizeText(filterTerm);
    const previousValue = voicingSelect.value;
    const matches = voicingCatalog.filter(entry => {
      if (!term) return true;
      return entry.searchText.includes(term);
    });

    voicingSelect.innerHTML = '';
    if (!matches.length) {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'No matches';
      option.disabled = true;
      voicingSelect.appendChild(option);
      voicingSelect.value = '';
      updateSummary();
      updateVoicingTooltip();
      updateVoicingTags();
      return;
    }

    const groups = { user: [], builtin: [] };
    matches.forEach(entry => {
      const origin = entry.origin === 'builtin' ? 'builtin' : 'user';
      groups[origin].push(entry);
    });
    [
      { key: 'user', label: 'Custom Voicings' },
      { key: 'builtin', label: 'Provided Voicings' },
    ].forEach(group => {
      if (!groups[group.key].length) return;
      const optgroup = document.createElement('optgroup');
      optgroup.label = group.label;
      groups[group.key]
        .sort((a, b) => a.title.localeCompare(b.title))
        .forEach(entry => {
          const option = document.createElement('option');
          option.value = entry.id;
          option.textContent = entry.title;
          option.dataset.tags = entry.tags.join(' ');
          optgroup.appendChild(option);
        });
      voicingSelect.appendChild(optgroup);
    });

    let nextValue = preferredId || previousValue;
    if (!nextValue || !matches.some(entry => entry.id === nextValue)) {
      const universal = matches.find(entry => entry.id === 'universal');
      nextValue = universal ? universal.id : matches[0].id;
    }
    voicingSelect.value = nextValue;
    const widthChanged = applyVoicingWidth();
    if (previousValue !== voicingSelect.value) {
      updateSummary();
      schedulePreview();
    } else if (widthChanged) {
      updateSummary();
    } else {
      updateSummary();
    }
    updateVoicingTooltip();
    updateVoicingTags();
    renderEqPreview();
  }

  async function loadVoicings(){
    if (!voicingSelect) return;
    try{
      const res = await fetch('/api/voicings', { cache: 'no-store' });
      if (!res.ok) throw new Error('voicings_failed');
      const data = await res.json();
      const items = data.items || [];
      if (!items.length && voicingCatalog.length) {
        renderVoicingOptions(voicingFilter?.value || '', state.voicing);
        return;
      }
      voicingCatalog = [];
      voicingIndex = {};
      items.forEach(item => {
        const meta = item.meta || {};
        const rawTags = Array.isArray(meta.tags) ? meta.tags : [];
        const tags = rawTags
          .map(tag => String(tag || '').trim())
          .filter(tag => tag.length);
        const parsedWidth = meta.width !== undefined && meta.width !== null ? parseFloat(meta.width) : null;
        const entry = {
          id: item.name || item.filename || '',
          title: meta.title || item.name || 'Voicing',
          tags,
          origin: item.origin || 'user',
          width: Number.isFinite(parsedWidth) ? parsedWidth : null,
          eq: Array.isArray(meta.eq) ? meta.eq : [],
        };
        if (!entry.id) return;
        entry.searchText = normalizeText([entry.title, entry.id, tags.join(' ')].join(' '));
        voicingCatalog.push(entry);
        voicingIndex[entry.id] = entry;
      });
      renderVoicingOptions(voicingFilter?.value || '', state.voicing);
      renderEqPreview();
    }catch(_err){
      if (voicingCatalog.length) {
        renderVoicingOptions(voicingFilter?.value || '', state.voicing);
        renderEqPreview();
        return;
      }
      voicingSelect.innerHTML = '<option value="" disabled selected>Voicings unavailable</option>';
      updateSummary();
      updateVoicingTooltip();
    }
  }

  async function loadLoudnessProfiles(){
    if (!loudnessMode) return;
    loudProfiles = {};
    const preferredProfile = state.profile || loudnessMode.value || '';
    loudnessMode.innerHTML = '';
    try{
      const res = await fetch('/api/profiles', { cache: 'no-store' });
      if (!res.ok) throw new Error('profiles_failed');
      const data = await res.json();
      const items = data.items || [];
      const options = [];
      items.forEach((item) => {
        const kind = (item.kind || item.meta?.kind || 'profile').toLowerCase();
        if (kind !== 'profile') return;
        const meta = item.meta || {};
        const origin = item.origin || 'user';
        const isCustom = origin !== 'builtin';
        const category = isCustom ? 'Custom Profiles' : meta.category;
        const entry = {
          id: item.name || item.filename || '',
          title: meta.title || item.name || 'Profile',
          lufs: meta.lufs,
          tp: meta.tp,
          category,
          order: isCustom ? 0 : (Number.isFinite(meta.order) ? meta.order : null),
          manual: Boolean(meta.manual),
        };
        if (entry.id) options.push(entry);
      });
      const manualFallback = { id: 'manual', title: 'Manual', manual: true, category: 'Manual', order: 9999 };
      if (!options.some(opt => opt.id === 'manual')) {
        options.push(manualFallback);
      }
      const categoryOrder = [
        'Custom Profiles',
        'Film / TV / Gaming',
        'Online Streaming',
        'Platform Targets',
        'Manual',
      ];
      const grouped = {};
      options.forEach(opt => {
        const category = opt.category || 'Other';
        if (!grouped[category]) grouped[category] = [];
        grouped[category].push(opt);
      });
      const categoryKeys = Object.keys(grouped).sort((a, b) => {
        const aIdx = categoryOrder.indexOf(a);
        const bIdx = categoryOrder.indexOf(b);
        const aRank = aIdx === -1 ? Number.MAX_SAFE_INTEGER : aIdx;
        const bRank = bIdx === -1 ? Number.MAX_SAFE_INTEGER : bIdx;
        if (aRank !== bRank) return aRank - bRank;
        return a.localeCompare(b);
      });
      categoryKeys.forEach(category => {
        const group = grouped[category];
        group.sort((a, b) => {
          const aOrder = a.order ?? Number.MAX_SAFE_INTEGER;
          const bOrder = b.order ?? Number.MAX_SAFE_INTEGER;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return a.title.localeCompare(b.title);
        });
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        group.forEach((opt) => {
          const option = document.createElement('option');
          option.value = opt.id;
          option.textContent = opt.title;
          optgroup.appendChild(option);
          loudProfiles[opt.id] = opt;
        });
        loudnessMode.appendChild(optgroup);
      });
      let targetProfile = preferredProfile && preferredProfile !== 'manual' ? preferredProfile : '';
      if (!loudProfiles[targetProfile]) {
        if (loudProfiles.apple_music) {
          targetProfile = 'apple_music';
        } else if (loudProfiles.apple) {
          targetProfile = 'apple';
        } else if (loudProfiles.manual) {
          targetProfile = 'manual';
        }
      }
      if (targetProfile && loudProfiles[targetProfile]) {
        loudnessMode.value = targetProfile;
      }
      applyLoudnessMode();
    }catch(_err){
      loudnessMode.innerHTML = '<option value="manual">Manual</option>';
      loudProfiles = { manual: { id: 'manual', title: 'Manual', manual: true } };
      applyLoudnessMode();
    }
  }

  function syncOverrideInputs(){
    if (ovTargetI) {
      const enabled = ovTargetI.checked;
      targetI.disabled = !enabled;
      targetIRange.disabled = !enabled;
    }
    if (ovTargetTp) {
      const enabled = ovTargetTp.checked;
      targetTp.disabled = !enabled;
      targetTpRange.disabled = !enabled;
    }
  }

  function applyLoudnessMode(){
    const mode = loudnessMode.value;
    const prof = loudProfiles[mode];
    const lufsVal = prof ? parseFloat(prof.lufs) : NaN;
    const tpVal = prof ? parseFloat(prof.tp) : NaN;
    if (mode === 'manual' || !prof || prof.manual || Number.isNaN(lufsVal) || Number.isNaN(tpVal)){
      ovTargetI.disabled = false;
      ovTargetTp.disabled = false;
      ovTargetI.checked = true;
      ovTargetTp.checked = true;
    }else{
      targetI.value = lufsVal;
      targetIRange.value = lufsVal;
      targetTp.value = tpVal;
      targetTpRange.value = tpVal;
      ovTargetI.checked = false;
      ovTargetTp.checked = false;
      ovTargetI.disabled = true;
      ovTargetTp.disabled = true;
    }
    syncOverrideInputs();
    updateSummary();
    schedulePreview();
  }
  if (loudnessMode) {
    loudnessMode.addEventListener('change', applyLoudnessMode);
  }
  applyLoudnessMode();

  function updateOutputControls(){
    const outputs = [
      { key: 'wav', checkbox: document.getElementById('out_wav'), row: document.querySelector('.format-row[data-format="wav"]') },
      { key: 'mp3', checkbox: document.getElementById('out_mp3'), row: document.querySelector('.format-row[data-format="mp3"]') },
      { key: 'aac', checkbox: document.getElementById('out_aac'), row: document.querySelector('.format-row[data-format="aac"]') },
      { key: 'ogg', checkbox: document.getElementById('out_ogg'), row: document.querySelector('.format-row[data-format="ogg"]') },
      { key: 'flac', checkbox: document.getElementById('out_flac'), row: document.querySelector('.format-row[data-format="flac"]') },
    ];
    outputs.forEach(item => {
      if (!item.row || !item.checkbox) return;
      const enabled = item.checkbox.checked;
      item.row.classList.toggle('disabled', !enabled);
      item.row.querySelectorAll('select').forEach(el => { el.disabled = !enabled; });
    });
  }

  function updateState(){
    state.voicing = voicingSelect?.value || 'universal';
    state.strength = parseInt(strength?.value || '0', 10);
    state.profile = loudnessMode?.value || 'manual';
    state.lufsOverrideEnabled = ovTargetI?.checked ?? false;
    state.lufsValue = parseFloat(targetI?.value || '');
    state.tpOverrideEnabled = ovTargetTp?.checked ?? false;
    state.tpValue = parseFloat(targetTp?.value || '');
    state.widthValue = parseFloat(width?.value || '1.0');
    state.guardrails = guardrails?.checked ?? false;
    state.convertOnly = convertOnly?.checked ?? false;
    state.outputs.wav.enabled = document.getElementById('out_wav')?.checked ?? false;
    state.outputs.wav.bitDepth = document.getElementById('wav_bit_depth')?.value || '';
    state.outputs.wav.sampleRate = document.getElementById('wav_sample_rate')?.value || '';
    state.outputs.mp3.enabled = document.getElementById('out_mp3')?.checked ?? false;
    state.outputs.mp3.bitrate = document.getElementById('mp3_bitrate')?.value || '';
    state.outputs.mp3.vbr = document.getElementById('mp3_vbr')?.value || '';
    state.outputs.aac.enabled = document.getElementById('out_aac')?.checked ?? false;
    state.outputs.aac.codec = document.getElementById('aac_codec')?.value || '';
    state.outputs.aac.container = document.getElementById('aac_container')?.value || '';
    state.outputs.aac.bitrate = document.getElementById('aac_bitrate')?.value || '';
    state.outputs.ogg.enabled = document.getElementById('out_ogg')?.checked ?? false;
    state.outputs.ogg.quality = document.getElementById('ogg_quality')?.value || '';
    state.outputs.flac.enabled = document.getElementById('out_flac')?.checked ?? false;
    state.outputs.flac.level = document.getElementById('flac_level')?.value || '';
    state.outputs.flac.bitDepth = document.getElementById('flac_bit_depth')?.value || '';
    state.outputs.flac.sampleRate = document.getElementById('flac_sample_rate')?.value || '';
  }

  function updateSummary(){
    updateState();
    if (strengthVal) strengthVal.textContent = String(state.strength);
    if (widthVal) widthVal.textContent = state.widthValue.toFixed(2);
    updateOutputControls();
    const count = state.selectedFiles.length;
    const fileLabel = count === 1 ? 'file' : 'files';
    const outputs = Object.entries(state.outputs)
      .filter(([_, val]) => val.enabled)
      .map(([key]) => outputLabels[key]);
    const outputText = outputs.length ? outputs.join(', ') : 'none';
    if (runSummaryText) {
      if (state.convertOnly) {
        runSummaryText.textContent = `${count} ${fileLabel} • Convert Only • Outputs: ${outputText}`;
      } else {
        const profileLabel = loudnessMode?.options[loudnessMode.selectedIndex]?.textContent?.trim() || state.profile;
        const voicingLabel = voicingSelect?.options[voicingSelect.selectedIndex]?.textContent?.trim() || state.voicing;
        runSummaryText.textContent =
          `${count} ${fileLabel} • Voicing: ${voicingLabel} (Strength ${state.strength}) • ` +
          `Profile: ${profileLabel} • Width: ${state.widthValue.toFixed(2)} • Outputs: ${outputText}`;
      }
    }
  }

  function updateRunButton(){
    if (runBtn) runBtn.disabled = state.selectedFiles.length === 0;
  }

  if (strength) {
    strength.addEventListener('input', updateSummary);
    strength.addEventListener('input', schedulePreview);
    strength.addEventListener('input', renderEqPreview);
  }
  if (voicingSelect) {
    voicingSelect.addEventListener('change', () => {
      applyVoicingWidth();
      updateSummary();
      schedulePreview();
      updateVoicingTooltip();
      updateVoicingTags();
      renderEqPreview();
    });
  }
  if (voicingFilter) {
    voicingFilter.addEventListener('input', () => {
      renderVoicingOptions(voicingFilter.value, voicingSelect?.value);
    });
  }
  if (width) width.addEventListener('input', updateSummary);
  if (width) width.addEventListener('input', schedulePreview);
  if (guardrails) guardrails.addEventListener('change', updateSummary);
  if (guardrails) guardrails.addEventListener('change', schedulePreview);
  if (ovTargetI) ovTargetI.addEventListener('change', () => { syncOverrideInputs(); updateSummary(); });
  if (ovTargetI) ovTargetI.addEventListener('change', schedulePreview);
  if (ovTargetTp) ovTargetTp.addEventListener('change', () => { syncOverrideInputs(); updateSummary(); });
  if (ovTargetTp) ovTargetTp.addEventListener('change', schedulePreview);
  if (targetIRange) targetIRange.addEventListener('input', () => { targetI.value = targetIRange.value; updateSummary(); });
  if (targetIRange) targetIRange.addEventListener('input', schedulePreview);
  if (targetI) targetI.addEventListener('input', () => { targetIRange.value = targetI.value; updateSummary(); });
  if (targetI) targetI.addEventListener('input', schedulePreview);
  if (targetTpRange) targetTpRange.addEventListener('input', () => { targetTp.value = targetTpRange.value; updateSummary(); });
  if (targetTpRange) targetTpRange.addEventListener('input', schedulePreview);
  if (targetTp) targetTp.addEventListener('input', () => { targetTpRange.value = targetTp.value; updateSummary(); });
  if (targetTp) targetTp.addEventListener('input', schedulePreview);
  if (convertOnly) convertOnly.addEventListener('change', () => { applyConvertOnly(); updateSummary(); });

  if (previewAudio) {
    previewAudio.addEventListener('play', () => {
      previewAutoPlay = true;
      setPreviewStatus('Playing');
    });
    previewAudio.addEventListener('pause', () => {
      if (previewReadyUrl && !previewIsBuilding) {
        if (!(previewAudio && previewAudio.ended)) {
          previewAutoPlay = false;
        }
        setPreviewStatus('Ready');
      }
    });
    previewAudio.addEventListener('ended', () => {
      if (previewReadyUrl) setPreviewStatus('Ready');
    });
  }

  [
    'out_wav','out_mp3','out_aac','out_ogg','out_flac',
    'wav_bit_depth','wav_sample_rate','mp3_bitrate','mp3_vbr',
    'aac_codec','aac_container','aac_bitrate','ogg_quality',
    'flac_level','flac_bit_depth','flac_sample_rate',
  ].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', updateSummary);
  });

  updateSummary();
  applyConvertOnly();
  loadFiles();
  seedVoicings();
  loadVoicings();
  loadLoudnessProfiles();

  form.addEventListener('submit', async (e)=>{
    e.preventDefault();
    setBusy(true);

    const convertOnlyChecked = convertOnly?.checked;
    const fd = new FormData();
    const files = state.selectedFiles;
    fd.append('infiles', files.join(','));
    fd.append('strength', strength?.value || '80');
    // stages
    if (convertOnlyChecked) {
      fd.append('stage_analyze', '0');
      fd.append('stage_master', '0');
      fd.append('stage_loudness', '0');
      fd.append('stage_stereo', '0');
      fd.append('stage_output', '1');
    } else {
      fd.append('stage_analyze', '1');
      fd.append('stage_master', '1');
      fd.append('stage_loudness', '1');
      fd.append('stage_stereo', '1');
      fd.append('stage_output', '1');
      // voicing
      fd.append('voicing_mode', 'voicing');
      fd.append('voicing_name', voicingSelect?.value || '');
      // loudness
      const activeProfile = loudProfiles[loudnessMode?.value || 'manual'];
      const useProfileTargets = activeProfile && !activeProfile.manual;
      if (useProfileTargets || ovTargetI?.checked) {
        fd.append('lufs', targetI?.value || '');
      }
      if (useProfileTargets || ovTargetTp?.checked) {
        fd.append('tp', targetTp?.value || '');
      }
      // stereo/tone
      if(width?.value){
        fd.append('width', width.value || '');
      }
      if(guardrails?.checked){
        fd.append('guardrails','1');
      }
    }
    // outputs
    const on = id => document.getElementById(id)?.checked;
    const val = id => document.getElementById(id)?.value || '';
    fd.append('out_wav', on('out_wav') ? '1' : '0');
    fd.append('wav_bit_depth', val('wav_bit_depth'));
    fd.append('wav_sample_rate', val('wav_sample_rate'));
    fd.append('out_mp3', on('out_mp3') ? '1' : '0');
    fd.append('mp3_bitrate', val('mp3_bitrate'));
    fd.append('mp3_vbr', val('mp3_vbr') || 'none');
    fd.append('out_aac', on('out_aac') ? '1' : '0');
    fd.append('aac_codec', val('aac_codec'));
    fd.append('aac_container', val('aac_container'));
    fd.append('aac_bitrate', val('aac_bitrate'));
    fd.append('out_ogg', on('out_ogg') ? '1' : '0');
    fd.append('ogg_quality', val('ogg_quality'));
    fd.append('out_flac', on('out_flac') ? '1' : '0');
    fd.append('flac_level', val('flac_level'));
    fd.append('flac_bit_depth', val('flac_bit_depth'));
    fd.append('flac_sample_rate', val('flac_sample_rate'));

    try{
      const res = await fetch('/api/run',{method:'POST', body: fd});
      if(!res.ok){
        const err = await res.json().catch(()=>({detail:'error'}));
        showToast('Run failed: '+ (err.detail || res.status));
      }else{
        showToast('Job started');

        // IMPORTANT: backend run_id is folder name (usually infile without extension).
        // Prefer explicit run_ids from the API, then fall back to stripping extension.
        let runId = null;
        try{
          const j = await res.json();
          if(j && j.primary_run_id){
            runId = j.primary_run_id;
          }else if(j && Array.isArray(j.run_ids) && j.run_ids.length){
            runId = j.run_ids[0];
          }
        }catch(_){ /* ignore */ }
        if(!runId){
          const first = files[0] || '';
          runId = first.replace(/\.[^.]+$/, '') || first;
        }

        setCurrentRun(runId);
        loadOutput(runId);
        refreshMasteringRuns();
      }
    }catch(err){
      showToast('Network error');
    }finally{
      setBusy(false);
    }
  });

  // track run selection clicks to update status polling target + output pane
  document.addEventListener('click', function(evt){
    const btn = evt.target.closest && evt.target.closest('.run-item');
    if(btn && btn.dataset && btn.dataset.song){
      const song = btn.dataset.song;
      setCurrentRun(song);
      if(!btn.getAttribute('hx-get')){
        loadOutput(song);
      }
    }
    const deleteBtn = evt.target.closest && evt.target.closest('[data-action="delete-run"]');
    if(deleteBtn && deleteBtn.dataset && deleteBtn.dataset.song){
      const song = deleteBtn.dataset.song;
      if(!song) return;
      if(!confirm(`Delete outputs for ${song}?`)) return;
      fetch(`/api/song/${encodeURIComponent(song)}`, { method:'DELETE' })
        .then(res => {
          if(!res.ok) throw new Error('delete failed');
          showToast('Deleted');
          refreshMasteringRuns();
          if (outputPaneWrap) {
            outputPaneWrap.innerHTML = `
              <div class="card" id="outputPane" style="background:transparent;border:none;padding:0;">
                <div class="card-head">
                  <div>
                    <div class="card-title">Job Output</div>
                    <div class="muted">Select a run to view outputs.</div>
                  </div>
                </div>
              </div>`;
          }
        })
        .catch(() => showToast('Delete failed'));
    }
    const deleteOutput = evt.target.closest && evt.target.closest('[data-action="delete-output"]');
    if(deleteOutput && deleteOutput.dataset){
      const song = deleteOutput.dataset.song;
      const stem = deleteOutput.dataset.stem;
      if(!song || !stem) return;
      if(!confirm(`Delete ${stem}?`)) return;
      fetch(`/api/output/${encodeURIComponent(song)}/${encodeURIComponent(stem)}`, { method:'DELETE' })
        .then(res => {
          if(!res.ok) throw new Error('delete failed');
          showToast('Deleted');
          loadOutput(song);
        })
        .catch(() => showToast('Delete failed'));
    }
  });

  window.addEventListener('beforeunload', closeStatusStream);
})();
</script>
{% endblock %}
