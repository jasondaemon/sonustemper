{% extends "base.html" %}
{% block page_title %}Mastering | SonusTemper{% endblock %}
{% block title %}Mastering{% endblock %}
{% block subtitle %}Run mastering jobs with voicings/presets, loudness, stereo/tone, and output options.{% endblock %}

{% block sidebar %}
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Processing Status</div>
        <div class="muted">Live status via event stream.</div>
      </div>
    </div>
    <div class="status-list" id="statusList">(waiting)</div>
  </div>
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Previous Runs</div>
        <div class="muted">Recent runs will appear here.</div>
      </div>
    </div>
    <div id="prevRunsWrap"></div>
  </div>
{% endblock %}

{% block content %}
<div class="master-grid">
  <div class="card job-card full-width">
    <div class="card-head">
      <div>
        <div class="card-title">Master</div>
        <div class="muted">Pick a source, choose voicing or preset, tune loudness/stereo, and outputs.</div>
      </div>
      <div class="muted hx-indicator" id="jobIndicator">Working…</div>
    </div>
    <form id="masterForm">
      <!-- form body unchanged -->
    </form>
  </div>

  <div class="card full-width" id="outputPaneWrap">
    <div class="card" id="outputPane" style="background:transparent;border:none;padding:0;">
      <div class="card-head">
        <div>
          <div class="card-title">Job Output</div>
          <div class="muted">Select a run to view outputs.</div>
        </div>
      </div>
      <div class="muted">Output list placeholder.</div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  const indicator = document.getElementById('jobIndicator');
  const statusList = document.getElementById('statusList');
  let currentRun = null;
  let statusSource = null;
  let statusLines = [];
  let statusRenderPending = false;

  function esc(str){
    if(!str) return '';
    if(window.CSS && CSS.escape) return CSS.escape(str);
    return String(str).replace(/[^a-zA-Z0-9_-]/g, '\\$&');
  }

  function setBusy(on){
    if(!indicator) return;
    indicator.style.display = on ? 'inline-block' : 'none';
  }
  setBusy(false);

  function scheduleStatusRender(){
    if(statusRenderPending) return;
    statusRenderPending = true;
    requestAnimationFrame(()=>{
      statusRenderPending = false;
      if(!statusList) return;
      statusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
    });
  }

  function setCurrentRun(song){
    const next = song || null;
    if(next === currentRun && statusSource){
      return;
    }
    currentRun = next;
    startStatusStream();
  }

  function closeStatusStream(){
    if(statusSource){
      statusSource.close();
      statusSource = null;
    }
  }

  function startStatusStream(){
    closeStatusStream();
    statusLines = [];
    scheduleStatusRender();
    if(!currentRun) return;

    const url = `/api/status-stream?song=${encodeURIComponent(currentRun)}`;
    let es;
    try{
      es = new EventSource(url);
      statusSource = es;
      statusLines.push('(connecting…)');
      scheduleStatusRender();
    }catch(err){
      statusLines.push('Event stream unavailable');
      scheduleStatusRender();
      return;
    }

    es.onmessage = (ev)=>{
      let data;
      try{ data = JSON.parse(ev.data); }catch(_){ data = { detail: ev.data }; }
      const ts = data.ts ? new Date(data.ts*1000).toLocaleTimeString() : '';
      const stage = data.stage || '';
      const detail = data.detail || data.message || '';
      const line = [ts, stage, detail].filter(Boolean).join(' ');
      if(line) statusLines.push(line);
      scheduleStatusRender();

      if(data.stage === 'complete' || data.stage === 'error'){
        closeStatusStream();
        refreshPrevRuns(false);
      }
    };

    es.onerror = ()=>{
      closeStatusStream();
      statusLines.push('(status unavailable)');
      scheduleStatusRender();
    };
  }

  async function refreshPrevRuns(selectLatest, preferSong){
    try{
      const res = await fetch('/ui/partials/master_prev',{cache:'no-store'});
      const html = await res.text();
      const wrap = document.getElementById('prevRunsWrap');
      if(wrap){
        wrap.innerHTML = html;
        const desired = preferSong && wrap.querySelector(`.run-item[data-song="${esc(preferSong)}"]`);
        if(desired){
          desired.click();
        }else if(selectLatest){
          const firstBtn = wrap.querySelector('.run-item');
          if(firstBtn){ firstBtn.click(); }
        }
      }
    }catch(err){
      showToast('Failed to refresh runs');
    }
  }

  refreshPrevRuns(false);

  document.addEventListener('click', function(evt){
    const btn = evt.target.closest && evt.target.closest('.run-item');
    if(btn && btn.dataset && btn.dataset.song){
      setCurrentRun(btn.dataset.song);
    }
  });

  window.addEventListener('beforeunload', closeStatusStream);
})();
</script>
{% endblock %}
