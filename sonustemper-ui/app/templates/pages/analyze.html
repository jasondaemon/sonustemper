{% extends "base.html" %}
{% block page_title %}Noise Removal | SonusTemper{% endblock %}
{% block title %}Noise Removal{% endblock %}
{% block subtitle %}Remove hum, hiss, and noise from your audio.{% endblock %}
{% block sidebar %}
  {% if not wide %}
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Noise Removal Status</div>
        <div class="muted">Selection and cleanup activity.</div>
      </div>
    </div>
    <div class="status-list" id="analysisStatusList">(waiting)</div>
  </div>
  <div class="card browse-card">
    <div class="card-head">
      <div>
        <div class="card-title">Song Library</div>
        <div class="muted">Pick a source, run output, or import.</div>
      </div>
    </div>
    <input type="file" id="analysisUploadInput" accept=".wav,.mp3,.flac,.aiff,.aif,.m4a,.ogg,.aac" hidden>
    <div id="analysisBrowser" class="library-browser-container" data-module="analyze"></div>
    <div class="ai-selected-summary">
      <div class="ai-selected-label">Selected File</div>
      <div class="ai-selected-name" id="noiseSelectedName">-</div>
      <div class="ai-selected-meta" id="noiseSelectedMeta">No file selected.</div>
    </div>
    <div class="noise-history">
      <div class="ai-selected-label">Noise Removed History</div>
      <div class="noise-history-list" id="noiseHistoryList">
        <div class="muted">No history yet.</div>
      </div>
    </div>
  </div>
  {% endif %}
{% endblock %}
{% block content %}
  {% if wide %}
    <style>
      .page-analyze .layout{ grid-template-columns: 1fr; }
      .page-analyze .sidebar-slot{ display: none; }
      .page-analyze .content{ max-width: 100%; }
    </style>
  {% endif %}
  <div class="card analyze-card">
    <div class="card-head">
      <div>
        <div class="card-title">Noise Removal</div>
        <div class="muted" id="analysisSubtitle">Remove hum, hiss, and noise from your audio.</div>
      </div>
      <div class="analyze-actions">
        <a class="btn ghost small" id="compareLink" href="/compare">Open Compare</a>
        <a class="btn ghost small" id="analysisWideLink" href="/analyze?wide=1" target="_blank" rel="noopener">Open Wide</a>
      </div>
    </div>

    <div id="analysisEmpty" class="analyze-empty">
      <div class="muted">Select a source or output to remove noise.</div>
    </div>

    <div id="analysisLoaded" class="analyze-loaded" hidden>
      <div class="analysis-info">
        <div class="analysis-file-title" id="analysisFileTitle">-</div>
        <div class="metric-pills analysis-summary" id="analysisSummary"></div>
      </div>

      <div class="analysis-panel analysis-panel-focus" id="analysisSpectrogramPanel">
        <div class="spectrogram-toolbar">
          <div class="pill-toggle">
            <button class="btn ghost small is-active" type="button" id="analysisScaleLog">Log</button>
            <button class="btn ghost small" type="button" id="analysisScaleLin">Linear</button>
          </div>
          <div class="pill-toggle" id="analysisFocusToggle" hidden>
            <button class="btn ghost small is-active" type="button" id="analysisFocusProcessed">Processed</button>
            <button class="btn ghost small" type="button" id="analysisFocusSource">Source</button>
          </div>
          <div class="spectrogram-control">
            <label for="analysisRange">Range</label>
            <input type="range" id="analysisRange" min="80" max="160" step="5" value="120">
            <span class="value-pill" id="analysisRangeVal">120</span>
          </div>
          <div class="spectrogram-control">
            <label for="analysisHeight">Height</label>
            <select id="analysisHeight" class="full-width-select">
              <option value="256">256</option>
              <option value="384" selected>384</option>
              <option value="512">512</option>
            </select>
          </div>
          <div class="spectrogram-control">
            <label for="analysisZoom">Time Zoom</label>
            <input type="range" id="analysisZoom" min="1" max="16" step="1" value="1">
            <span class="value-pill" id="analysisZoomVal">1x</span>
          </div>
          <div class="pill-toggle">
            <button class="btn ghost small is-active" type="button" id="analysisStereoCombined">Combined</button>
            <button class="btn ghost small" type="button" id="analysisStereoSplit">Split</button>
          </div>
          <button class="btn ghost small" type="button" id="analysisFitBtn">Fit</button>
          <span class="value-pill spectro-readout" id="analysisCursor">t=--  f=--</span>
        </div>
        <div class="spectro-viewport spectro-viewport--large" id="spectrogramViewport">
          <div class="spectro-inner" id="spectrogramInner">
            <img id="spectrogramImg" alt="Spectrogram" />
            <div class="spectrogram-loading" id="spectrogramLoading" hidden>Generating Spectrogram…</div>
            <div class="spectrogram-grid" id="spectrogramGrid" aria-hidden="true"></div>
            <div class="spectrogram-overlay" id="spectrogramOverlay"></div>
            <div class="spectrogram-selection" id="spectrogramSelection" hidden></div>
            <div class="spectrogram-playhead" id="spectrogramPlayhead" aria-hidden="true"></div>
          </div>
        </div>
        <div class="spectro-viewport spectro-viewport--mini" id="spectrogramMiniViewport">
          <div class="spectro-inner" id="spectrogramMiniInner">
            <img id="spectrogramMiniImg" alt="Spectrogram overview" />
            <div class="spectrogram-loading spectrogram-loading--mini" id="spectrogramMiniLoading" hidden>Generating…</div>
            <div class="spectro-window" id="spectrogramMiniWindow"></div>
          </div>
        </div>
        <div class="spectro-legend">
          <span id="spectroLegendLow">Low energy (-120 dB)</span>
          <div class="spectro-legend-bar" aria-hidden="true"></div>
          <span id="spectroLegendHigh">High energy (0 dB)</span>
        </div>
        <div class="analysis-player">
          <div class="analysis-player-controls">
            <button class="btn ghost small" type="button" id="analysisPlayBtn">Play</button>
            <button class="btn ghost small" type="button" id="analysisPauseBtn">Pause</button>
            <button class="btn ghost small" type="button" id="analysisStopBtn">Stop</button>
            <span class="muted" id="analysisTimeCurrent">0:00</span>
            <input type="range" id="analysisScrubber" min="0" max="1000" value="0">
            <span class="muted" id="analysisTimeTotal">0:00</span>
          </div>
          <audio id="analysisAudio" preload="metadata" hidden></audio>
        </div>
        <div class="analysis-selection-bar">
          <div class="analysis-selection-readouts">
            <span class="muted">Selection</span>
            <div class="analysis-selection-row">
              <div class="selection-item">
                <span class="selection-label">t0 (s)</span>
                <span class="value-pill" id="noiseT0">-</span>
              </div>
              <div class="selection-item">
                <span class="selection-label">t1 (s)</span>
                <span class="value-pill" id="noiseT1">-</span>
              </div>
            </div>
            <div class="analysis-selection-row">
              <div class="selection-item">
                <span class="selection-label">f0 (Hz)</span>
                <span class="value-pill" id="noiseF0">-</span>
              </div>
              <div class="selection-item">
                <span class="selection-label">f1 (Hz)</span>
                <span class="value-pill" id="noiseF1">-</span>
              </div>
              <div class="selection-item">
                <span class="selection-label">Center (Hz)</span>
                <span class="value-pill" id="noiseCenter">-</span>
              </div>
              <div class="selection-item">
                <span class="selection-label">Bandwidth (Hz)</span>
                <span class="value-pill" id="noiseBandwidth">-</span>
              </div>
            </div>
          </div>
          <div class="analysis-selection-actions">
            <button class="btn ghost tiny" type="button" id="noiseClearBtn">Clear selection</button>
            <span class="muted" id="noiseSelectionHint">No selection yet — drag on the spectrogram above.</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="card analyze-card" id="noiseCleanupCard">
    <div class="card-head">
      <div>
        <div class="card-title">Noise Removal</div>
        <div class="muted">Select a time/frequency region and preview noise removal.</div>
      </div>
    </div>
    <div class="noise-cleanup">
      <div class="noise-left">
        <div class="control-row">
          <label class="control-label">Noise Filter Preset</label>
          <select id="noisePresetSelect" class="full-width-select">
            <option value="">No preset</option>
          </select>
          <div class="muted noise-preset-hint" id="noisePresetHint" hidden></div>
        </div>
        <div class="control-row">
          <label class="control-label">Apply Scope</label>
          <div class="pill-toggle">
            <button class="btn ghost small is-active" type="button" id="noiseScopeGlobal">Apply Globally</button>
            <button class="btn ghost small" type="button" id="noiseScopeSelection">Apply to Selection</button>
          </div>
        </div>
        <div class="control-row compact-row">
          <div class="control-label">Filter depth (dB)</div>
          <input type="range" id="noiseDepthRange" min="-30" max="-6" step="1" value="-18">
          <div class="value-pill" id="noiseDepthVal">-18</div>
        </div>
        <div class="control-row compact-row">
          <div class="control-label">Denoise strength</div>
          <input type="range" id="noiseAfftdnRange" min="0" max="1" step="0.05" value="0.35">
          <div class="value-pill" id="noiseAfftdnVal">0.35</div>
        </div>
        <div class="control-row noise-hp-lp">
          <label class="check"><input type="checkbox" id="noiseHpToggle"> High-pass</label>
          <input type="number" id="noiseHpValue" min="20" max="500" step="1" value="70">
          <label class="check"><input type="checkbox" id="noiseLpToggle"> Low-pass</label>
          <input type="number" id="noiseLpValue" min="1000" max="20000" step="10" value="16000">
        </div>
        <div class="control-row">
          <button class="btn ghost small" type="button" id="noiseSaveBtn">Save as Profile…</button>
        </div>
      </div>
      <div class="noise-right">
        <div class="control-row">
          <label class="control-label">Preview Mode</label>
          <div class="pill-toggle">
            <button class="btn ghost small is-active" type="button" id="noiseModeRemove">Remove noise</button>
            <button class="btn ghost small" type="button" id="noiseModeSolo">Solo noise</button>
          </div>
        </div>
        <div class="control-row preview-row">
          <div class="control-label small-label">Preview</div>
          <audio id="noisePreviewAudio" class="preview-audio" controls preload="none"></audio>
          <span class="muted" id="noisePreviewStatus">Preview idle</span>
        </div>
        <div class="preset-actions">
          <button class="btn btn-primary small" type="button" id="noisePreviewBtn">Preview</button>
          <button class="btn ghost small" type="button" id="noiseSaveNoiseBtn">Save Noise File</button>
          <button class="btn ghost small" type="button" id="noiseRenderBtn">Save Version</button>
        </div>
      </div>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script src="/static/js/library_browser.js"></script>
<script>
(() => {
  const statusList = document.getElementById('analysisStatusList');
  const emptyState = document.getElementById('analysisEmpty');
  const loadedState = document.getElementById('analysisLoaded');
  const summaryPills = document.getElementById('analysisSummary');
  const fileTitle = document.getElementById('analysisFileTitle');
  const analyzeBrowser = document.getElementById('analysisBrowser');
  const analysisUploadInput = document.getElementById('analysisUploadInput');
  const compareLink = document.getElementById('compareLink');
  const analysisWideLink = document.getElementById('analysisWideLink');
  const noiseCleanupCard = document.getElementById('noiseCleanupCard');
  const analysisFocusToggle = document.getElementById('analysisFocusToggle');
  const analysisFocusProcessedBtn = document.getElementById('analysisFocusProcessed');
  const analysisFocusSourceBtn = document.getElementById('analysisFocusSource');
  const spectrogramViewport = document.getElementById('spectrogramViewport');
  const spectrogramInner = document.getElementById('spectrogramInner');
  const spectrogramImg = document.getElementById('spectrogramImg');
  const spectrogramLoading = document.getElementById('spectrogramLoading');
  const spectrogramOverlay = document.getElementById('spectrogramOverlay');
  const spectrogramSelection = document.getElementById('spectrogramSelection');
  const spectrogramGrid = document.getElementById('spectrogramGrid');
  const spectrogramPlayhead = document.getElementById('spectrogramPlayhead');
  const spectrogramMiniViewport = document.getElementById('spectrogramMiniViewport');
  const spectrogramMiniInner = document.getElementById('spectrogramMiniInner');
  const spectrogramMiniImg = document.getElementById('spectrogramMiniImg');
  const spectrogramMiniLoading = document.getElementById('spectrogramMiniLoading');
  const spectrogramMiniWindow = document.getElementById('spectrogramMiniWindow');
  const analysisScaleLog = document.getElementById('analysisScaleLog');
  const analysisScaleLin = document.getElementById('analysisScaleLin');
  const analysisRange = document.getElementById('analysisRange');
  const analysisRangeVal = document.getElementById('analysisRangeVal');
  const analysisHeight = document.getElementById('analysisHeight');
  const analysisZoom = document.getElementById('analysisZoom');
  const analysisZoomVal = document.getElementById('analysisZoomVal');
  const analysisStereoCombinedBtn = document.getElementById('analysisStereoCombined');
  const analysisStereoSplitBtn = document.getElementById('analysisStereoSplit');
  const analysisFitBtn = document.getElementById('analysisFitBtn');
  const analysisCursor = document.getElementById('analysisCursor');
  const spectroLegendLow = document.getElementById('spectroLegendLow');
  const spectroLegendHigh = document.getElementById('spectroLegendHigh');
  const noiseSelectedName = document.getElementById('noiseSelectedName');
  const noiseSelectedMeta = document.getElementById('noiseSelectedMeta');
  const noiseHistoryList = document.getElementById('noiseHistoryList');
  const analysisPlayBtn = document.getElementById('analysisPlayBtn');
  const analysisPauseBtn = document.getElementById('analysisPauseBtn');
  const analysisStopBtn = document.getElementById('analysisStopBtn');
  const analysisScrubber = document.getElementById('analysisScrubber');
  const analysisTimeCurrent = document.getElementById('analysisTimeCurrent');
  const analysisTimeTotal = document.getElementById('analysisTimeTotal');
  const analysisAudio = document.getElementById('analysisAudio');
  const noisePresetSelect = document.getElementById('noisePresetSelect');
  const noisePresetHint = document.getElementById('noisePresetHint');
  const noiseModeRemoveBtn = document.getElementById('noiseModeRemove');
  const noiseModeSoloBtn = document.getElementById('noiseModeSolo');
  const noiseScopeGlobalBtn = document.getElementById('noiseScopeGlobal');
  const noiseScopeSelectionBtn = document.getElementById('noiseScopeSelection');
  const noiseDepthRange = document.getElementById('noiseDepthRange');
  const noiseDepthVal = document.getElementById('noiseDepthVal');
  const noiseAfftdnRange = document.getElementById('noiseAfftdnRange');
  const noiseAfftdnVal = document.getElementById('noiseAfftdnVal');
  const noiseHpToggle = document.getElementById('noiseHpToggle');
  const noiseHpValue = document.getElementById('noiseHpValue');
  const noiseLpToggle = document.getElementById('noiseLpToggle');
  const noiseLpValue = document.getElementById('noiseLpValue');
  const noisePreviewAudio = document.getElementById('noisePreviewAudio');
  const noisePreviewStatus = document.getElementById('noisePreviewStatus');
  const noisePreviewBtn = document.getElementById('noisePreviewBtn');
  const noiseRenderBtn = document.getElementById('noiseRenderBtn');
  const noiseSaveBtn = document.getElementById('noiseSaveBtn');
  const noiseSaveNoiseBtn = document.getElementById('noiseSaveNoiseBtn');
  const noiseClearBtn = document.getElementById('noiseClearBtn');
  const noiseT0 = document.getElementById('noiseT0');
  const noiseT1 = document.getElementById('noiseT1');
  const noiseF0 = document.getElementById('noiseF0');
  const noiseF1 = document.getElementById('noiseF1');
  const noiseCenter = document.getElementById('noiseCenter');
  const noiseBandwidth = document.getElementById('noiseBandwidth');
  const noiseSelectionHint = document.getElementById('noiseSelectionHint');
  let statusLines = [];
  let libraryBrowser = null;
  let analysisContext = {
    source: null,
    processed: null,
    active: null,
    duration: null,
    run_id: null,
    song_id: null,
    song: null,
    versions: [],
    active_version_id: null,
  };
  let analysisPayload = null;
  let noiseSelection = null;
  let noiseSuggestedBand = null;
  let noiseMode = 'remove';
  let noiseScope = 'global';
  let noisePresets = new Map();
  let lastNoiseTargetRel = null;
  let summaryMinHeight = 0;
  const ANALYZE_SCALE_KEY = 'sonustemper.analyzeSpecScale';
  const ANALYZE_DRANGE_KEY = 'sonustemper.analyzeSpecDrange';
  const ANALYZE_HEIGHT_KEY = 'sonustemper.analyzeSpecHeight';
  const ANALYZE_STEREO_KEY = 'sonustemper.analyzeSpecStereo';
  const ANALYZE_MINI_HEIGHT = 90;

  const metricLabels = [
    { key: 'I', label: 'LUFS-I', suffix: ' LUFS' },
    { key: 'TP', label: 'True Peak', suffix: ' dBTP' },
    { key: 'LRA', label: 'LRA', suffix: ' LU' },
    { key: 'rms_level', label: 'RMS', suffix: ' dB' },
    { key: 'crest_factor', label: 'Crest', suffix: ' dB' },
    { key: 'dynamic_range', label: 'DR', suffix: ' dB' },
  ];

  function fmt(num, decimals){
    if (num === null || num === undefined || Number.isNaN(num)) return '-';
    const fixed = (typeof decimals === 'number') ? num.toFixed(decimals) : num.toFixed(1);
    return fixed.replace(/\.0$/, '');
  }

  function formatDelta(outVal, inVal){
    if (typeof outVal !== 'number' || typeof inVal !== 'number') return '';
    const delta = outVal - inVal;
    const sign = delta > 0 ? '+' : '';
    return ` (${sign}${fmt(delta, 1)})`;
  }

  function formatSeconds(val){
    if (val === null || val === undefined || Number.isNaN(val)) return '-';
    return `${val.toFixed(2)}s`;
  }

  function formatHz(val){
    if (val === null || val === undefined || Number.isNaN(val)) return '-';
    if (val >= 1000) return `${(val / 1000).toFixed(2)} kHz`;
    return `${val.toFixed(0)} Hz`;
  }

  function formatClock(seconds){
    if (seconds === null || seconds === undefined || Number.isNaN(seconds)) return '--';
    const total = Math.max(0, seconds);
    const m = Math.floor(total / 60);
    const s = (total % 60).toFixed(1).padStart(4, '0');
    return `${m}:${s}`;
  }

  function formatTimeDisplay(seconds){
    if (seconds === null || seconds === undefined || Number.isNaN(seconds)) return '0:00';
    const total = Math.max(0, seconds);
    const m = Math.floor(total / 60);
    const s = Math.floor(total % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  }

  function loadSetting(key, fallback){
    try {
      const stored = window.localStorage.getItem(key);
      return stored !== null ? stored : fallback;
    } catch (_err) {
      return fallback;
    }
  }

  function saveSetting(key, value){
    try {
      window.localStorage.setItem(key, String(value));
    } catch (_err) {
      return;
    }
  }

  function spectrogramUrl(relPath, w, h, scale, drange, stereo){
    const params = new URLSearchParams({
      path: relPath,
      w: String(w),
      h: String(h),
      scale: scale,
      drange: String(drange),
    });
    if (stereo) params.set('stereo', stereo);
    return `/api/analyze/spectrogram?${params.toString()}`;
  }

  function analysisAudioUrl(rel){
    return `/api/analyze/path?path=${encodeURIComponent(rel)}`;
  }

  function updatePlayhead(){
    if (!analysisAudio || !spectrogramPlayhead || !analysisContext.duration || !spectrogramInner) return;
    const duration = analysisAudio.duration || analysisContext.duration || 0;
    if (!duration || !Number.isFinite(duration)) return;
    const innerWidth = spectrogramInner.getBoundingClientRect().width || 0;
    if (!innerWidth) return;
    const rel = Math.max(0, Math.min(1, analysisAudio.currentTime / duration));
    spectrogramPlayhead.style.left = `${rel * innerWidth}px`;
  }

  function updateScrubber(){
    if (!analysisAudio || !analysisScrubber) return;
    const duration = analysisAudio.duration || analysisContext.duration || 0;
    if (!duration || !Number.isFinite(duration)) {
      analysisScrubber.value = '0';
      if (analysisTimeCurrent) analysisTimeCurrent.textContent = '0:00';
      if (analysisTimeTotal) analysisTimeTotal.textContent = '0:00';
      return;
    }
    const rel = Math.max(0, Math.min(1, analysisAudio.currentTime / duration));
    analysisScrubber.value = String(Math.round(rel * 1000));
    if (analysisTimeCurrent) analysisTimeCurrent.textContent = formatTimeDisplay(analysisAudio.currentTime);
    if (analysisTimeTotal) analysisTimeTotal.textContent = formatTimeDisplay(duration);
  }

  function setAudioSource(rel){
    if (!analysisAudio) return;
    if (!rel) {
      analysisAudio.removeAttribute('src');
      analysisAudio.load();
      return;
    }
    const nextUrl = analysisAudioUrl(rel);
    if (analysisAudio.src !== nextUrl) {
      analysisAudio.pause();
      analysisAudio.src = nextUrl;
      analysisAudio.load();
    }
  }

  let spectroLoadToken = 0;
  let spectroMiniLoadToken = 0;

  function setSpectrogramLoading(on){
    if (spectrogramLoading) spectrogramLoading.hidden = !on;
    if (spectrogramImg) spectrogramImg.classList.toggle('spectrogram-img-hidden', !!on);
  }

  function setMiniSpectrogramLoading(on){
    if (spectrogramMiniLoading) spectrogramMiniLoading.hidden = !on;
    if (spectrogramMiniImg) spectrogramMiniImg.classList.toggle('spectrogram-img-hidden', !!on);
  }

  function setSpectrogramViewport(viewportEl, heightPx, overrideMin){
    if (!viewportEl || !heightPx) return;
    viewportEl.style.height = `${heightPx}px`;
    if (overrideMin) {
      viewportEl.style.minHeight = `${heightPx}px`;
    }
  }

  function renderSpectrogramViewer(spec, relPath, heightPx, preserveCenter, overrideMin){
    if (!spec || !spec.viewport || !spec.inner || !spec.img || !relPath) return;
    const viewport = spec.viewport;
    const inner = spec.inner;
    const zoom = Math.max(1, spec.zoom || 1);
    const baseWidth = Math.max(1, viewport.clientWidth);
    const prevInnerWidth = inner.getBoundingClientRect().width || baseWidth;
    const prevScroll = viewport.scrollLeft;
    const innerWidth = Math.max(baseWidth * zoom, baseWidth);
    setSpectrogramViewport(viewport, heightPx, overrideMin);
    inner.style.width = `${innerWidth}px`;
    inner.style.height = `${heightPx}px`;
    const dpr = window.devicePixelRatio || 1;
    const width = Math.max(300, Math.round(innerWidth * dpr));
    const height = Math.max(200, Math.round(heightPx * dpr));
    const nextUrl = spectrogramUrl(relPath, width, height, spec.scale, spec.drange, spec.stereo);
    const sameUrl = spec.img.src === nextUrl;
    if (spec.img === spectrogramImg && !sameUrl) {
      const token = ++spectroLoadToken;
      spec.img.dataset.loadToken = String(token);
      setSpectrogramLoading(true);
    }
    spec.img.src = nextUrl;
    if (spec.img === spectrogramImg && sameUrl && spec.img.complete) {
      setSpectrogramLoading(false);
    }
    if (preserveCenter && prevInnerWidth > 0) {
      const centerRatio = (prevScroll + baseWidth * 0.5) / prevInnerWidth;
      const nextScroll = Math.max(0, centerRatio * innerWidth - baseWidth * 0.5);
      viewport.scrollLeft = nextScroll;
    } else if (!preserveCenter) {
      viewport.scrollLeft = Math.min(viewport.scrollLeft, Math.max(0, innerWidth - baseWidth));
    }
  }

  function renderMiniSpectrogram(){
    if (!spectrogramMiniViewport || !spectrogramMiniInner || !spectrogramMiniImg) return;
    const target = getActiveNoiseTarget();
    if (!target || !target.rel) {
      spectrogramMiniImg.removeAttribute('src');
      setMiniSpectrogramLoading(false);
      return;
    }
    const widthPx = Math.max(1, spectrogramMiniViewport.clientWidth);
    setSpectrogramViewport(spectrogramMiniViewport, ANALYZE_MINI_HEIGHT, true);
    spectrogramMiniInner.style.width = `${widthPx}px`;
    spectrogramMiniInner.style.height = `${ANALYZE_MINI_HEIGHT}px`;
    const dpr = window.devicePixelRatio || 1;
    const width = Math.max(300, Math.round(widthPx * dpr));
    const height = Math.max(80, Math.round(ANALYZE_MINI_HEIGHT * dpr));
    const miniUrl = spectrogramUrl(
      target.rel,
      width,
      height,
      analysisSpectrogram.scale,
      analysisSpectrogram.drange,
      analysisSpectrogram.stereo
    );
    const sameMini = spectrogramMiniImg.src === miniUrl;
    if (!sameMini) {
      const token = ++spectroMiniLoadToken;
      spectrogramMiniImg.dataset.loadToken = String(token);
      setMiniSpectrogramLoading(true);
    }
    spectrogramMiniImg.src = miniUrl;
    if (sameMini && spectrogramMiniImg.complete) {
      setMiniSpectrogramLoading(false);
    }
    updateMiniWindow();
  }

  function updateMiniWindow(){
    if (!spectrogramMiniWindow || !spectrogramMiniViewport || !spectrogramViewport || !spectrogramInner) return;
    const innerWidth = spectrogramInner.getBoundingClientRect().width || 0;
    const viewportWidth = spectrogramViewport.clientWidth || 0;
    if (!innerWidth || !viewportWidth) return;
    const maxScroll = Math.max(0, innerWidth - viewportWidth);
    const scrollLeft = Math.min(Math.max(0, spectrogramViewport.scrollLeft), maxScroll);
    const windowWidth = Math.max(0, Math.min(1, viewportWidth / innerWidth));
    const leftRatio = maxScroll > 0 ? scrollLeft / innerWidth : 0;
    spectrogramMiniWindow.style.width = `${Math.max(4, windowWidth * 100)}%`;
    spectrogramMiniWindow.style.left = `${Math.max(0, leftRatio * 100)}%`;
  }

  function scrollMainToRatio(ratio){
    const innerWidth = spectrogramInner?.getBoundingClientRect().width || 0;
    const viewportWidth = spectrogramViewport?.clientWidth || 0;
    if (!innerWidth || !viewportWidth) return;
    const targetLeft = ratio * innerWidth - viewportWidth * 0.5;
    const maxScroll = Math.max(0, innerWidth - viewportWidth);
    if (spectrogramViewport) {
      spectrogramViewport.scrollLeft = Math.max(0, Math.min(maxScroll, targetLeft));
    }
  }

  function makeResizeObserver(containerEl, callback){
    if (!containerEl || typeof ResizeObserver === 'undefined') return null;
    let timer = null;
    const observer = new ResizeObserver(() => {
      if (timer) clearTimeout(timer);
      timer = setTimeout(callback, 150);
    });
    observer.observe(containerEl);
    return observer;
  }

  function setNoiseMode(mode){
    noiseMode = mode === 'solo' ? 'solo' : 'remove';
    if (noiseModeRemoveBtn) noiseModeRemoveBtn.classList.toggle('is-active', noiseMode === 'remove');
    if (noiseModeSoloBtn) noiseModeSoloBtn.classList.toggle('is-active', noiseMode === 'solo');
    if (noiseDepthRange) noiseDepthRange.disabled = noiseMode !== 'remove';
  }

  function setNoiseScope(scope){
    noiseScope = scope === 'selection' ? 'selection' : 'global';
    if (noiseScopeGlobalBtn) noiseScopeGlobalBtn.classList.toggle('is-active', noiseScope === 'global');
    if (noiseScopeSelectionBtn) noiseScopeSelectionBtn.classList.toggle('is-active', noiseScope === 'selection');
  }

  function setNoiseStatus(msg){
    if (noisePreviewStatus) noisePreviewStatus.textContent = msg || '';
  }

  function updateNoiseReadouts(selection){
    if (!noiseT0 || !noiseT1 || !noiseF0 || !noiseF1 || !noiseCenter || !noiseBandwidth) return;
    if (!selection) {
      noiseT0.textContent = '-';
      noiseT1.textContent = '-';
      noiseF0.textContent = '-';
      noiseF1.textContent = '-';
      noiseCenter.textContent = '-';
      noiseBandwidth.textContent = '-';
      if (noiseSelectionHint) noiseSelectionHint.textContent = 'No selection yet — drag on the spectrogram above.';
      updateNoiseButtonState();
      return;
    }
    noiseT0.textContent = formatSeconds(selection.t0);
    noiseT1.textContent = formatSeconds(selection.t1);
    noiseF0.textContent = formatHz(selection.f0);
    noiseF1.textContent = formatHz(selection.f1);
    noiseCenter.textContent = formatHz((selection.f0 + selection.f1) * 0.5);
    noiseBandwidth.textContent = formatHz(selection.f1 - selection.f0);
    if (noiseSelectionHint) noiseSelectionHint.textContent = 'Selection ready.';
    if (noisePresetHint && !noiseSuggestedBand) {
      noisePresetHint.hidden = true;
      noisePresetHint.textContent = '';
    }
    updateNoiseButtonState();
  }

  function updateNoiseButtonState(){
    const ok = !!noiseSelection && noiseSelection.t1 > noiseSelection.t0 && noiseSelection.f1 > noiseSelection.f0;
    if (noisePreviewBtn) noisePreviewBtn.disabled = !ok;
    if (noiseRenderBtn) noiseRenderBtn.disabled = !ok;
    if (noiseSaveBtn) noiseSaveBtn.disabled = !ok;
    if (noiseSaveNoiseBtn) noiseSaveNoiseBtn.disabled = !ok;
  }

  function getActiveNoiseTarget(){
    return analysisContext.active;
  }

  function renderActiveSpectrogram(preserveCenter){
    if (!spectrogramImg || !spectrogramViewport || !spectrogramInner) return;
    const target = getActiveNoiseTarget();
    if (!target || !target.rel) {
      if (spectrogramImg) {
        spectrogramImg.removeAttribute('src');
        spectrogramImg.classList.add('spectrogram-img-hidden');
      }
      setSpectrogramLoading(false);
      noiseSelection = null;
      lastNoiseTargetRel = null;
      updateNoiseReadouts(null);
      if (spectrogramMiniImg) {
        spectrogramMiniImg.removeAttribute('src');
        spectrogramMiniImg.classList.add('spectrogram-img-hidden');
      }
      setMiniSpectrogramLoading(false);
      if (spectrogramMiniWindow) {
        spectrogramMiniWindow.style.width = '0';
        spectrogramMiniWindow.style.left = '0';
      }
      return;
    }
    if (lastNoiseTargetRel && lastNoiseTargetRel !== target.rel) {
      noiseSelection = null;
      updateNoiseReadouts(null);
    }
    lastNoiseTargetRel = target.rel;
    renderSpectrogramViewer(analysisSpectrogram, target.rel, analysisSpectrogram.height, preserveCenter, true);
    renderMiniSpectrogram();
    renderNoiseSelectionBox();
    renderSpectroGrid();
    updatePlayhead();
  }

  function clearNoiseSelection(){
    noiseSelection = null;
    lastNoiseTargetRel = null;
    noiseSuggestedBand = null;
    if (noisePresetHint) {
      noisePresetHint.hidden = true;
      noisePresetHint.textContent = '';
    }
    if (spectrogramSelection) spectrogramSelection.hidden = true;
    updateNoiseReadouts(null);
  }

  function setActive(kind){
    const next = kind === 'source' ? analysisContext.source : analysisContext.processed;
    if (!next) return;
    analysisContext.active = next;
    if (analysisFocusProcessedBtn) {
      analysisFocusProcessedBtn.classList.toggle('is-active', kind === 'processed');
    }
    if (analysisFocusSourceBtn) {
      analysisFocusSourceBtn.classList.toggle('is-active', kind === 'source');
    }
    clearNoiseSelection();
    if (analysisPayload) {
      renderPills(analysisPayload, analysisPayload.metrics?.input || null, analysisPayload.metrics?.output || null);
    }
    renderActiveSpectrogram(true);
    if (next.rel) {
      setAudioSource(next.rel);
      updateScrubber();
      updatePlayhead();
      const ext = next.rel ? next.rel.split('.').pop() : '';
      const metrics = next.kind === 'processed' ? analysisPayload?.metrics?.output : analysisPayload?.metrics?.input;
      updateSelectedFileDisplay(analysisContext.song, {
        kind: next.kind,
        rel: next.rel,
        format: ext,
        metrics,
        title: next.name || '',
      });
    }
  }

  const analysisSpectrogram = {
    img: spectrogramImg,
    viewport: spectrogramViewport,
    inner: spectrogramInner,
    scaleLog: analysisScaleLog,
    scaleLin: analysisScaleLin,
    range: analysisRange,
    rangeVal: analysisRangeVal,
    heightSelect: analysisHeight,
    zoomRange: analysisZoom,
    zoomVal: analysisZoomVal,
    fitBtn: analysisFitBtn,
    cursor: analysisCursor,
    scaleKey: ANALYZE_SCALE_KEY,
    drangeKey: ANALYZE_DRANGE_KEY,
    heightKey: ANALYZE_HEIGHT_KEY,
    stereoKey: ANALYZE_STEREO_KEY,
    stereoCombinedBtn: analysisStereoCombinedBtn,
    stereoSplitBtn: analysisStereoSplitBtn,
    scale: 'log',
    drange: 120,
    height: 384,
    zoom: 1,
    stereo: 'combined',
  };

  function loadAnalyzeSpectrogramState(spec){
    spec.scale = loadSetting(spec.scaleKey, 'log');
    spec.drange = parseInt(loadSetting(spec.drangeKey, '120'), 10) || 120;
    spec.height = parseInt(loadSetting(spec.heightKey, '384'), 10) || 384;
    spec.stereo = loadSetting(spec.stereoKey, 'combined');
    if (spec.stereo !== 'separate') spec.stereo = 'combined';
    spec.zoom = 1;
    if (spec.range) spec.range.value = String(spec.drange);
    if (spec.rangeVal) spec.rangeVal.textContent = String(spec.drange);
    if (spec.heightSelect) spec.heightSelect.value = String(spec.height);
    if (spec.zoomRange) spec.zoomRange.value = String(spec.zoom);
    if (spec.zoomVal) spec.zoomVal.textContent = `${spec.zoom}x`;
    if (spec.scaleLog) spec.scaleLog.classList.toggle('is-active', spec.scale !== 'lin');
    if (spec.scaleLin) spec.scaleLin.classList.toggle('is-active', spec.scale === 'lin');
    if (spec.range) spec.range.disabled = spec.scale === 'lin';
    if (spec.stereoCombinedBtn) {
      spec.stereoCombinedBtn.classList.toggle('is-active', spec.stereo !== 'separate');
    }
    if (spec.stereoSplitBtn) {
      spec.stereoSplitBtn.classList.toggle('is-active', spec.stereo === 'separate');
    }
    updateSpectroLegend(spec.drange);
  }

  function updateSpectroLegend(drange){
    const spanLow = spectroLegendLow;
    const spanHigh = spectroLegendHigh;
    if (!spanLow || !spanHigh) return;
    const rangeVal = Number.isFinite(drange) ? Math.max(40, Math.min(160, drange)) : 120;
    spanLow.textContent = `Low energy (-${rangeVal} dB)`;
    spanHigh.textContent = 'High energy (0 dB)';
  }

  function bindAnalyzeSpectrogramControls(spec){
    if (spec.scaleLog) {
      spec.scaleLog.addEventListener('click', () => {
        spec.scale = 'log';
        saveSetting(spec.scaleKey, spec.scale);
        if (spec.scaleLog) spec.scaleLog.classList.add('is-active');
        if (spec.scaleLin) spec.scaleLin.classList.remove('is-active');
        if (spec.range) spec.range.disabled = false;
        renderActiveSpectrogram(false);
      });
    }
    if (spec.scaleLin) {
      spec.scaleLin.addEventListener('click', () => {
        spec.scale = 'lin';
        saveSetting(spec.scaleKey, spec.scale);
        if (spec.scaleLin) spec.scaleLin.classList.add('is-active');
        if (spec.scaleLog) spec.scaleLog.classList.remove('is-active');
        if (spec.range) spec.range.disabled = true;
        renderActiveSpectrogram(false);
      });
    }
    if (spec.range) {
      spec.range.addEventListener('input', () => {
        spec.drange = parseInt(spec.range.value || '120', 10) || 120;
        saveSetting(spec.drangeKey, spec.drange);
        if (spec.rangeVal) spec.rangeVal.textContent = String(spec.drange);
        updateSpectroLegend(spec.drange);
        renderActiveSpectrogram(false);
      });
    }
    if (spec.stereoCombinedBtn) {
      spec.stereoCombinedBtn.addEventListener('click', () => {
        spec.stereo = 'combined';
        saveSetting(spec.stereoKey, spec.stereo);
        spec.stereoCombinedBtn.classList.add('is-active');
        if (spec.stereoSplitBtn) spec.stereoSplitBtn.classList.remove('is-active');
        renderActiveSpectrogram(false);
      });
    }
    if (spec.stereoSplitBtn) {
      spec.stereoSplitBtn.addEventListener('click', () => {
        spec.stereo = 'separate';
        saveSetting(spec.stereoKey, spec.stereo);
        spec.stereoSplitBtn.classList.add('is-active');
        if (spec.stereoCombinedBtn) spec.stereoCombinedBtn.classList.remove('is-active');
        renderActiveSpectrogram(false);
      });
    }
    if (spec.heightSelect) {
      spec.heightSelect.addEventListener('change', () => {
        spec.height = parseInt(spec.heightSelect.value || '384', 10) || 384;
        saveSetting(spec.heightKey, spec.height);
        renderActiveSpectrogram(false);
      });
    }
    if (spec.zoomRange) {
      spec.zoomRange.addEventListener('input', () => {
        spec.zoom = parseInt(spec.zoomRange.value || '1', 10) || 1;
        if (spec.zoomVal) spec.zoomVal.textContent = `${spec.zoom}x`;
        renderActiveSpectrogram(true);
      });
    }
    if (spec.fitBtn) {
      spec.fitBtn.addEventListener('click', () => {
        spec.zoom = 1;
        if (spec.zoomRange) spec.zoomRange.value = '1';
        if (spec.zoomVal) spec.zoomVal.textContent = '1x';
        if (spec.viewport) spec.viewport.scrollLeft = 0;
        renderActiveSpectrogram(false);
      });
    }
  }

  function bindSpectrogramCursor(spec){
    if (!spec || !spec.viewport || !spec.inner || !spec.cursor) return;
    const updateCursor = (evt) => {
      if (!analysisContext.duration) {
        spec.cursor.textContent = 't=--  f=--';
        return;
      }
      const rect = spec.inner.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      if (x < 0 || y < 0 || x > rect.width || y > rect.height) {
        spec.cursor.textContent = 't=--  f=--';
        return;
      }
      const time = (x / rect.width) * analysisContext.duration;
      const freq = yToFreqScaled(y, rect.height, spec.scale);
      spec.cursor.textContent = `t=${formatClock(time)}  f=${formatHz(freq)}`;
    };
    spec.viewport.addEventListener('mousemove', updateCursor);
    spec.viewport.addEventListener('mouseleave', () => {
      spec.cursor.textContent = 't=--  f=--';
    });
  }

  function renderStatus(){
    if (!statusList) return;
    statusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
    statusList.scrollTop = statusList.scrollHeight;
  }

  function addStatusLine(message){
    if (!message) return;
    const ts = new Date().toLocaleTimeString();
    statusLines.push(`${ts} ${message}`);
    if (statusLines.length > 200) statusLines = statusLines.slice(-200);
    renderStatus();
  }

  function renderPills(payload, input, output){
    if (!summaryPills) return;
    summaryPills.innerHTML = '';
    const addPill = (text, title) => {
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      pill.textContent = text;
      if (title) pill.title = title;
      summaryPills.appendChild(pill);
    };
    const active = analysisContext.active;
    const activeName = active?.name || '';
    if (fileTitle) {
      fileTitle.textContent = payload?.run_id || activeName || 'Selected file';
    }
    if (activeName) {
      addPill(activeName, activeName);
    }
    if (analysisContext.duration) {
      addPill(`Duration: ${formatSeconds(analysisContext.duration)}`);
    }
    const isProcessed = active?.kind === 'processed';
    const base = isProcessed ? output : input;
    const reference = isProcessed ? input : null;
    metricLabels.forEach(meta => {
      const val = base ? base[meta.key] : null;
      if (val === null || val === undefined) return;
      const delta = reference ? formatDelta(val, reference[meta.key]) : '';
      addPill(`${meta.label}: ${fmt(val, 1)}${meta.suffix}${delta}`);
    });
    const height = summaryPills.getBoundingClientRect().height;
    if (height > summaryMinHeight) {
      summaryMinHeight = height;
      summaryPills.style.minHeight = `${summaryMinHeight}px`;
    }
  }

  function normalizeUtility(value){
    return String(value || '').trim().toLowerCase();
  }

  function isNoiseRemoved(version){
    const util = normalizeUtility(version?.utility);
    return util === 'noise removed' || util === 'noise cleanup' || util === 'noise removal';
  }

  function updateSelectedFileDisplay(song, track){
    if (!noiseSelectedName || !noiseSelectedMeta) return;
    if (!song && !track) {
      noiseSelectedName.textContent = '-';
      noiseSelectedMeta.textContent = 'No file selected.';
      return;
    }
    const title = song?.title || track?.label || track?.title || 'Selected file';
    noiseSelectedName.textContent = title;
    const parts = [];
    if (track?.kind === 'version') {
      parts.push('Version');
    } else if (track?.kind === 'source') {
      parts.push('Source');
    }
    const fmt = track?.format || (track?.rel ? track.rel.split('.').pop() : '');
    if (fmt) parts.push(fmt.toUpperCase());
    const duration = track?.metrics?.duration_sec || song?.source?.duration_sec;
    if (typeof duration === 'number' && Number.isFinite(duration)) {
      parts.push(formatTimeDisplay(duration));
    }
    noiseSelectedMeta.textContent = parts.length ? parts.join(' · ') : 'Selected file';
  }

  function renderNoiseHistory(){
    if (!noiseHistoryList) return;
    const versions = Array.isArray(analysisContext.versions) ? analysisContext.versions : [];
    const noiseVersions = versions.filter(isNoiseRemoved);
    if (!noiseVersions.length) {
      noiseHistoryList.innerHTML = '<div class="muted">No history yet.</div>';
      return;
    }
    const sorted = noiseVersions.slice().sort((a, b) => {
      const aKey = a.created_at || '';
      const bKey = b.created_at || '';
      return aKey.localeCompare(bKey);
    });
    const primary = sorted[sorted.length - 1];
    noiseHistoryList.innerHTML = '';
    sorted.forEach((version, idx) => {
      const row = document.createElement('div');
      row.className = 'noise-history-row';
      if (primary && primary.version_id === version.version_id) {
        row.classList.add('is-primary');
      }
      const label = document.createElement('div');
      label.className = 'noise-history-label';
      label.textContent = `Noise Removed ${idx + 1}`;
      const meta = document.createElement('div');
      meta.className = 'noise-history-meta';
      meta.textContent = version.created_at ? new Date(version.created_at).toLocaleString() : '—';
      const action = document.createElement('button');
      action.type = 'button';
      action.className = 'btn ghost tiny';
      action.textContent = primary && primary.version_id === version.version_id ? 'Primary' : 'Make Primary';
      action.disabled = primary && primary.version_id === version.version_id;
      action.addEventListener('click', () => promoteNoiseVersion(version));
      row.appendChild(label);
      row.appendChild(meta);
      row.appendChild(action);
      noiseHistoryList.appendChild(row);
    });
  }

  async function promoteNoiseVersion(version){
    if (!version?.version_id) return;
    addStatusLine('Promoting noise-removed version...');
    try {
      const res = await fetch('/api/library/promote-version', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ version_id: version.version_id }),
      });
      if (!res.ok) throw new Error('promote_failed');
      if (libraryBrowser) libraryBrowser.reload();
      const song = await fetchSong(analysisContext.song_id);
      if (song) {
        analysisContext.song = song;
        analysisContext.versions = song.versions || [];
      }
      const rel = primaryRendition(version.renditions)?.rel || version.rel;
      if (rel && analysisContext.song) {
        await loadLibrarySelection(analysisContext.song, {
          kind: 'version',
          rel,
          version_id: version.version_id,
          label: version.label || version.title,
        }, true);
      }
      addStatusLine('Noise Removed version promoted.');
    } catch (_err) {
      addStatusLine('Failed to promote version.');
    }
  }

  function syncPreserveLinks(params){
    const search = params.toString();
    document.querySelectorAll('a[data-preserve-query="true"]').forEach((link) => {
      const href = link.getAttribute('href');
      if (!href) return;
      try {
        const url = new URL(href, window.location.origin);
        url.search = search;
        link.setAttribute('href', `${url.pathname}${url.search}`);
      } catch (_err) {
        return;
      }
    });
  }

  function updateUrl(params){
    const next = new URL(window.location.href);
    next.search = params.toString();
    window.history.pushState({}, '', next.toString());
    if (compareLink) {
      compareLink.href = `/compare${next.search}`;
    }
    syncPreserveLinks(params);
  }

  async function resolveRun(song, out, solo){
    const params = new URLSearchParams();
    params.set('song', song);
    if (out) params.set('out', out);
    if (solo) params.set('solo', '1');
    const res = await fetch(`/api/analyze-resolve?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function resolveFile(kind, rel){
    const params = new URLSearchParams();
    if (kind === 'source') {
      params.set('src', rel);
    } else if (kind === 'import') {
      params.set('imp', rel);
    }
    const res = await fetch(`/api/analyze-resolve-file?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function resolvePair(srcRel, procRel){
    const params = new URLSearchParams();
    params.set('src', srcRel);
    params.set('proc', procRel);
    const res = await fetch(`/api/analyze-resolve-pair?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function fetchSong(songId){
    if (!songId) return null;
    const res = await fetch('/api/library', { cache: 'no-store' });
    if (!res.ok) return null;
    const data = await res.json();
    return (data.songs || []).find(song => song.song_id === songId) || null;
  }

  function updateCompareLinkWithRel(srcRel, procRel){
    if (!compareLink) return;
    const url = new URL('/compare', window.location.origin);
    if (srcRel) url.searchParams.set('src', srcRel);
    if (procRel) url.searchParams.set('proc', procRel);
    compareLink.href = `${url.pathname}${url.search}`;
  }

  function normalizeLibraryRel(rel){
    if (!rel) return null;
    const raw = String(rel);
    if (raw.startsWith('in/')) return { kind: 'source', rel: raw.slice(3) };
    if (raw.startsWith('analysis/')) return { kind: 'import', rel: raw.slice(9) };
    if (raw.startsWith('library/songs/')) {
      if (raw.includes('/source/')) return { kind: 'source', rel: raw };
      return { kind: 'import', rel: raw };
    }
    return { kind: 'any', rel: raw };
  }

  function primaryRendition(renditions){
    const list = Array.isArray(renditions) ? renditions : [];
    if (!list.length) return null;
    const prefer = ['wav', 'flac', 'aiff', 'aif', 'm4a', 'aac', 'mp3', 'ogg'];
    for (const fmt of prefer) {
      const hit = list.find(item => String(item.format || '').toLowerCase() === fmt);
      if (hit) return hit;
    }
    return list[0];
  }

  async function loadLibrarySelection(song, track, shouldPush){
    if (!track?.rel) return;
    const sourceRel = song?.source?.rel || null;
    if (song) {
      analysisContext.song = song;
      analysisContext.versions = song.versions || [];
    }
    if (track.kind === 'version') {
      const srcRel = sourceRel || track.rel;
      const params = new URLSearchParams();
      params.set('src', srcRel);
      params.set('proc', track.rel);
      addStatusLine(`Loading ${song?.title || track.label || 'selection'}...`);
      if (shouldPush) updateUrl(params);
      const data = await resolvePair(srcRel, track.rel);
      await applyData(data);
      analysisContext.song_id = song?.song_id || null;
      analysisContext.active_version_id = track.version_id || null;
      updateCompareLinkWithRel(srcRel, track.rel);
      addStatusLine('Analysis ready');
      updateSelectedFileDisplay(song, track);
      renderNoiseHistory();
      return;
    }
    const parsed = normalizeLibraryRel(track.rel);
    if (parsed?.kind === 'source' || parsed?.kind === 'import') {
      addStatusLine(`Loading ${parsed.kind}...`);
      const params = new URLSearchParams();
      params.set(parsed.kind === 'source' ? 'src' : 'imp', parsed.rel);
      if (shouldPush) updateUrl(params);
      const data = await resolveFile(parsed.kind, parsed.rel);
      await applyData(data);
      analysisContext.song_id = song?.song_id || null;
      analysisContext.active_version_id = null;
      updateCompareLinkWithRel(parsed.kind === 'source' ? parsed.rel : null, null);
      addStatusLine('Analysis ready');
      updateSelectedFileDisplay(song, track);
      renderNoiseHistory();
      return;
    }
    addStatusLine('Analysis failed');
  }

  const NOISE_FREQ_MIN = 20;
  const NOISE_FREQ_MAX = 20000;

  function freqToY(freq, height){
    const safe = Math.max(NOISE_FREQ_MIN, Math.min(NOISE_FREQ_MAX, freq));
    const norm = (Math.log(safe) - Math.log(NOISE_FREQ_MIN)) / Math.log(NOISE_FREQ_MAX / NOISE_FREQ_MIN);
    return (1 - norm) * height;
  }

  function yToFreq(y, height){
    const norm = 1 - (y / height);
    return Math.exp(Math.log(NOISE_FREQ_MIN) + norm * Math.log(NOISE_FREQ_MAX / NOISE_FREQ_MIN));
  }

  function yToFreqScaled(y, height, scale){
    if (scale === 'lin') {
      const norm = 1 - (y / height);
      return NOISE_FREQ_MIN + norm * (NOISE_FREQ_MAX - NOISE_FREQ_MIN);
    }
    return yToFreq(y, height);
  }

  const GRID_FREQS = [60, 120, 250, 500, 1000, 2000, 4000, 8000, 12000, 16000];

  function formatGridLabel(freq){
    if (freq >= 1000) {
      const val = freq >= 10000 ? (freq / 1000).toFixed(0) : (freq / 1000).toFixed(1);
      return `${val.replace(/\.0$/, '')}k`;
    }
    return `${freq} Hz`;
  }

  function renderSpectroGrid(){
    if (!spectrogramGrid || !spectrogramInner) return;
    spectrogramGrid.innerHTML = '';
    const height = spectrogramInner.getBoundingClientRect().height || 0;
    if (!height) return;
    GRID_FREQS.forEach((freq) => {
      const y = freqToYScaled(freq, height, analysisSpectrogram.scale);
      const line = document.createElement('div');
      line.className = 'spectrogram-grid-line';
      line.style.top = `${y}px`;
      spectrogramGrid.appendChild(line);
      const label = document.createElement('div');
      label.className = 'spectrogram-grid-label';
      label.textContent = formatGridLabel(freq);
      label.style.top = `${y}px`;
      spectrogramGrid.appendChild(label);
    });
  }

  function freqToYScaled(freq, height, scale){
    const safe = Math.max(NOISE_FREQ_MIN, Math.min(NOISE_FREQ_MAX, freq));
    if (scale === 'lin') {
      const norm = (safe - NOISE_FREQ_MIN) / (NOISE_FREQ_MAX - NOISE_FREQ_MIN);
      return (1 - norm) * height;
    }
    return freqToY(safe, height);
  }

  function renderNoiseSelectionBox(){
    if (!spectrogramSelection || !spectrogramOverlay) return;
    if (!noiseSelection || !analysisContext.duration) {
      spectrogramSelection.hidden = true;
      return;
    }
    const rect = spectrogramOverlay.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const t0 = Math.max(0, Math.min(noiseSelection.t0, noiseSelection.t1));
    const t1 = Math.max(0, Math.max(noiseSelection.t0, noiseSelection.t1));
    const f0 = Math.max(NOISE_FREQ_MIN, Math.min(noiseSelection.f0, noiseSelection.f1));
    const f1 = Math.max(NOISE_FREQ_MIN, Math.max(noiseSelection.f0, noiseSelection.f1));
    const x0 = (t0 / analysisContext.duration) * rect.width;
    const x1 = (t1 / analysisContext.duration) * rect.width;
    const y0 = freqToYScaled(f1, rect.height, analysisSpectrogram.scale);
    const y1 = freqToYScaled(f0, rect.height, analysisSpectrogram.scale);
    spectrogramSelection.hidden = false;
    spectrogramSelection.style.left = `${x0}px`;
    spectrogramSelection.style.top = `${y0}px`;
    spectrogramSelection.style.width = `${Math.max(2, x1 - x0)}px`;
    spectrogramSelection.style.height = `${Math.max(2, y1 - y0)}px`;
  }

  function bindSpectrogramSelection(){
    if (!spectrogramOverlay || !spectrogramSelection) return;
    const updateCrosshair = (evt) => {
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      spectrogramOverlay.style.setProperty('--cursor-x', `${x}px`);
      spectrogramOverlay.style.setProperty('--cursor-y', `${y}px`);
      spectrogramOverlay.classList.add('is-hovering');
    };
    let dragging = false;
    let startX = 0;
    let startY = 0;
    const onMove = (evt) => {
      if (!dragging) return;
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      const left = Math.min(startX, x);
      const top = Math.min(startY, y);
      const width = Math.abs(x - startX);
      const height = Math.abs(y - startY);
      spectrogramSelection.hidden = false;
      spectrogramSelection.style.left = `${left}px`;
      spectrogramSelection.style.top = `${top}px`;
      spectrogramSelection.style.width = `${Math.max(width, 2)}px`;
      spectrogramSelection.style.height = `${Math.max(height, 2)}px`;
      if (analysisContext.duration) {
        const right = left + Math.max(width, 2);
        const bottom = top + Math.max(height, 2);
        const t0 = (left / rect.width) * analysisContext.duration;
        const t1 = (right / rect.width) * analysisContext.duration;
        const f0 = yToFreqScaled(bottom, rect.height, analysisSpectrogram.scale);
        const f1 = yToFreqScaled(top, rect.height, analysisSpectrogram.scale);
        noiseSelection = { t0, t1, f0, f1 };
        updateNoiseReadouts(noiseSelection);
      }
      updateCrosshair(evt);
    };
    const onUp = (evt) => {
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x1 = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y1 = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      const left = Math.min(startX, x1);
      const right = Math.max(startX, x1);
      const top = Math.min(startY, y1);
      const bottom = Math.max(startY, y1);
      if (right - left < 4 || bottom - top < 4) {
        noiseSelection = null;
        spectrogramSelection.hidden = true;
        updateNoiseReadouts(null);
        return;
      }
      const duration = analysisContext.duration || 0;
      const toTime = (x) => (duration ? (x / rect.width) * duration : 0);
      const toFreq = (y) => yToFreqScaled(y, rect.height, analysisSpectrogram.scale);
      const t0 = toTime(left);
      const t1 = toTime(right);
      let f0 = toFreq(bottom);
      let f1 = toFreq(top);
      if (noiseSuggestedBand) {
        f0 = noiseSuggestedBand.f0;
        f1 = noiseSuggestedBand.f1;
        noiseSuggestedBand = null;
        if (noisePresetHint) {
          noisePresetHint.hidden = true;
          noisePresetHint.textContent = '';
        }
      }
      noiseSelection = { t0, t1, f0, f1 };
      updateNoiseReadouts(noiseSelection);
    };
    spectrogramOverlay.addEventListener('mousedown', (evt) => {
      if (!analysisContext.duration || !spectrogramImg?.src) return;
      const rect = spectrogramOverlay.getBoundingClientRect();
      startX = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      startY = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      dragging = true;
      updateCrosshair(evt);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
    spectrogramOverlay.addEventListener('mousemove', (evt) => {
      if (!dragging) updateCrosshair(evt);
    });
    spectrogramOverlay.addEventListener('mouseleave', () => {
      spectrogramOverlay.classList.remove('is-hovering');
    });
  }

  function collectNoisePayload(){
    const target = getActiveNoiseTarget();
    if (!target || !target.rel) return null;
    if (!noiseSelection) return null;
    const bandDepth = noiseDepthRange ? parseFloat(noiseDepthRange.value || '-18') : -18;
    const strength = noiseAfftdnRange ? parseFloat(noiseAfftdnRange.value || '0') : 0;
    const hp = noiseHpToggle?.checked ? parseFloat(noiseHpValue?.value || '') : null;
    const lp = noiseLpToggle?.checked ? parseFloat(noiseLpValue?.value || '') : null;
    return {
      path: target.rel,
      start_sec: noiseSelection.t0,
      end_sec: noiseSelection.t1,
      t0_sec: noiseSelection.t0,
      t1_sec: noiseSelection.t1,
      f_low: noiseSelection.f0,
      f_high: noiseSelection.f1,
      mode: noiseMode,
      apply_scope: noiseScope,
      band_depth_db: bandDepth,
      afftdn_strength: strength,
      hp_hz: Number.isFinite(hp) ? hp : null,
      lp_hz: Number.isFinite(lp) ? lp : null,
      preview_len_sec: 10,
    };
  }

  function summarizeNoisePayload(prefix, payload){
    if (!payload) return;
    const hp = payload.hp_hz ? `${Math.round(payload.hp_hz)}Hz` : 'off';
    const lp = payload.lp_hz ? `${Math.round(payload.lp_hz)}Hz` : 'off';
    addStatusLine(`${prefix}: building filter chain...`);
    addStatusLine(
      `${prefix}: mode=${payload.mode} f0=${formatHz(payload.f_low)} f1=${formatHz(payload.f_high)} ` +
      `depth=${payload.band_depth_db} denoise=${payload.afftdn_strength} hp=${hp} lp=${lp}`
    );
  }

  async function previewNoise(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to preview.');
      return;
    }
    summarizeNoisePayload('Preview', payload);
    addStatusLine('Preview: starting ffmpeg...');
    setNoiseStatus('Previewing...');
    try {
      const res = await fetch('/api/analyze/noise/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'preview_failed');
      }
      const data = await res.json();
      if (noisePreviewAudio && data.url) {
        noisePreviewAudio.src = data.url;
        noisePreviewAudio.play().catch(() => {});
      }
      const startText = typeof data.preview_start === 'number' ? data.preview_start.toFixed(2) : '-';
      setNoiseStatus(`Preview starts at ${startText}s`);
    } catch (_err) {
      setNoiseStatus('Preview failed.');
    }
  }

  async function renderNoise(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to render.');
      return;
    }
    payload.mode = 'remove';
    summarizeNoisePayload('Render Cleaned Copy', payload);
    addStatusLine('Render Cleaned Copy: starting ffmpeg...');
    setNoiseStatus('Rendering full file...');
    try {
      const songId = await ensureSongId();
      if (!songId) throw new Error('missing_song');
      payload.song_id = songId;
      const res = await fetch('/api/analyze/noise/render', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'render_failed');
      }
      const data = await res.json();
      if (libraryBrowser) libraryBrowser.reload();
      if (analysisContext.source?.rel && data.output_rel) {
        const song = await fetchSong(analysisContext.song_id);
        if (song) {
          const version = (song.versions || []).find((v) => {
            const primary = primaryRendition(v.renditions);
            return (primary?.rel || v.rel) === data.output_rel;
          });
          analysisContext.song = song;
          analysisContext.versions = song.versions || [];
          analysisContext.active_version_id = version?.version_id || null;
        }
        const dataPayload = await resolvePair(analysisContext.source.rel, data.output_rel);
        await applyData(dataPayload);
      }
      if (typeof showToast === 'function') {
        showToast(`Cleaned copy ready: ${data.output_name || 'output'}`);
      }
      addStatusLine(`Saved version: ${data.output_name || 'output'}`);
      setNoiseStatus('Render complete.');
    } catch (_err) {
      setNoiseStatus('Render failed.');
    }
  }

  async function saveNoiseFile(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to save noise.');
      return;
    }
    payload.mode = 'solo';
    summarizeNoisePayload('Save Noise File', payload);
    addStatusLine('Save Noise File: starting ffmpeg...');
    setNoiseStatus('Saving noise file...');
    try {
      const songId = await ensureSongId();
      if (!songId) throw new Error('missing_song');
      payload.song_id = songId;
      const res = await fetch('/api/analyze/noise/render', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'render_failed');
      }
      const data = await res.json();
      if (libraryBrowser) libraryBrowser.reload();
      const song = await fetchSong(analysisContext.song_id);
      if (song) {
        analysisContext.song = song;
        analysisContext.versions = song.versions || [];
        renderNoiseHistory();
      }
      addStatusLine(`Saved version: ${data.output_name || 'noise profile'}`);
      setNoiseStatus('Noise file saved.');
    } catch (_err) {
      setNoiseStatus('Noise file save failed.');
    }
  }

  async function ensureSongId(){
    if (analysisContext.song_id) return analysisContext.song_id;
    if (!analysisContext.source?.rel) return null;
    try {
      const res = await fetch('/api/library/import_source', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          path: analysisContext.source.rel,
          title: analysisContext.source.name || 'Untitled',
        }),
      });
      if (!res.ok) return null;
      const data = await res.json();
      analysisContext.song_id = data.song?.song_id || null;
      if (libraryBrowser) libraryBrowser.reload();
      return analysisContext.song_id;
    } catch (_err) {
      return null;
    }
  }

  async function uploadFile(file){
    return new Promise((resolve, reject) => {
      const fd = new FormData();
      fd.append('file', file, file.name);
      const xhr = new XMLHttpRequest();
      xhr.open('POST', '/api/analyze-upload', true);
      xhr.responseType = 'json';
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(xhr.response || {});
        } else {
          reject(new Error('upload_failed'));
        }
      });
      xhr.addEventListener('error', () => reject(new Error('upload_failed')));
      xhr.send(fd);
    });
  }

  async function attachUnsortedOutput(item){
    const res = await fetch('/api/library', { cache: 'no-store' });
    if (!res.ok) return;
    const data = await res.json();
    const songs = Array.isArray(data.songs) ? data.songs : [];
    const list = songs.map((song, idx) => `${idx + 1}) ${song.title || 'Untitled'}`).join('\n');
    const choice = prompt(`Add output to which song?\n${list}\n\nEnter number or type a new title.`, '');
    if (!choice) return;
    const idx = parseInt(choice, 10);
    if (!Number.isNaN(idx) && songs[idx - 1]) {
      const song = songs[idx - 1];
      await fetch('/api/library/add_version', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          song_id: song.song_id,
          kind: 'manual',
          label: item.name || 'Output',
          rel: item.rel,
          summary: {},
          tags: [],
        }),
      });
    } else {
      const title = choice.trim() || item.name || item.rel;
      await fetch('/api/library/import_source', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: item.rel, title }),
      });
    }
  }

  async function loadNoisePresets(){
    if (!noisePresetSelect) return;
    noisePresetSelect.innerHTML = '<option value="">No preset</option>';
    noisePresets = new Map();
    try {
      const [builtinRes, userRes] = await Promise.all([
        fetch('/api/library/noise_filters?origin=builtin', { cache: 'no-store' }),
        fetch('/api/library/noise_filters?origin=user', { cache: 'no-store' }),
      ]);
      if (!builtinRes.ok || !userRes.ok) throw new Error('preset_failed');
      const builtinData = await builtinRes.json();
      const userData = await userRes.json();
      const appendGroup = (items, label) => {
        if (!items.length) return;
        const group = document.createElement('optgroup');
        group.label = label;
        items.forEach((item) => {
          const title = item.meta?.title || item.id || 'Noise Filter';
          const option = document.createElement('option');
          option.value = item.id || '';
          option.textContent = title;
          group.appendChild(option);
          noisePresets.set(option.value, item);
        });
        noisePresetSelect.appendChild(group);
      };
      appendGroup(builtinData.items || [], 'Built-in');
      appendGroup(userData.items || [], 'Your Presets');
    } catch (_err) {
      addStatusLine('Failed to load noise presets.');
    }
  }

  function applyNoisePreset(id){
    const item = noisePresets.get(id);
    if (!item || !item.noise) return;
    const noise = item.noise;
    if (noiseDepthRange && typeof noise.band_depth_db === 'number') {
      noiseDepthRange.value = String(noise.band_depth_db);
      if (noiseDepthVal) noiseDepthVal.textContent = String(noise.band_depth_db);
    }
    if (noiseAfftdnRange && typeof noise.afftdn_strength === 'number') {
      noiseAfftdnRange.value = String(noise.afftdn_strength);
      if (noiseAfftdnVal) noiseAfftdnVal.textContent = String(noise.afftdn_strength);
    }
    if (noiseHpToggle && noiseHpValue) {
      noiseHpToggle.checked = typeof noise.hp_hz === 'number';
      if (typeof noise.hp_hz === 'number') noiseHpValue.value = String(noise.hp_hz);
    }
    if (noiseLpToggle && noiseLpValue) {
      noiseLpToggle.checked = typeof noise.lp_hz === 'number';
      if (typeof noise.lp_hz === 'number') noiseLpValue.value = String(noise.lp_hz);
    }
    if (noise.mode) setNoiseMode(noise.mode);
    if (noisePresetHint) {
      noisePresetHint.hidden = true;
      noisePresetHint.textContent = '';
    }
    if (noise.f_low && noise.f_high) {
      if (noiseSelection) {
        noiseSelection = {
          t0: noiseSelection.t0,
          t1: noiseSelection.t1,
          f0: noise.f_low,
          f1: noise.f_high,
        };
        updateNoiseReadouts(noiseSelection);
        renderNoiseSelectionBox();
        noiseSuggestedBand = null;
      } else {
        noiseSuggestedBand = { f0: noise.f_low, f1: noise.f_high };
        if (noisePresetHint) {
          noisePresetHint.textContent = `Preset suggests ${formatHz(noise.f_low)}–${formatHz(noise.f_high)}. Drag a box to choose the time region.`;
          noisePresetHint.hidden = false;
        }
        updateNoiseButtonState();
      }
    } else {
      noiseSuggestedBand = null;
      updateNoiseButtonState();
    }
  }

  async function saveNoisePreset(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to save.');
      return;
    }
    const title = prompt('Noise filter name', 'Noise Cleanup');
    if (!title) return;
    addStatusLine('Save Noise Profile: starting...');
    setNoiseStatus('Saving preset...');
    try {
      const res = await fetch('/api/analyze/noise/preset/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title,
          target_kind: 'noise_filter',
          settings: {
            f_low: payload.f_low,
            f_high: payload.f_high,
            band_depth_db: payload.band_depth_db,
            afftdn_strength: payload.afftdn_strength,
            hp_hz: payload.hp_hz,
            lp_hz: payload.lp_hz,
            mode: payload.mode,
          },
          source_hint: { from_file: getActiveNoiseTarget()?.name || '' },
        }),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'save_failed');
      }
      await res.json();
      setNoiseStatus('Preset saved.');
      loadNoisePresets();
    } catch (_err) {
      setNoiseStatus('Preset save failed.');
    }
  }

  async function applyData(payload){
    if (!payload) return;
    const input = payload.metrics?.input || null;
    const output = payload.metrics?.output || null;
    analysisPayload = payload;
    if (emptyState) emptyState.hidden = true;
    if (loadedState) loadedState.hidden = false;
    const durationFallback = payload.duration_s ?? output?.duration_sec ?? input?.duration_sec ?? null;
    const sourceEntry = payload.source_rel ? { rel: payload.source_rel, name: payload.source_name || 'Source', kind: 'source' } : null;
    const processedEntry = payload.processed_rel ? { rel: payload.processed_rel, name: payload.processed_name || 'Processed', kind: 'processed' } : null;
    analysisContext = {
      duration: durationFallback,
      source: sourceEntry,
      processed: processedEntry,
      active: null,
      run_id: payload.run_id || null,
      song_id: analysisContext.song_id || null,
      song: analysisContext.song || null,
      versions: analysisContext.versions || [],
      active_version_id: analysisContext.active_version_id || null,
    };
    if (analysisFocusToggle) {
      analysisFocusToggle.hidden = !(sourceEntry && processedEntry);
    }
    if (processedEntry) {
      setActive('processed');
    } else if (sourceEntry) {
      setActive('source');
    } else {
      analysisContext.active = null;
      renderPills(payload, input, output);
      renderActiveSpectrogram(false);
    }
    const active = analysisContext.active;
    let track = null;
    if (active) {
      const rel = active.rel || '';
      const ext = rel ? rel.split('.').pop() : '';
      const metrics = active.kind === 'processed' ? output : input;
      track = { kind: active.kind, rel, format: ext, metrics, title: active.name || '' };
    }
    updateSelectedFileDisplay(analysisContext.song, track);
    renderNoiseHistory();
  }

  async function selectAndLoad(item, node, shouldPush){
    if (!item) return;
    if (node && analyzeBrowser) {
      analyzeBrowser.querySelectorAll('.browser-item.active').forEach(el => el.classList.remove('active'));
      node.classList.add('active');
    }
    try {
      if (item.kind === 'mastering_output') {
        addStatusLine(`Loading run ${item.song}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (item.out) params.set('out', item.out);
        if (item.solo) params.set('solo', '1');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', item.solo);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'mastering_run') {
        addStatusLine(`Loading run ${item.song || item.id}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', false);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'source' || item.kind === 'import') {
        addStatusLine(`Loading ${item.kind}...`);
        const params = new URLSearchParams();
        params.set(item.kind === 'source' ? 'src' : 'imp', item.rel);
        if (shouldPush) updateUrl(params);
        const data = await resolveFile(item.kind, item.rel);
        await applyData(data);
        addStatusLine('Analysis ready');
      }
    } catch (_err) {
      if (typeof showToast === 'function') showToast('Analyze data unavailable');
      addStatusLine('Analysis failed');
    }
  }

  if (compareLink && window.location.search) {
    compareLink.href = `/compare${window.location.search}`;
  }
  if (analysisWideLink) {
    const url = new URL('/analyze', window.location.origin);
    if (window.location.search) url.search = window.location.search;
    url.searchParams.set('wide', '1');
    analysisWideLink.href = `${url.pathname}${url.search}`;
  }

  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  const out = params.get('out');
  const solo = params.get('solo');
  let src = params.get('src');
  const proc = params.get('proc');
  const imp = params.get('imp');
  if (song) {
    selectAndLoad(
      out
        ? { kind: 'mastering_output', id: `${song}::${out}`, song, out, solo: solo === '1' || solo === 'true' }
        : { kind: 'mastering_run', id: song, song },
      null,
      false
    );
  } else if (src && proc) {
    resolvePair(src, proc).then(async (data) => {
      await applyData(data);
      updateCompareLinkWithRel(src, proc);
      addStatusLine('Analysis ready');
    }).catch(() => {
      addStatusLine('Analysis failed');
    });
  } else if (src) {
    const parsed = normalizeLibraryRel(src);
    if (parsed?.kind === 'source' || parsed?.kind === 'import') {
      src = parsed.rel;
    }
    selectAndLoad({ kind: 'source', rel: src }, null, false);
  } else if (imp) {
    selectAndLoad({ kind: 'import', rel: imp }, null, false);
  }

  if (analyzeBrowser && window.LibraryBrowser) {
    const browser = window.LibraryBrowser.init(analyzeBrowser, { module: 'analyze' });
    libraryBrowser = browser;
    analyzeBrowser.addEventListener('library:select', async (evt) => {
      const { song, track } = evt.detail || {};
      try {
        await loadLibrarySelection(song, track, true);
      } catch (_err) {
        addStatusLine('Analysis failed');
        if (typeof showToast === 'function') showToast('Analyze data unavailable');
      }
    });
    analyzeBrowser.addEventListener('library:action', async (evt) => {
      const { action, song, version, item } = evt.detail || {};
      if (action === 'open-compare') {
        const rel = primaryRendition(version?.renditions)?.rel || version?.rel;
        if (!rel) return;
        const url = new URL('/compare', window.location.origin);
        if (song?.source?.rel) url.searchParams.set('src', song.source.rel);
        url.searchParams.set('proc', rel);
        window.location.assign(`${url.pathname}${url.search}`);
        return;
      }
      if (action === 'delete-version' && song?.song_id && version?.version_id) {
        await fetch('/api/library/delete_version', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ song_id: song.song_id, version_id: version.version_id }),
        });
        browser.reload();
        return;
      }
      if (action === 'rename-song' && song?.song_id) {
        const next = prompt('Rename song', song.title || '');
        if (!next) return;
        await fetch('/api/library/rename_song', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ song_id: song.song_id, title: next }),
        });
        browser.reload();
        return;
      }
      if (action === 'add-unsorted' && item?.rel) {
        await attachUnsortedOutput(item);
        browser.reload();
        return;
      }
      if (action === 'import-file' && analysisUploadInput) {
        analysisUploadInput.click();
      }
    });
  }

  if (analysisUploadInput) {
    analysisUploadInput.addEventListener('change', async () => {
      const file = (analysisUploadInput.files || [])[0];
      if (!file) return;
      try {
        addStatusLine(`Uploading ${file.name}...`);
        const data = await uploadFile(file);
        if (data.rel) {
          const payload = await resolveFile('source', data.rel);
          await applyData(payload);
          analysisContext.song_id = data.song?.song_id || null;
          updateCompareLinkWithRel(data.rel, null);
          if (libraryBrowser) libraryBrowser.reload();
          updateSelectedFileDisplay(data.song || null, {
            kind: 'source',
            rel: data.rel,
            format: data.rel ? data.rel.split('.').pop() : '',
            metrics: payload?.metrics?.input || null,
          });
          renderNoiseHistory();
        }
        addStatusLine('Upload complete');
      } catch (_err) {
        addStatusLine('Upload failed');
      } finally {
        analysisUploadInput.value = '';
      }
    });
  }

  if (spectrogramImg) {
    spectrogramImg.addEventListener('load', () => {
      const token = spectrogramImg.dataset.loadToken;
      if (!token || token === String(spectroLoadToken)) {
        setSpectrogramLoading(false);
      }
    });
    spectrogramImg.addEventListener('error', () => {
      const token = spectrogramImg.dataset.loadToken;
      if (!token || token === String(spectroLoadToken)) {
        setSpectrogramLoading(false);
      }
    });
  }
  if (spectrogramMiniImg) {
    spectrogramMiniImg.addEventListener('load', () => {
      const token = spectrogramMiniImg.dataset.loadToken;
      if (!token || token === String(spectroMiniLoadToken)) {
        setMiniSpectrogramLoading(false);
      }
    });
    spectrogramMiniImg.addEventListener('error', () => {
      const token = spectrogramMiniImg.dataset.loadToken;
      if (!token || token === String(spectroMiniLoadToken)) {
        setMiniSpectrogramLoading(false);
      }
    });
  }

  loadAnalyzeSpectrogramState(analysisSpectrogram);
  bindAnalyzeSpectrogramControls(analysisSpectrogram);
  bindSpectrogramCursor(analysisSpectrogram);
  renderActiveSpectrogram(false);
  if (analysisFocusProcessedBtn) {
    analysisFocusProcessedBtn.addEventListener('click', () => setActive('processed'));
  }
  if (analysisFocusSourceBtn) {
    analysisFocusSourceBtn.addEventListener('click', () => setActive('source'));
  }
  if (spectrogramViewport) {
    spectrogramViewport.addEventListener('scroll', () => updateMiniWindow());
    spectrogramViewport.addEventListener('wheel', (evt) => {
      if (!analysisSpectrogram.zoomRange) return;
      evt.preventDefault();
      const delta = evt.deltaY;
      const step = delta > 0 ? -1 : 1;
      const next = Math.max(1, Math.min(16, (analysisSpectrogram.zoom || 1) + step));
      analysisSpectrogram.zoom = next;
      analysisSpectrogram.zoomRange.value = String(next);
      if (analysisSpectrogram.zoomVal) analysisSpectrogram.zoomVal.textContent = `${next}x`;
      renderActiveSpectrogram(true);
    }, { passive: false });
  }
  if (spectrogramMiniViewport) {
    let miniDragging = false;
    const onMiniMove = (evt) => {
      if (!spectrogramMiniViewport) return;
      const rect = spectrogramMiniViewport.getBoundingClientRect();
      if (!rect.width) return;
      const ratio = Math.max(0, Math.min(1, (evt.clientX - rect.left) / rect.width));
      scrollMainToRatio(ratio);
      updateMiniWindow();
    };
    const stopMiniDrag = () => {
      if (!miniDragging) return;
      miniDragging = false;
      spectrogramMiniViewport.classList.remove('is-dragging');
      document.removeEventListener('mousemove', onMiniMove);
      document.removeEventListener('mouseup', stopMiniDrag);
    };
    spectrogramMiniViewport.addEventListener('mousedown', (evt) => {
      miniDragging = true;
      spectrogramMiniViewport.classList.add('is-dragging');
      onMiniMove(evt);
      document.addEventListener('mousemove', onMiniMove);
      document.addEventListener('mouseup', stopMiniDrag);
      evt.preventDefault();
    });
    spectrogramMiniViewport.addEventListener('mouseleave', () => {
      stopMiniDrag();
    });
  }
  makeResizeObserver(spectrogramViewport, () => {
    renderActiveSpectrogram(true);
  });
  makeResizeObserver(spectrogramMiniViewport, () => {
    renderMiniSpectrogram();
  });

  if (noiseModeRemoveBtn) {
    noiseModeRemoveBtn.addEventListener('click', () => setNoiseMode('remove'));
  }
  if (noiseModeSoloBtn) {
    noiseModeSoloBtn.addEventListener('click', () => setNoiseMode('solo'));
  }
  if (noiseScopeGlobalBtn) {
    noiseScopeGlobalBtn.addEventListener('click', () => setNoiseScope('global'));
  }
  if (noiseScopeSelectionBtn) {
    noiseScopeSelectionBtn.addEventListener('click', () => setNoiseScope('selection'));
  }
  if (noiseDepthRange) {
    noiseDepthRange.addEventListener('input', () => {
      if (noiseDepthVal) noiseDepthVal.textContent = noiseDepthRange.value;
    });
  }
  if (noiseAfftdnRange) {
    noiseAfftdnRange.addEventListener('input', () => {
      if (noiseAfftdnVal) noiseAfftdnVal.textContent = noiseAfftdnRange.value;
    });
  }
  if (noiseClearBtn) {
    noiseClearBtn.addEventListener('click', () => {
      noiseSelection = null;
      if (spectrogramSelection) spectrogramSelection.hidden = true;
      updateNoiseReadouts(null);
    });
  }
  if (noisePresetSelect) {
    noisePresetSelect.addEventListener('change', () => {
      const id = noisePresetSelect.value;
      if (id) applyNoisePreset(id);
    });
  }
  if (noisePreviewBtn) noisePreviewBtn.addEventListener('click', previewNoise);
  if (noiseRenderBtn) noiseRenderBtn.addEventListener('click', renderNoise);
  if (noiseSaveBtn) noiseSaveBtn.addEventListener('click', saveNoisePreset);
  if (noiseSaveNoiseBtn) noiseSaveNoiseBtn.addEventListener('click', saveNoiseFile);

  if (analysisPlayBtn && analysisAudio) {
    analysisPlayBtn.addEventListener('click', () => {
      if (!analysisAudio.src) return;
      analysisAudio.play().catch(() => {});
    });
  }
  if (analysisPauseBtn && analysisAudio) {
    analysisPauseBtn.addEventListener('click', () => {
      analysisAudio.pause();
    });
  }
  if (analysisStopBtn && analysisAudio) {
    analysisStopBtn.addEventListener('click', () => {
      analysisAudio.pause();
      analysisAudio.currentTime = 0;
      updateScrubber();
      updatePlayhead();
    });
  }
  if (analysisScrubber && analysisAudio) {
    analysisScrubber.addEventListener('input', () => {
      const duration = analysisAudio.duration || analysisContext.duration || 0;
      if (!duration || !Number.isFinite(duration)) return;
      const rel = Math.max(0, Math.min(1, parseFloat(analysisScrubber.value || '0') / 1000));
      analysisAudio.currentTime = rel * duration;
      updateScrubber();
      updatePlayhead();
    });
  }
  if (analysisAudio) {
    analysisAudio.addEventListener('loadedmetadata', () => {
      if (!analysisContext.duration && Number.isFinite(analysisAudio.duration)) {
        analysisContext.duration = analysisAudio.duration;
      }
      updateScrubber();
      updatePlayhead();
    });
    analysisAudio.addEventListener('timeupdate', () => {
      updateScrubber();
      updatePlayhead();
    });
    analysisAudio.addEventListener('ended', () => {
      updateScrubber();
      updatePlayhead();
    });
  }
  bindSpectrogramSelection();
  setNoiseMode('remove');
  setNoiseScope('global');
  updateNoiseButtonState();
  loadNoisePresets();
})();
</script>
{% endblock %}
