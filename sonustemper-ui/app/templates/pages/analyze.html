{% extends "base.html" %}
{% block page_title %}Analyze | SonusTemper{% endblock %}
{% block title %}Analyze{% endblock %}
{% block subtitle %}Inspect spectrograms and diagnostics (read-only).{% endblock %}
{% block sidebar %}
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Analyze Status</div>
        <div class="muted">Selection and analysis activity.</div>
      </div>
    </div>
    <div class="status-list" id="analysisStatusList">(waiting)</div>
  </div>
  <div class="card browse-card">
    <div class="card-head">
      <div>
        <div class="card-title">Browse</div>
        <div class="muted">Pick a source, run output, or import.</div>
      </div>
    </div>
    {% set browser_id = "analysisBrowser" %}
    {% set sections = [
      {"key": "analyze_uploads", "title": "Analyze Uploads", "endpoint": "/partials/library_list?view=analysis_imports&context=analyze"},
      {"key": "mastering_outputs", "title": "Mastering Outputs", "endpoint": "/partials/library_list?view=mastering_outputs&context=analyze"}
    ] %}
    {% include "partials/file_browser.html" %}
  </div>
{% endblock %}
{% block content %}
  <div class="card analyze-card">
    <div class="card-head">
      <div>
        <div class="card-title">Analyze</div>
        <div class="muted" id="analysisSubtitle">Read-only diagnostics</div>
      </div>
      <div class="analyze-actions">
        <a class="btn ghost small" id="compareLink" href="/compare">Open Compare</a>
      </div>
    </div>

    <div id="analysisEmpty" class="analyze-empty">
      <div class="muted">Select a source or output to inspect.</div>
    </div>

    <div id="analysisLoaded" class="analyze-loaded" hidden>
      <div class="metric-pills" id="analysisSummary"></div>

      <div class="analysis-grid">
        <div class="analysis-panel">
          <div class="analysis-panel-head">
            <div class="wave-title">Source</div>
            <div class="wave-meta" id="analysisSourceName">-</div>
          </div>
          <div class="analysis-placeholder">Spectrogram coming soon.</div>
        </div>
        <div class="analysis-panel">
          <div class="analysis-panel-head">
            <div class="wave-title">Processed</div>
            <div class="wave-meta" id="analysisProcessedName">-</div>
          </div>
          <div class="analysis-placeholder">Spectrogram coming soon.</div>
        </div>
      </div>

      <div class="compare-grid" id="analysisMetricsGrid"></div>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script>
(() => {
  const statusList = document.getElementById('analysisStatusList');
  const emptyState = document.getElementById('analysisEmpty');
  const loadedState = document.getElementById('analysisLoaded');
  const summaryPills = document.getElementById('analysisSummary');
  const metricsGrid = document.getElementById('analysisMetricsGrid');
  const sourceName = document.getElementById('analysisSourceName');
  const processedName = document.getElementById('analysisProcessedName');
  const analyzeBrowser = document.getElementById('analysisBrowser');
  const compareLink = document.getElementById('compareLink');
  let statusLines = [];

  const metricLabels = [
    { key: 'I', label: 'LUFS-I', suffix: ' LUFS' },
    { key: 'TP', label: 'True Peak', suffix: ' dBTP' },
    { key: 'LRA', label: 'LRA', suffix: ' LU' },
    { key: 'rms_level', label: 'RMS', suffix: ' dB' },
    { key: 'crest_factor', label: 'Crest', suffix: ' dB' },
    { key: 'dynamic_range', label: 'DR', suffix: ' dB' },
  ];

  function fmt(num, decimals){
    if (num === null || num === undefined || Number.isNaN(num)) return '-';
    const fixed = (typeof decimals === 'number') ? num.toFixed(decimals) : num.toFixed(1);
    return fixed.replace(/\.0$/, '');
  }

  function formatDelta(outVal, inVal){
    if (typeof outVal !== 'number' || typeof inVal !== 'number') return '';
    const delta = outVal - inVal;
    const sign = delta > 0 ? '+' : '';
    return ` (${sign}${fmt(delta, 1)})`;
  }

  function renderStatus(){
    if (!statusList) return;
    statusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
    statusList.scrollTop = statusList.scrollHeight;
  }

  function addStatusLine(message){
    if (!message) return;
    const ts = new Date().toLocaleTimeString();
    statusLines.push(`${ts} ${message}`);
    if (statusLines.length > 200) statusLines = statusLines.slice(-200);
    renderStatus();
  }

  function renderPills(input, output){
    if (!summaryPills) return;
    summaryPills.innerHTML = '';
    metricLabels.forEach(meta => {
      const outVal = output ? output[meta.key] : null;
      if (outVal === null || outVal === undefined) return;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      const delta = formatDelta(outVal, input ? input[meta.key] : null);
      pill.textContent = `${meta.label}: ${fmt(outVal, 1)}${meta.suffix}${delta}`;
      summaryPills.appendChild(pill);
    });
  }

  function renderMetrics(input, output){
    if (!metricsGrid) return;
    metricsGrid.innerHTML = '';
    const headers = ['Metric', 'Source', 'Processed', 'Delta'];
    headers.forEach(label => {
      const cell = document.createElement('div');
      cell.className = 'compare-cell compare-head';
      cell.textContent = label;
      metricsGrid.appendChild(cell);
    });
    metricLabels.forEach(meta => {
      const inVal = input ? input[meta.key] : null;
      const outVal = output ? output[meta.key] : null;
      const row = [
        meta.label,
        inVal === null || inVal === undefined ? '-' : `${fmt(inVal, 1)}${meta.suffix}`,
        outVal === null || outVal === undefined ? '-' : `${fmt(outVal, 1)}${meta.suffix}`,
        formatDelta(outVal, inVal).replace(/[()]/g, '') || '-',
      ];
      row.forEach((val) => {
        const cell = document.createElement('div');
        cell.className = 'compare-cell';
        cell.textContent = val;
        metricsGrid.appendChild(cell);
      });
    });
  }

  function syncPreserveLinks(params){
    const search = params.toString();
    document.querySelectorAll('a[data-preserve-query="true"]').forEach((link) => {
      const href = link.getAttribute('href');
      if (!href) return;
      try {
        const url = new URL(href, window.location.origin);
        url.search = search;
        link.setAttribute('href', `${url.pathname}${url.search}`);
      } catch (_err) {
        return;
      }
    });
  }

  function updateUrl(params){
    const next = new URL(window.location.href);
    next.search = params.toString();
    window.history.pushState({}, '', next.toString());
    if (compareLink) {
      compareLink.href = `/compare${next.search}`;
    }
    syncPreserveLinks(params);
  }

  async function resolveRun(song, out, solo){
    const params = new URLSearchParams();
    params.set('song', song);
    if (out) params.set('out', out);
    if (solo) params.set('solo', '1');
    const res = await fetch(`/api/analyze-resolve?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function resolveFile(kind, rel){
    const params = new URLSearchParams();
    if (kind === 'source') {
      params.set('src', rel);
    } else if (kind === 'import') {
      params.set('imp', rel);
    }
    const res = await fetch(`/api/analyze-resolve-file?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function applyData(payload){
    if (!payload) return;
    const input = payload.metrics?.input || null;
    const output = payload.metrics?.output || null;
    if (sourceName) sourceName.textContent = payload.source_name || 'Source';
    if (processedName) processedName.textContent = payload.processed_name || '-';
    if (emptyState) emptyState.hidden = true;
    if (loadedState) loadedState.hidden = false;
    renderPills(input, output);
    renderMetrics(input, output);
  }

  async function selectAndLoad(item, node, shouldPush){
    if (!item) return;
    if (node && analyzeBrowser) {
      analyzeBrowser.querySelectorAll('.browser-item.active').forEach(el => el.classList.remove('active'));
      node.classList.add('active');
    }
    try {
      if (item.kind === 'mastering_output') {
        addStatusLine(`Loading run ${item.song}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (item.out) params.set('out', item.out);
        if (item.solo) params.set('solo', '1');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', item.solo);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'mastering_run') {
        addStatusLine(`Loading run ${item.song || item.id}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', false);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'source' || item.kind === 'import') {
        addStatusLine(`Loading ${item.kind}...`);
        const params = new URLSearchParams();
        params.set(item.kind === 'source' ? 'src' : 'imp', item.rel);
        if (shouldPush) updateUrl(params);
        const data = await resolveFile(item.kind, item.rel);
        await applyData(data);
        addStatusLine('Analysis ready');
      }
    } catch (_err) {
      if (typeof showToast === 'function') showToast('Analyze data unavailable');
      addStatusLine('Analysis failed');
    }
  }

  if (compareLink && window.location.search) {
    compareLink.href = `/compare${window.location.search}`;
  }

  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  const out = params.get('out');
  const solo = params.get('solo');
  const src = params.get('src');
  const imp = params.get('imp');
  if (song) {
    selectAndLoad(
      out
        ? { kind: 'mastering_output', id: `${song}::${out}`, song, out, solo: solo === '1' || solo === 'true' }
        : { kind: 'mastering_run', id: song, song },
      null,
      false
    );
  } else if (src) {
    selectAndLoad({ kind: 'source', rel: src }, null, false);
  } else if (imp) {
    selectAndLoad({ kind: 'import', rel: imp }, null, false);
  }

  if (analyzeBrowser) {
    analyzeBrowser.addEventListener('click', (evt) => {
      const itemNode = evt.target.closest('.browser-item');
      if (!itemNode || itemNode.disabled) return;
      const kind = itemNode.dataset.kind || '';
      const id = itemNode.dataset.id || '';
      let meta = {};
      if (itemNode.dataset.meta) {
        try {
          meta = JSON.parse(itemNode.dataset.meta || '{}');
        } catch (_err) {
          meta = {};
        }
      }
      if (kind === 'mastering_output') {
        const song = meta.song || '';
        if (!song) return;
        evt.preventDefault();
        evt.stopPropagation();
        const item = { kind, id, song, out: meta.out || '', solo: Boolean(meta.solo) };
        selectAndLoad(item, itemNode, true);
        return;
      }
      if (kind === 'import') {
        const rel = meta.rel || id;
        if (!rel) return;
        evt.preventDefault();
        evt.stopPropagation();
        const item = { kind, id, rel };
        selectAndLoad(item, itemNode, true);
        return;
      }
      if (kind !== 'mastering_run') return;
      evt.preventDefault();
      evt.stopPropagation();
      const item = { kind, id, song: id };
      selectAndLoad(item, itemNode, true);
    });
  }
})();
</script>
{% endblock %}
