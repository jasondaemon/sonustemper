{% extends "base.html" %}
{% block page_title %}Analyze | SonusTemper{% endblock %}
{% block title %}Analyze{% endblock %}
{% block subtitle %}Compare source vs processed audio (metrics + waveform).{% endblock %}
{% block sidebar %}
  <div class="card browse-card">
    <div class="card-head">
      <div>
        <div class="card-title">Browse</div>
        <div class="muted">Pick a source, run output, or import.</div>
      </div>
    </div>
    {% set browser_id = "analyzeBrowser" %}
    {% set sections = [
      {"key": "mastering_runs", "title": "Mastering Runs", "endpoint": "/partials/library_list?view=mastering_runs&context=analyze"},
      {"key": "tagging_mp3", "title": "Tagging MP3 Library", "endpoint": "/partials/library_list?view=tagging_mp3&context=analyze"}
    ] %}
    {% include "partials/file_browser.html" %}
  </div>
{% endblock %}
{% block content %}
  <div class="card analyze-card">
    <div class="card-head">
      <div>
        <div class="card-title">Compare</div>
        <div class="muted" id="analyzeSubtitle">Source vs Processed</div>
      </div>
      <div class="analyze-actions">
        <input type="file" id="analyzeUploadInput" accept=".wav,.mp3,.flac,.aiff,.aif,.m4a,.ogg,.aac" hidden>
        <button class="btn ghost small" id="analyzeUploadBtn">Upload</button>
      </div>
    </div>

    <div id="analyzeEmpty" class="analyze-empty">
      <div class="muted">Upload a source file to analyze or launch Analyze from a mastering output.</div>
    </div>

    <div id="analyzeLoaded" class="analyze-loaded" hidden>
      <div class="metric-pills" id="summaryPills"></div>

      <div class="wave-panel" id="sourcePanel">
        <div class="wave-head">
          <div class="wave-title">Source</div>
          <div class="wave-head-actions">
            <button class="btn ghost tiny" id="soloSourceBtn" type="button">Solo</button>
            <div class="wave-meta" id="sourceName">-</div>
          </div>
        </div>
        <div class="wave-canvas" id="waveSource"></div>
      </div>

      <div class="wave-panel" id="processedPanel">
        <div class="wave-head">
          <div class="wave-title">Processed</div>
          <div class="wave-head-actions">
            <button class="btn ghost tiny" id="soloProcessedBtn" type="button">Solo</button>
            <div class="wave-meta" id="processedName">-</div>
          </div>
        </div>
        <div class="wave-canvas" id="waveProcessed"></div>
        <div class="wave-empty muted" id="processedEmpty" hidden>No processed file selected.</div>
      </div>

      <div class="analyze-controls">
        <button class="btn ghost small" id="playBtn">Play</button>
        <button class="btn ghost small" id="pauseBtn">Pause</button>
        <button class="btn ghost small" id="stopBtn">Stop</button>
        <div class="playback-modes">
          <button class="btn ghost small is-active" data-playback-mode="compare" id="modeCompareBtn" type="button">Compare</button>
          <button class="btn ghost small" data-playback-mode="source" id="modeSourceBtn" type="button">Source</button>
          <button class="btn ghost small" data-playback-mode="processed" id="modeProcessedBtn" type="button">Processed</button>
          <span class="link-indicator" id="linkIndicator">Linked</span>
        </div>
        <div class="zoom-control">
          <span>Zoom</span>
          <span class="zoom-label" id="zoomLabel">1x</span>
          <input type="range" id="zoomRange" min="0" max="3" value="0" step="1">
        </div>
        <div class="analyze-toggles">
          <label class="analyze-toggle is-active">
            <input type="checkbox" id="togglePeakRisk" checked>
            <span>Peak Risk</span>
          </label>
          <label class="analyze-toggle is-active">
            <input type="checkbox" id="toggleHeatmap" checked>
            <span>Loudness Heatmap</span>
          </label>
          <label class="analyze-toggle">
            <input type="checkbox" id="toggleDelta">
            <span>Δ Loudness</span>
          </label>
        </div>
      </div>

      <div class="compare-grid" id="compareGrid"></div>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script src="/ui/static/vendor/wavesurfer.min.js"></script>
<script>
(() => {
  const uploadBtn = document.getElementById('analyzeUploadBtn');
  const uploadInput = document.getElementById('analyzeUploadInput');
  const emptyState = document.getElementById('analyzeEmpty');
  const loadedState = document.getElementById('analyzeLoaded');
  const summaryPills = document.getElementById('summaryPills');
  const compareGrid = document.getElementById('compareGrid');
  const sourceName = document.getElementById('sourceName');
  const processedName = document.getElementById('processedName');
  const processedEmpty = document.getElementById('processedEmpty');
  const analyzeSubtitle = document.getElementById('analyzeSubtitle');

  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stopBtn = document.getElementById('stopBtn');
  const zoomRange = document.getElementById('zoomRange');
  const zoomLabel = document.getElementById('zoomLabel');
  const linkIndicator = document.getElementById('linkIndicator');
  const soloSourceBtn = document.getElementById('soloSourceBtn');
  const soloProcessedBtn = document.getElementById('soloProcessedBtn');
  const modeButtons = Array.from(document.querySelectorAll('[data-playback-mode]'));
  const togglePeakRisk = document.getElementById('togglePeakRisk');
  const toggleHeatmap = document.getElementById('toggleHeatmap');
  const toggleDelta = document.getElementById('toggleDelta');

  let sourceWave = null;
  let processedWave = null;
  let selectedItem = null;
  let analysisData = null;
  let overlayCleanup = [];
  let transportCleanup = [];
  let playbackMode = 'compare';
  let transportLock = false;
  let zoomRaf = null;
  let pendingZoom = null;
  const analyzeBrowser = document.getElementById('analyzeBrowser');

  const zoomSteps = [1, 2, 4, 8];
  let fitMinPxPerSec = 1;

  const metricLabels = [
    { key: 'I', label: 'LUFS-I', suffix: ' LUFS' },
    { key: 'TP', label: 'True Peak', suffix: ' dBTP' },
    { key: 'LRA', label: 'LRA', suffix: ' LU' },
    { key: 'rms_level', label: 'RMS', suffix: ' dB' },
    { key: 'crest_factor', label: 'Crest', suffix: ' dB' },
    { key: 'dynamic_range', label: 'DR', suffix: ' dB' },
  ];

  function fmt(num, decimals){
    if (num === null || num === undefined || Number.isNaN(num)) return '-';
    const fixed = (typeof decimals === 'number') ? num.toFixed(decimals) : num.toFixed(1);
    return fixed.replace(/\.0$/, '');
  }

  function formatDelta(outVal, inVal){
    if (typeof outVal !== 'number' || typeof inVal !== 'number') return '';
    const delta = outVal - inVal;
    const sign = delta > 0 ? '+' : '';
    return ` (${sign}${fmt(delta, 1)})`;
  }

  function displayMetric(value, suffix){
    if (value === null || value === undefined || Number.isNaN(value)) return '-';
    return `${fmt(value, 1)}${suffix}`;
  }

  function currentZoomIndex(){
    if (!zoomRange) return 0;
    const raw = parseInt(zoomRange.value || '0', 10);
    if (Number.isNaN(raw)) return 0;
    return Math.max(0, Math.min(zoomSteps.length - 1, raw));
  }

  function setZoomLevel(level){
    const idx = Math.max(0, Math.min(zoomSteps.length - 1, level));
    const factor = zoomSteps[idx];
    if (zoomLabel) zoomLabel.textContent = `${factor}x`;
    const minPxPerSec = Math.max(1, fitMinPxPerSec) * factor;
    if (sourceWave) sourceWave.zoom(minPxPerSec);
    if (processedWave) processedWave.zoom(minPxPerSec);
  }

  function clamp(val, minVal, maxVal){
    return Math.max(minVal, Math.min(maxVal, val));
  }

  function fitPxPerSecFor(wave){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const duration = wave.getDuration();
    if (!duration || duration <= 0) return null;
    const wrapper = wave.getWrapper();
    const scrollEl = wrapper ? wrapper.parentElement : null;
    const width = scrollEl?.clientWidth || wrapper?.clientWidth || 0;
    if (!width) return null;
    const fit = width / duration;
    return clamp(fit, 1, 200);
  }

  function updateFitBaseline(){
    const fits = [];
    const sourceFit = fitPxPerSecFor(sourceWave);
    if (sourceFit) fits.push(sourceFit);
    const processedFit = fitPxPerSecFor(processedWave);
    if (processedFit) fits.push(processedFit);
    if (!fits.length) return;
    const next = Math.min(...fits);
    if (Math.abs(next - fitMinPxPerSec) < 0.01) return;
    fitMinPxPerSec = next;
    setZoomLevel(currentZoomIndex());
  }

  function debugOverflow(label) {
    const doc = document.documentElement;
    const body = document.body;
    const overflow = Math.max(doc.scrollWidth, body.scrollWidth) - doc.clientWidth;
    if (overflow <= 1) return;
    console.warn(`[overflow] ${label}: +${overflow}px`);

    let worst = null;
    let worstRight = 0;
    const vw = doc.clientWidth;

    for (const el of document.querySelectorAll("*")) {
      const r = el.getBoundingClientRect();
      if (r.right > worstRight + 1) {
        worstRight = r.right;
        worst = el;
      }
    }

    if (worst) {
      console.warn("[overflow] culprit:", worst, worstRight, "vw:", vw);
      worst.style.outline = "3px solid red";
    }
  }

  function cleanupTransport(){
    transportCleanup.forEach((fn) => {
      try {
        fn();
      } catch (_err) {
        // ignore cleanup errors
      }
    });
    transportCleanup = [];
  }

  function isAnyPlaying(){
    const srcPlaying = sourceWave && sourceWave.isPlaying && sourceWave.isPlaying();
    const procPlaying = processedWave && processedWave.isPlaying && processedWave.isPlaying();
    return Boolean(srcPlaying || procPlaying);
  }

  function getMasterWave(){
    if (playbackMode === 'processed') return processedWave || sourceWave;
    return sourceWave || processedWave;
  }

  function getSlaveWave(){
    if (playbackMode !== 'compare') return null;
    const master = getMasterWave();
    if (!master || !sourceWave || !processedWave) return null;
    return master === sourceWave ? processedWave : sourceWave;
  }

  function seekBoth(time){
    if (transportLock) return;
    transportLock = true;
    if (sourceWave) sourceWave.setTime(time);
    if (processedWave) processedWave.setTime(time);
    transportLock = false;
  }

  function syncSlave(time){
    const slave = getSlaveWave();
    if (!slave) return;
    const drift = Math.abs(slave.getCurrentTime() - time);
    if (drift > 0.015) {
      slave.setTime(time);
    }
  }

  function playTransport(){
    const master = getMasterWave();
    if (!master) return;
    const time = master.getCurrentTime();
    seekBoth(time);
    if (playbackMode === 'compare') {
      if (sourceWave) sourceWave.play();
      if (processedWave) processedWave.play();
    } else {
      master.play();
      const other = master === sourceWave ? processedWave : sourceWave;
      if (other) other.pause();
    }
  }

  function pauseTransport(){
    if (sourceWave) sourceWave.pause();
    if (processedWave) processedWave.pause();
  }

  function stopTransport(){
    if (sourceWave) sourceWave.stop();
    if (processedWave) processedWave.stop();
  }

  function updatePlaybackModeUI(){
    modeButtons.forEach((btn) => {
      const mode = btn.dataset.playbackMode;
      const disabled = (mode === 'processed' && !processedWave) || (mode === 'compare' && !processedWave);
      btn.disabled = disabled;
      btn.classList.toggle('is-active', mode === playbackMode);
    });
    if (linkIndicator) {
      linkIndicator.classList.toggle('hidden', playbackMode !== 'compare' || !processedWave);
    }
    if (soloSourceBtn) soloSourceBtn.classList.toggle('is-active', playbackMode === 'source');
    if (soloProcessedBtn) {
      soloProcessedBtn.disabled = !processedWave;
      soloProcessedBtn.classList.toggle('is-active', playbackMode === 'processed');
    }
  }

  function setPlaybackMode(nextMode){
    if (nextMode === 'processed' && !processedWave) nextMode = 'source';
    if (nextMode === 'compare' && !processedWave) nextMode = 'source';
    if (nextMode === playbackMode) return;
    const wasPlaying = isAnyPlaying();
    playbackMode = nextMode;
    updatePlaybackModeUI();
    pauseTransport();
    if (wasPlaying) playTransport();
  }

  function bindTransportEvents(wave){
    if (!wave) return;
    transportCleanup.push(
      wave.on('interaction', (time) => {
        if (transportLock) return;
        seekBoth(time);
      })
    );
    transportCleanup.push(
      wave.on('audioprocess', (time) => {
        const master = getMasterWave();
        if (wave !== master) return;
        if (playbackMode === 'compare') {
          syncSlave(time);
        }
      })
    );
    transportCleanup.push(
      wave.on('finish', () => {
        pauseTransport();
      })
    );
  }

  function syncToggleStyles(){
    [togglePeakRisk, toggleHeatmap, toggleDelta].forEach((el) => {
      if (!el) return;
      const label = el.closest('.analyze-toggle');
      if (label) label.classList.toggle('is-active', el.checked);
    });
  }

  function overlayState(){
    return {
      peak: togglePeakRisk ? togglePeakRisk.checked : true,
      heatmap: toggleHeatmap ? toggleHeatmap.checked : true,
      delta: toggleDelta ? toggleDelta.checked : false,
    };
  }

  function cleanupOverlays(){
    overlayCleanup.forEach((fn) => {
      try {
        fn();
      } catch (_err) {
        // ignore cleanup errors
      }
    });
    overlayCleanup = [];
  }

  function percentile(values, p){
    if (!values.length) return null;
    const sorted = [...values].sort((a, b) => a - b);
    const idx = Math.max(0, Math.min(sorted.length - 1, Math.floor((sorted.length - 1) * p)));
    return sorted[idx];
  }

  function ensureOverlayCanvas(wave, kind){
    if (!wave || typeof wave.getWrapper !== 'function') return null;
    const wrapper = wave.getWrapper();
    if (!wrapper) return null;
    const scrollEl = wrapper.parentElement || wrapper;
    let canvas = scrollEl.querySelector(`canvas.analysis-overlay-${kind}`);
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.className = `analysis-overlay analysis-overlay-${kind}`;
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = '3';
      scrollEl.appendChild(canvas);
    }
    const width = Math.max(scrollEl.clientWidth || 0, 1);
    const height = Math.max(scrollEl.clientHeight || wrapper.clientHeight || 1, 1);
    const fullWidth = Math.max(wrapper.scrollWidth || wrapper.clientWidth || width, width);
    const scrollLeft = scrollEl.scrollLeft || 0;
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(width * ratio));
    canvas.height = Math.max(1, Math.round(height * ratio));
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return { canvas, ctx, wrapper, scrollEl, width, height, fullWidth, scrollLeft };
  }

  function drawHeatmap(ctx, width, height, t, values, duration, fullWidth, scrollLeft){
    if (!t.length || !values.length || !duration || !fullWidth) return;
    const clean = values.filter((v) => typeof v === 'number' && !Number.isNaN(v));
    if (clean.length < 2) return;
    const minVal = percentile(clean, 0.1);
    const maxVal = percentile(clean, 0.9);
    if (minVal === null || maxVal === null || maxVal <= minVal) return;
    const low = [24, 48, 76];
    const high = [255, 138, 61];
    const step = fullWidth / values.length;
    for (let i = 0; i < values.length; i += 1) {
      const val = values[i];
      if (typeof val !== 'number' || Number.isNaN(val)) continue;
      const norm = Math.max(0, Math.min(1, (val - minVal) / (maxVal - minVal)));
      const r = Math.round(low[0] + (high[0] - low[0]) * norm);
      const g = Math.round(low[1] + (high[1] - low[1]) * norm);
      const b = Math.round(low[2] + (high[2] - low[2]) * norm);
      const alpha = 0.08 + norm * 0.32;
      const x = (t[i] / duration) * fullWidth - scrollLeft;
      if (x < -step || x > width + step) continue;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      ctx.fillRect(x - step * 0.5, 0, step, height);
    }
  }

  function drawDelta(ctx, width, height, t, values, duration, fullWidth, scrollLeft){
    if (!t.length || !values.length || !duration || !fullWidth) return;
    const clean = values.filter((v) => typeof v === 'number' && !Number.isNaN(v));
    if (!clean.length) return;
    const absVals = clean.map((v) => Math.abs(v));
    let maxAbs = percentile(absVals, 0.9) || Math.max(...absVals);
    if (!maxAbs || maxAbs < 0.1) maxAbs = 0.1;
    const mid = height * 0.5;
    const scale = (height * 0.35) / maxAbs;
    ctx.save();
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.beginPath();
    ctx.moveTo(0, mid);
    ctx.lineTo(width, mid);
    ctx.stroke();
    const drawSign = (sign, color) => {
      ctx.strokeStyle = color;
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < values.length; i += 1) {
        const val = values[i];
        if (typeof val !== 'number' || Number.isNaN(val) || val * sign <= 0) {
          started = false;
          continue;
        }
        const x = (t[i] / duration) * fullWidth - scrollLeft;
        if (x < -2 || x > width + 2) {
          started = false;
          continue;
        }
        const y = mid - (val * scale);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    };
    drawSign(1, 'rgba(60, 214, 186, 0.9)');
    drawSign(-1, 'rgba(255, 96, 96, 0.9)');
    ctx.restore();
  }

  function drawMarkers(ctx, width, height, duration, markers, fullWidth, scrollLeft){
    if (!duration || !markers || !markers.length || !fullWidth) return;
    ctx.save();
    markers.forEach((marker) => {
      if (!marker || typeof marker.t !== 'number') return;
      const x = (marker.t / duration) * fullWidth - scrollLeft;
      if (x < 0 || x > width) return;
      const isClip = marker.severity === 'clip';
      ctx.strokeStyle = isClip ? 'rgba(255, 88, 88, 0.85)' : 'rgba(255, 184, 77, 0.45)';
      ctx.lineWidth = isClip ? 1.4 : 1.0;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    });
    ctx.restore();
  }

  function nearestIndex(arr, t){
    if (!arr || !arr.length) return -1;
    let lo = 0;
    let hi = arr.length - 1;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const val = arr[mid];
      if (val === t) return mid;
      if (val < t) lo = mid + 1;
      else hi = mid - 1;
    }
    const idx = Math.max(0, Math.min(arr.length - 1, lo));
    if (idx > 0 && Math.abs(arr[idx - 1] - t) < Math.abs(arr[idx] - t)) {
      return idx - 1;
    }
    return idx;
  }

  function nearestMarker(markers, t, window){
    if (!markers || !markers.length) return null;
    let lo = 0;
    let hi = markers.length - 1;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const val = markers[mid].t;
      if (val === t) return markers[mid];
      if (val < t) lo = mid + 1;
      else hi = mid - 1;
    }
    const idx = Math.max(0, Math.min(markers.length - 1, lo));
    const candidates = [markers[idx], markers[idx - 1]].filter(Boolean);
    let best = null;
    let bestDist = window;
    candidates.forEach((m) => {
      const dist = Math.abs(m.t - t);
      if (dist <= bestDist) {
        best = m;
        bestDist = dist;
      }
    });
    return best;
  }

  function updateTooltip(evt, kind, scrollEl, wrapper){
    if (!analysisData || !analysisData.series || !scrollEl || !wrapper) return;
    const rect = scrollEl.getBoundingClientRect();
    if (!rect.width) return;
    const duration = analysisData.duration_s || (kind === 'source' ? sourceWave?.getDuration() : processedWave?.getDuration());
    if (!duration) return;
    const x = evt.clientX - rect.left;
    const fullWidth = Math.max(wrapper.scrollWidth || rect.width, rect.width);
    const scrollLeft = scrollEl.scrollLeft || 0;
    const t = Math.max(0, Math.min(duration, ((x + scrollLeft) / fullWidth) * duration));
    const seriesT = analysisData.series.t || [];
    const idx = nearestIndex(seriesT, t);
    const state = overlayState();
    const lines = [];
    if (state.heatmap && idx >= 0) {
      const sVal = analysisData.series.lufs_st_source?.[idx];
      const pVal = analysisData.series.lufs_st_processed?.[idx];
      if (typeof sVal === 'number') lines.push(`Source ST: ${fmt(sVal, 1)} LUFS`);
      if (typeof pVal === 'number') lines.push(`Processed ST: ${fmt(pVal, 1)} LUFS`);
    }
    if (state.delta && kind === 'processed' && idx >= 0) {
      const dVal = analysisData.series.lufs_st_delta?.[idx];
      if (typeof dVal === 'number') lines.push(`Δ Loudness: ${fmt(dVal, 1)} LU`);
    }
    if (state.peak) {
      const markerList = analysisData.markers?.true_peak?.[kind === 'processed' ? 'processed' : 'source'] || [];
      const marker = nearestMarker(markerList, t, 0.15);
      if (marker) {
        const label = kind === 'processed' ? 'Processed' : 'Source';
        lines.push(`True Peak (${label}): ${fmt(marker.value, 1)} dBTP`);
      }
    }
    wrapper.title = lines.join('\n');
  }

  function drawOverlay(wave, kind){
    if (!wave) return;
    const overlay = ensureOverlayCanvas(wave, kind);
    if (!overlay) return;
    const { ctx, width, height, fullWidth, scrollLeft } = overlay;
    ctx.clearRect(0, 0, width, height);
    if (!analysisData || !analysisData.series) return;
    const duration = analysisData.duration_s || wave.getDuration() || 0;
    if (!duration) return;
    const state = overlayState();
    const t = analysisData.series.t || [];
    if (!t.length) return;
    const sourceVals = analysisData.series.lufs_st_source || [];
    const processedVals = analysisData.series.lufs_st_processed || [];
    const deltaVals = analysisData.series.lufs_st_delta || [];
    if (state.heatmap) {
      const values = (kind === 'processed' && processedVals.length) ? processedVals : sourceVals;
      drawHeatmap(ctx, width, height, t, values, duration, fullWidth, scrollLeft);
    }
    if (state.delta && kind === 'processed' && deltaVals.length) {
      drawDelta(ctx, width, height, t, deltaVals, duration, fullWidth, scrollLeft);
    }
    if (state.peak) {
      const markerList = analysisData.markers?.true_peak?.[kind === 'processed' ? 'processed' : 'source'] || [];
      drawMarkers(ctx, width, height, duration, markerList, fullWidth, scrollLeft);
    }
  }

  function drawOverlays(){
    drawOverlay(sourceWave, 'source');
    drawOverlay(processedWave, 'processed');
  }

  function bindOverlayEvents(wave, kind){
    if (!wave) return () => {};
    const cleanup = [];
    const draw = () => drawOverlay(wave, kind);
    cleanup.push(wave.on('ready', draw));
    cleanup.push(wave.on('redraw', draw));
    cleanup.push(wave.on('zoom', draw));
    cleanup.push(wave.on('scroll', draw));
    cleanup.push(wave.on('resize', draw));
    const onResize = () => drawOverlay(wave, kind);
    window.addEventListener('resize', onResize);
    cleanup.push(() => window.removeEventListener('resize', onResize));
    const wrapper = typeof wave.getWrapper === 'function' ? wave.getWrapper() : null;
    const scrollEl = wrapper ? wrapper.parentElement : null;
    if (scrollEl && wrapper) {
      const onMove = (evt) => updateTooltip(evt, kind, scrollEl, wrapper);
      const onLeave = () => { scrollEl.title = ''; };
      scrollEl.addEventListener('mousemove', onMove);
      scrollEl.addEventListener('mouseleave', onLeave);
      cleanup.push(() => {
        scrollEl.removeEventListener('mousemove', onMove);
        scrollEl.removeEventListener('mouseleave', onLeave);
      });
      const onScroll = () => drawOverlay(wave, kind);
      scrollEl.addEventListener('scroll', onScroll, { passive: true });
      cleanup.push(() => scrollEl.removeEventListener('scroll', onScroll));
    }
    return () => cleanup.forEach((fn) => fn && fn());
  }

  function setupOverlays(){
    cleanupOverlays();
    if (sourceWave) overlayCleanup.push(bindOverlayEvents(sourceWave, 'source'));
    if (processedWave) overlayCleanup.push(bindOverlayEvents(processedWave, 'processed'));
    drawOverlays();
  }

  function clearWaves(){
    cleanupOverlays();
    cleanupTransport();
    if (sourceWave) {
      sourceWave.destroy();
      sourceWave = null;
    }
    if (processedWave) {
      processedWave.destroy();
      processedWave = null;
    }
  }

  function initWave(containerId){
    const el = document.getElementById(containerId);
    if (!el || !window.WaveSurfer) return null;
    const zoomIdx = currentZoomIndex();
    return WaveSurfer.create({
      container: el,
      waveColor: '#2a3a4f',
      progressColor: '#ff8a3d',
      cursorColor: '#ffc38a',
      height: 180,
      barWidth: 2,
      barGap: 1,
      normalize: true,
      backend: 'MediaElement',
      minPxPerSec: Math.max(1, fitMinPxPerSec) * zoomSteps[zoomIdx],
      fillParent: false,
      autoScroll: false,
      autoCenter: false,
    });
  }

  async function loadWave(wave, url){
    if (!wave || !url) return;
    return new Promise((resolve) => {
      const done = () => resolve();
      wave.once('ready', done);
      wave.once('error', () => {
        done();
        if (typeof showToast === 'function') {
          showToast('Waveform failed to load');
        }
      });
      wave.load(url);
    });
  }

  function renderPills(input, output){
    if (!summaryPills) return;
    summaryPills.innerHTML = '';
    metricLabels.forEach(meta => {
      const outVal = output ? output[meta.key] : null;
      if (outVal === null || outVal === undefined) return;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      const delta = formatDelta(outVal, input ? input[meta.key] : null);
      pill.textContent = `${meta.label}: ${fmt(outVal, 1)}${meta.suffix}${delta}`;
      summaryPills.appendChild(pill);
    });
  }

  function renderCompare(input, output){
    if (!compareGrid) return;
    compareGrid.innerHTML = '';
    const headers = ['Metric', 'Source', 'Processed', 'Delta'];
    headers.forEach(label => {
      const cell = document.createElement('div');
      cell.className = 'compare-cell compare-head';
      cell.textContent = label;
      compareGrid.appendChild(cell);
    });
    metricLabels.forEach(meta => {
      const inVal = input ? input[meta.key] : null;
      const outVal = output ? output[meta.key] : null;
      const row = [
        meta.label,
        displayMetric(inVal, meta.suffix),
        displayMetric(outVal, meta.suffix),
        formatDelta(outVal, inVal).replace(/[()]/g, '') || '-',
      ];
      row.forEach((value, idx) => {
        const cell = document.createElement('div');
        cell.className = idx === 0 ? 'compare-cell compare-metric' : 'compare-cell';
        cell.textContent = value;
        compareGrid.appendChild(cell);
      });
    });
  }

  function updateUrl(params){
    const next = new URL(window.location.href);
    next.search = params.toString();
    window.history.pushState({}, '', next.toString());
  }

  function updateControls(){
    const hasSource = sourceWave !== null;
    const hasProcessed = processedWave !== null;
    const processedCanvas = document.getElementById('waveProcessed');
    if (processedCanvas) processedCanvas.style.display = hasProcessed ? '' : 'none';
    if (playBtn) playBtn.disabled = !hasSource;
    if (pauseBtn) pauseBtn.disabled = !hasSource;
    if (stopBtn) stopBtn.disabled = !hasSource;
    if (zoomRange) zoomRange.disabled = !hasSource;
    if (processedEmpty) processedEmpty.hidden = hasProcessed;
  }

  async function applyData(payload){
    if (!payload) return;
    const input = payload.metrics?.input || null;
    const output = payload.metrics?.output || null;
    const durationFallback = payload.duration_s ?? output?.duration_sec ?? input?.duration_sec ?? null;
    analysisData = {
      duration_s: durationFallback,
      series: payload.series || null,
      markers: payload.markers || null,
    };

    if (analyzeSubtitle) {
      const name = payload.run_id ? `Run ${payload.run_id}` : 'Standalone analysis';
      analyzeSubtitle.textContent = name;
    }
    if (sourceName) sourceName.textContent = payload.source_name || 'Source';
    if (processedName) processedName.textContent = payload.processed_name || '-';

    if (emptyState) emptyState.hidden = true;
    if (loadedState) loadedState.hidden = false;

    renderPills(input, output);
    renderCompare(input, output);

    clearWaves();
    sourceWave = initWave('waveSource');
    processedWave = payload.processed_url ? initWave('waveProcessed') : null;

    await loadWave(sourceWave, payload.source_url);
    if (processedWave) {
      await loadWave(processedWave, payload.processed_url);
    }
    updateFitBaseline();
    playbackMode = processedWave ? 'compare' : 'source';
    updatePlaybackModeUI();
    cleanupTransport();
    bindTransportEvents(sourceWave);
    bindTransportEvents(processedWave);
    updateControls();
    setupOverlays();
  }

  async function resolveRun(song, out){
    const params = new URLSearchParams();
    params.set('song', song);
    if (out) params.set('out', out);
    const res = await fetch(`/api/analyze-resolve?${params.toString()}`);
    if (!res.ok) {
      throw new Error('resolve_failed');
    }
    return res.json();
  }

  async function resolveFile(kind, rel){
    const params = new URLSearchParams();
    if (kind === 'source') {
      params.set('src', rel);
    } else if (kind === 'import') {
      params.set('imp', rel);
    }
    const res = await fetch(`/api/analyze-resolve-file?${params.toString()}`);
    if (!res.ok) {
      throw new Error('resolve_failed');
    }
    return res.json();
  }

  function setActiveItem(node){
    if (!analyzeBrowser) return;
    analyzeBrowser.querySelectorAll('.browser-item.active').forEach(el => el.classList.remove('active'));
    if (node) node.classList.add('active');
  }

  async function selectAndLoad(item, node, shouldPush){
    if (!item) return;
    selectedItem = item;
    setActiveItem(node);
    try {
      if (item.kind === 'mastering_run') {
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, '');
        await applyData(data);
      } else if (item.kind === 'source' || item.kind === 'import') {
        const params = new URLSearchParams();
        params.set(item.kind === 'source' ? 'src' : 'imp', item.rel);
        if (shouldPush) updateUrl(params);
        const data = await resolveFile(item.kind, item.rel);
        await applyData(data);
      }
    } catch (_err) {
      if (typeof showToast === 'function') showToast('Analyze data unavailable');
    }
  }

  async function uploadFile(file){
    const fd = new FormData();
    fd.append('file', file, file.name);
    const res = await fetch('/api/analyze-upload', { method: 'POST', body: fd });
    if (!res.ok) {
      throw new Error('upload_failed');
    }
    return res.json();
  }

  if (uploadBtn && uploadInput) {
    uploadBtn.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', async () => {
      const file = (uploadInput.files || [])[0];
      if (!file) return;
      try {
        if (typeof showToast === 'function') showToast('Uploading...');
        const data = await uploadFile(file);
        const payload = {
          source_url: data.source_url,
          source_name: data.source_name || file.name,
          processed_url: null,
          processed_name: '',
          metrics: { input: data.metrics, output: null },
          duration_s: data.duration_s,
          series: data.series,
          markers: data.markers,
        };
        await applyData(payload);
        if (data.rel) {
          const item = { kind: 'import', rel: data.rel };
          selectedItem = item;
          const params = new URLSearchParams();
          params.set('imp', data.rel);
          updateUrl(params);
        }
        if (typeof showToast === 'function') showToast('Analysis ready');
      } catch (_err) {
        if (typeof showToast === 'function') showToast('Upload failed');
      } finally {
        uploadInput.value = '';
      }
    });
  }

  if (playBtn) {
    playBtn.addEventListener('click', () => {
      playTransport();
    });
  }
  if (pauseBtn) {
    pauseBtn.addEventListener('click', () => {
      pauseTransport();
    });
  }
  if (stopBtn) {
    stopBtn.addEventListener('click', () => {
      stopTransport();
    });
  }
  if (zoomRange) {
    zoomRange.addEventListener('input', () => {
      const val = parseInt(zoomRange.value || '0', 10);
      const next = Number.isNaN(val) ? 0 : val;
      pendingZoom = next;
      if (zoomRaf !== null) return;
      zoomRaf = requestAnimationFrame(() => {
        zoomRaf = null;
        if (pendingZoom === null) return;
        setZoomLevel(pendingZoom);
        debugOverflow("zoom");
        pendingZoom = null;
      });
    });
  }

  window.addEventListener('resize', () => {
    if (zoomRaf !== null) return;
    zoomRaf = requestAnimationFrame(() => {
      zoomRaf = null;
      updateFitBaseline();
    });
  });

  modeButtons.forEach((btn) => {
    btn.addEventListener('click', () => {
      const mode = btn.dataset.playbackMode;
      if (mode) setPlaybackMode(mode);
    });
  });

  if (soloSourceBtn) {
    soloSourceBtn.addEventListener('click', () => {
      if (playbackMode === 'source' && processedWave) {
        setPlaybackMode('compare');
      } else {
        setPlaybackMode('source');
      }
    });
  }

  if (soloProcessedBtn) {
    soloProcessedBtn.addEventListener('click', () => {
      if (!processedWave) return;
      if (playbackMode === 'processed') {
        setPlaybackMode('compare');
      } else {
        setPlaybackMode('processed');
      }
    });
  }

  [togglePeakRisk, toggleHeatmap, toggleDelta].forEach((el) => {
    if (!el) return;
    el.addEventListener('change', () => {
      syncToggleStyles();
      drawOverlays();
    });
  });
  syncToggleStyles();
  updateFitBaseline();
  updatePlaybackModeUI();

  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  const src = params.get('src');
  const imp = params.get('imp');
  if (song) {
    selectedItem = { kind: 'mastering_run', id: song, song };
    selectAndLoad(selectedItem, null, false);
  } else if (src) {
    selectedItem = { kind: 'source', rel: src };
    selectAndLoad(selectedItem, null, false);
  } else if (imp) {
    selectedItem = { kind: 'import', rel: imp };
    selectAndLoad(selectedItem, null, false);
  }

  if (analyzeBrowser) {
    analyzeBrowser.addEventListener('click', (evt) => {
      const itemNode = evt.target.closest('.browser-item');
      if (!itemNode || itemNode.disabled) return;
      const kind = itemNode.dataset.kind || '';
      const id = itemNode.dataset.id || '';
      if (kind !== 'mastering_run') return;
      evt.preventDefault();
      evt.stopPropagation();
      const item = { kind, id, song: id };
      selectAndLoad(item, itemNode, true);
    });
    document.addEventListener('htmx:afterSwap', (evt) => {
      if (!analyzeBrowser.contains(evt.target)) return;
      const current = new URLSearchParams(window.location.search).get('song');
      if (!current) return;
      const node = analyzeBrowser.querySelector(`.browser-item[data-song="${current}"]`);
      if (node) setActiveItem(node);
    });
  }
})();
</script>
{% endblock %}
