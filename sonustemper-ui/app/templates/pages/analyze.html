{% extends "base.html" %}
{% block page_title %}Analyze | SonusTemper{% endblock %}
{% block title %}Analyze{% endblock %}
{% block subtitle %}Inspect spectrograms and diagnostics (read-only).{% endblock %}
{% block sidebar %}
  <div class="card">
    <div class="card-head">
      <div>
        <div class="card-title">Analyze Status</div>
        <div class="muted">Selection and analysis activity.</div>
      </div>
    </div>
    <div class="status-list" id="analysisStatusList">(waiting)</div>
  </div>
  <div class="card browse-card">
    <div class="card-head">
      <div>
        <div class="card-title">Browse</div>
        <div class="muted">Pick a source, run output, or import.</div>
      </div>
    </div>
    {% set browser_id = "analysisBrowser" %}
    {% set sections = [
      {"key": "analyze_uploads", "title": "Analyze Uploads", "endpoint": "/partials/library_list?view=analysis_imports&context=analyze"},
      {"key": "mastering_outputs", "title": "Mastering Outputs", "endpoint": "/partials/library_list?view=mastering_outputs&context=analyze"}
    ] %}
    {% include "partials/file_browser.html" %}
  </div>
{% endblock %}
{% block content %}
  <div class="card analyze-card">
    <div class="card-head">
      <div>
        <div class="card-title">Analyze</div>
        <div class="muted" id="analysisSubtitle">Read-only diagnostics</div>
      </div>
      <div class="analyze-actions">
        <a class="btn ghost small" id="compareLink" href="/compare">Open Compare</a>
      </div>
    </div>

    <div id="analysisEmpty" class="analyze-empty">
      <div class="muted">Select a source or output to inspect.</div>
    </div>

    <div id="analysisLoaded" class="analyze-loaded" hidden>
      <div class="metric-pills" id="analysisSummary"></div>

      <div class="analysis-focus-bar">
        <div class="pill-toggle">
          <button class="btn ghost small is-active" type="button" id="analysisFocusProcessed">Processed</button>
          <button class="btn ghost small" type="button" id="analysisFocusSource">Source</button>
        </div>
        <button class="btn ghost small" type="button" id="analysisShowBoth">Show both</button>
      </div>

      <div class="analysis-focus">
        <div class="analysis-panel analysis-panel-focus" id="analysisPanelProcessed">
          <div class="analysis-panel-head">
            <div class="wave-title">Processed</div>
            <div class="wave-meta" id="analysisProcessedName">-</div>
          </div>
          <div class="spectrogram-toolbar">
            <div class="pill-toggle">
              <button class="btn ghost small is-active" type="button" id="analysisProcessedScaleLog">Log</button>
              <button class="btn ghost small" type="button" id="analysisProcessedScaleLin">Linear</button>
            </div>
            <div class="spectrogram-control">
              <label for="analysisProcessedRange">Range</label>
              <input type="range" id="analysisProcessedRange" min="80" max="160" step="5" value="120">
              <span class="value-pill" id="analysisProcessedRangeVal">120</span>
            </div>
            <div class="spectrogram-control">
              <label for="analysisProcessedHeight">Height</label>
              <select id="analysisProcessedHeight" class="full-width-select">
                <option value="256">256</option>
                <option value="384" selected>384</option>
                <option value="512">512</option>
              </select>
            </div>
            <div class="spectrogram-control">
              <label for="analysisProcessedZoom">Time Zoom</label>
              <input type="range" id="analysisProcessedZoom" min="1" max="16" step="1" value="1">
              <span class="value-pill" id="analysisProcessedZoomVal">1x</span>
            </div>
            <button class="btn ghost small" type="button" id="analysisProcessedFitBtn">Fit</button>
            <button class="btn ghost small" type="button" id="analysisProcessedToNoise">Open Noise Cleanup</button>
            <span class="value-pill spectro-readout" id="analysisProcessedCursor">t=--  f=--</span>
          </div>
          <div class="spectro-viewport spectro-viewport--large" id="analysisSpectrogramProcessedViewport">
            <div class="spectro-inner" id="analysisSpectrogramProcessedInner">
              <img id="analysisSpectrogramProcessedImg" alt="Processed spectrogram" />
            </div>
          </div>
        </div>
        <div class="analysis-panel analysis-panel-secondary" id="analysisPanelSource" hidden>
          <div class="analysis-panel-head">
            <div class="wave-title">Source</div>
            <div class="wave-meta" id="analysisSourceName">-</div>
          </div>
          <div class="spectrogram-toolbar">
            <div class="pill-toggle">
              <button class="btn ghost small is-active" type="button" id="analysisSourceScaleLog">Log</button>
              <button class="btn ghost small" type="button" id="analysisSourceScaleLin">Linear</button>
            </div>
            <div class="spectrogram-control">
              <label for="analysisSourceRange">Range</label>
              <input type="range" id="analysisSourceRange" min="80" max="160" step="5" value="120">
              <span class="value-pill" id="analysisSourceRangeVal">120</span>
            </div>
            <div class="spectrogram-control">
              <label for="analysisSourceHeight">Height</label>
              <select id="analysisSourceHeight" class="full-width-select">
                <option value="256">256</option>
                <option value="384" selected>384</option>
                <option value="512">512</option>
              </select>
            </div>
            <div class="spectrogram-control">
              <label for="analysisSourceZoom">Time Zoom</label>
              <input type="range" id="analysisSourceZoom" min="1" max="16" step="1" value="1">
              <span class="value-pill" id="analysisSourceZoomVal">1x</span>
            </div>
            <button class="btn ghost small" type="button" id="analysisSourceFitBtn">Fit</button>
            <button class="btn ghost small" type="button" id="analysisSourceToNoise">Open Noise Cleanup</button>
            <span class="value-pill spectro-readout" id="analysisSourceCursor">t=--  f=--</span>
          </div>
          <div class="spectro-viewport spectro-viewport--large" id="analysisSpectrogramSourceViewport">
            <div class="spectro-inner" id="analysisSpectrogramSourceInner">
              <img id="analysisSpectrogramSourceImg" alt="Source spectrogram" />
            </div>
          </div>
        </div>
      </div>

      <div class="compare-grid analysis-metrics" id="analysisMetricsGrid"></div>
    </div>
  </div>

  <div class="card analyze-card" id="noiseCleanupCard">
    <div class="card-head">
      <div>
        <div class="card-title">Noise Cleanup</div>
        <div class="muted">Select a time/frequency region and preview cleanup.</div>
      </div>
    </div>
    <div class="noise-cleanup">
      <div class="noise-left">
        <div class="noise-source-toggle">
          <label class="check"><input type="radio" name="noiseTarget" id="noiseTargetSource" value="source" checked> Source</label>
          <label class="check"><input type="radio" name="noiseTarget" id="noiseTargetProcessed" value="processed"> Processed</label>
        </div>
        <div class="spectrogram-toolbar noise-toolbar">
          <div class="spectrogram-control">
            <label for="noiseSpectrogramHeight">Height</label>
            <select id="noiseSpectrogramHeight" class="full-width-select">
              <option value="256">256</option>
              <option value="384" selected>384</option>
              <option value="512">512</option>
            </select>
          </div>
          <div class="spectrogram-control">
            <label for="noiseZoomRange">Time Zoom</label>
            <input type="range" id="noiseZoomRange" min="1" max="16" step="1" value="1">
            <span class="value-pill" id="noiseZoomVal">1x</span>
          </div>
          <button class="btn ghost tiny" type="button" id="noiseFitBtn">Fit</button>
          <button class="btn ghost tiny" type="button" id="noiseClearBtn">Clear selection</button>
        </div>
        <div class="spectro-viewport" id="spectrogramViewport">
          <div class="spectro-inner" id="spectrogramInner">
            <img id="spectrogramImg" alt="Spectrogram" />
            <div class="spectrogram-overlay" id="spectrogramOverlay"></div>
            <div class="spectrogram-selection" id="spectrogramSelection" hidden></div>
          </div>
        </div>
        <div class="noise-readouts">
          <div class="noise-readout"><span>t0</span><span id="noiseT0">-</span></div>
          <div class="noise-readout"><span>t1</span><span id="noiseT1">-</span></div>
          <div class="noise-readout"><span>f0</span><span id="noiseF0">-</span></div>
          <div class="noise-readout"><span>f1</span><span id="noiseF1">-</span></div>
          <div class="noise-readout"><span>Center</span><span id="noiseCenter">-</span></div>
          <div class="noise-readout"><span>Bandwidth</span><span id="noiseBandwidth">-</span></div>
        </div>
      </div>
      <div class="noise-right">
        <div class="control-row">
          <label class="control-label">Noise Filter Preset</label>
          <select id="noisePresetSelect" class="full-width-select">
            <option value="">No preset</option>
          </select>
        </div>
        <div class="control-row">
          <label class="control-label">Preview Mode</label>
          <div class="pill-toggle">
            <button class="btn ghost small is-active" type="button" id="noiseModeRemove">Remove noise</button>
            <button class="btn ghost small" type="button" id="noiseModeSolo">Solo noise</button>
          </div>
        </div>
        <div class="control-row compact-row">
          <div class="control-label">Filter depth (dB)</div>
          <input type="range" id="noiseDepthRange" min="-30" max="-6" step="1" value="-18">
          <div class="value-pill" id="noiseDepthVal">-18</div>
        </div>
        <div class="control-row compact-row">
          <div class="control-label">Denoise strength</div>
          <input type="range" id="noiseAfftdnRange" min="0" max="1" step="0.05" value="0.35">
          <div class="value-pill" id="noiseAfftdnVal">0.35</div>
        </div>
        <div class="control-row noise-hp-lp">
          <label class="check"><input type="checkbox" id="noiseHpToggle"> High-pass</label>
          <input type="number" id="noiseHpValue" min="20" max="500" step="1" value="70">
          <label class="check"><input type="checkbox" id="noiseLpToggle"> Low-pass</label>
          <input type="number" id="noiseLpValue" min="1000" max="20000" step="10" value="16000">
        </div>
        <div class="control-row preview-row">
          <div class="control-label small-label">Preview</div>
          <audio id="noisePreviewAudio" class="preview-audio" controls preload="none"></audio>
          <span class="muted" id="noisePreviewStatus">Preview idle</span>
        </div>
        <div class="preset-actions">
          <button class="btn btn-primary small" type="button" id="noisePreviewBtn">Preview</button>
          <button class="btn ghost small" type="button" id="noiseRenderBtn">Render Cleaned Copy</button>
          <button class="btn ghost small" type="button" id="noiseSaveBtn">Save as Noise Filter Preset</button>
        </div>
      </div>
    </div>
  </div>
{% endblock %}

{% block extra_js %}
<script>
(() => {
  const statusList = document.getElementById('analysisStatusList');
  const emptyState = document.getElementById('analysisEmpty');
  const loadedState = document.getElementById('analysisLoaded');
  const summaryPills = document.getElementById('analysisSummary');
  const metricsGrid = document.getElementById('analysisMetricsGrid');
  const sourceName = document.getElementById('analysisSourceName');
  const processedName = document.getElementById('analysisProcessedName');
  const analyzeBrowser = document.getElementById('analysisBrowser');
  const compareLink = document.getElementById('compareLink');
  const noiseCleanupCard = document.getElementById('noiseCleanupCard');
  const analysisPanelSource = document.getElementById('analysisPanelSource');
  const analysisPanelProcessed = document.getElementById('analysisPanelProcessed');
  const analysisFocusProcessedBtn = document.getElementById('analysisFocusProcessed');
  const analysisFocusSourceBtn = document.getElementById('analysisFocusSource');
  const analysisShowBothBtn = document.getElementById('analysisShowBoth');
  const analysisSpectrogramSourceImg = document.getElementById('analysisSpectrogramSourceImg');
  const analysisSpectrogramProcessedImg = document.getElementById('analysisSpectrogramProcessedImg');
  const analysisSpectrogramSourceViewport = document.getElementById('analysisSpectrogramSourceViewport');
  const analysisSpectrogramSourceInner = document.getElementById('analysisSpectrogramSourceInner');
  const analysisSpectrogramProcessedViewport = document.getElementById('analysisSpectrogramProcessedViewport');
  const analysisSpectrogramProcessedInner = document.getElementById('analysisSpectrogramProcessedInner');
  const analysisSourceScaleLog = document.getElementById('analysisSourceScaleLog');
  const analysisSourceScaleLin = document.getElementById('analysisSourceScaleLin');
  const analysisProcessedScaleLog = document.getElementById('analysisProcessedScaleLog');
  const analysisProcessedScaleLin = document.getElementById('analysisProcessedScaleLin');
  const analysisSourceRange = document.getElementById('analysisSourceRange');
  const analysisSourceRangeVal = document.getElementById('analysisSourceRangeVal');
  const analysisProcessedRange = document.getElementById('analysisProcessedRange');
  const analysisProcessedRangeVal = document.getElementById('analysisProcessedRangeVal');
  const analysisSourceHeight = document.getElementById('analysisSourceHeight');
  const analysisProcessedHeight = document.getElementById('analysisProcessedHeight');
  const analysisSourceZoom = document.getElementById('analysisSourceZoom');
  const analysisSourceZoomVal = document.getElementById('analysisSourceZoomVal');
  const analysisSourceFitBtn = document.getElementById('analysisSourceFitBtn');
  const analysisProcessedZoom = document.getElementById('analysisProcessedZoom');
  const analysisProcessedZoomVal = document.getElementById('analysisProcessedZoomVal');
  const analysisProcessedFitBtn = document.getElementById('analysisProcessedFitBtn');
  const analysisSourceCursor = document.getElementById('analysisSourceCursor');
  const analysisProcessedCursor = document.getElementById('analysisProcessedCursor');
  const analysisSourceToNoise = document.getElementById('analysisSourceToNoise');
  const analysisProcessedToNoise = document.getElementById('analysisProcessedToNoise');
  const spectrogramViewport = document.getElementById('spectrogramViewport');
  const spectrogramInner = document.getElementById('spectrogramInner');
  const spectrogramImg = document.getElementById('spectrogramImg');
  const spectrogramOverlay = document.getElementById('spectrogramOverlay');
  const spectrogramSelection = document.getElementById('spectrogramSelection');
  const noiseTargetSource = document.getElementById('noiseTargetSource');
  const noiseTargetProcessed = document.getElementById('noiseTargetProcessed');
  const noisePresetSelect = document.getElementById('noisePresetSelect');
  const noiseModeRemoveBtn = document.getElementById('noiseModeRemove');
  const noiseModeSoloBtn = document.getElementById('noiseModeSolo');
  const noiseDepthRange = document.getElementById('noiseDepthRange');
  const noiseDepthVal = document.getElementById('noiseDepthVal');
  const noiseAfftdnRange = document.getElementById('noiseAfftdnRange');
  const noiseAfftdnVal = document.getElementById('noiseAfftdnVal');
  const noiseHpToggle = document.getElementById('noiseHpToggle');
  const noiseHpValue = document.getElementById('noiseHpValue');
  const noiseLpToggle = document.getElementById('noiseLpToggle');
  const noiseLpValue = document.getElementById('noiseLpValue');
  const noisePreviewAudio = document.getElementById('noisePreviewAudio');
  const noisePreviewStatus = document.getElementById('noisePreviewStatus');
  const noisePreviewBtn = document.getElementById('noisePreviewBtn');
  const noiseRenderBtn = document.getElementById('noiseRenderBtn');
  const noiseSaveBtn = document.getElementById('noiseSaveBtn');
  const noiseSpectrogramHeight = document.getElementById('noiseSpectrogramHeight');
  const noiseZoomRange = document.getElementById('noiseZoomRange');
  const noiseZoomVal = document.getElementById('noiseZoomVal');
  const noiseFitBtn = document.getElementById('noiseFitBtn');
  const noiseClearBtn = document.getElementById('noiseClearBtn');
  const noiseT0 = document.getElementById('noiseT0');
  const noiseT1 = document.getElementById('noiseT1');
  const noiseF0 = document.getElementById('noiseF0');
  const noiseF1 = document.getElementById('noiseF1');
  const noiseCenter = document.getElementById('noiseCenter');
  const noiseBandwidth = document.getElementById('noiseBandwidth');
  let statusLines = [];
  let analysisContext = { source: null, processed: null, duration: null };
  let analysisFocus = 'processed';
  let analysisShowBoth = false;
  let noiseSelection = null;
  let noiseMode = 'remove';
  let noisePresets = new Map();
  let lastNoiseTargetRel = null;
  const ANALYZE_SOURCE_SCALE_KEY = 'sonustemper.analyzeSpecScale.source';
  const ANALYZE_SOURCE_DRANGE_KEY = 'sonustemper.analyzeSpecDrange.source';
  const ANALYZE_SOURCE_HEIGHT_KEY = 'sonustemper.analyzeSpecHeight.source';
  const ANALYZE_PROCESSED_SCALE_KEY = 'sonustemper.analyzeSpecScale.processed';
  const ANALYZE_PROCESSED_DRANGE_KEY = 'sonustemper.analyzeSpecDrange.processed';
  const ANALYZE_PROCESSED_HEIGHT_KEY = 'sonustemper.analyzeSpecHeight.processed';
  const NOISE_HEIGHT_KEY = 'sonustemper.noiseSpectrogramHeight';

  const metricLabels = [
    { key: 'I', label: 'LUFS-I', suffix: ' LUFS' },
    { key: 'TP', label: 'True Peak', suffix: ' dBTP' },
    { key: 'LRA', label: 'LRA', suffix: ' LU' },
    { key: 'rms_level', label: 'RMS', suffix: ' dB' },
    { key: 'crest_factor', label: 'Crest', suffix: ' dB' },
    { key: 'dynamic_range', label: 'DR', suffix: ' dB' },
  ];

  function fmt(num, decimals){
    if (num === null || num === undefined || Number.isNaN(num)) return '-';
    const fixed = (typeof decimals === 'number') ? num.toFixed(decimals) : num.toFixed(1);
    return fixed.replace(/\.0$/, '');
  }

  function formatDelta(outVal, inVal){
    if (typeof outVal !== 'number' || typeof inVal !== 'number') return '';
    const delta = outVal - inVal;
    const sign = delta > 0 ? '+' : '';
    return ` (${sign}${fmt(delta, 1)})`;
  }

  function formatSeconds(val){
    if (val === null || val === undefined || Number.isNaN(val)) return '-';
    return `${val.toFixed(2)}s`;
  }

  function formatHz(val){
    if (val === null || val === undefined || Number.isNaN(val)) return '-';
    if (val >= 1000) return `${(val / 1000).toFixed(2)}k`;
    return `${val.toFixed(0)} Hz`;
  }

  function formatClock(seconds){
    if (seconds === null || seconds === undefined || Number.isNaN(seconds)) return '--';
    const total = Math.max(0, seconds);
    const m = Math.floor(total / 60);
    const s = (total % 60).toFixed(1).padStart(4, '0');
    return `${m}:${s}`;
  }

  function loadSetting(key, fallback){
    try {
      const stored = window.localStorage.getItem(key);
      return stored !== null ? stored : fallback;
    } catch (_err) {
      return fallback;
    }
  }

  function saveSetting(key, value){
    try {
      window.localStorage.setItem(key, String(value));
    } catch (_err) {
      return;
    }
  }

  function spectrogramUrl(relPath, w, h, scale, drange){
    const params = new URLSearchParams({
      path: relPath,
      w: String(w),
      h: String(h),
      scale: scale,
      drange: String(drange),
    });
    return `/api/analyze/spectrogram?${params.toString()}`;
  }

  function setSpectrogramViewport(viewportEl, heightPx, overrideMin){
    if (!viewportEl || !heightPx) return;
    viewportEl.style.height = `${heightPx}px`;
    if (overrideMin) {
      viewportEl.style.minHeight = `${heightPx}px`;
    }
  }

  function renderSpectrogramViewer(spec, relPath, heightPx, preserveCenter, overrideMin){
    if (!spec || !spec.viewport || !spec.inner || !spec.img || !relPath) return;
    const viewport = spec.viewport;
    const inner = spec.inner;
    const zoom = Math.max(1, spec.zoom || 1);
    const baseWidth = Math.max(1, viewport.clientWidth);
    const prevInnerWidth = inner.getBoundingClientRect().width || baseWidth;
    const prevScroll = viewport.scrollLeft;
    const innerWidth = Math.max(baseWidth * zoom, baseWidth);
    setSpectrogramViewport(viewport, heightPx, overrideMin);
    inner.style.width = `${innerWidth}px`;
    inner.style.height = `${heightPx}px`;
    const dpr = window.devicePixelRatio || 1;
    const width = Math.max(300, Math.round(innerWidth * dpr));
    const height = Math.max(200, Math.round(heightPx * dpr));
    spec.img.src = spectrogramUrl(relPath, width, height, spec.scale, spec.drange);
    if (preserveCenter && prevInnerWidth > 0) {
      const centerRatio = (prevScroll + baseWidth * 0.5) / prevInnerWidth;
      const nextScroll = Math.max(0, centerRatio * innerWidth - baseWidth * 0.5);
      viewport.scrollLeft = nextScroll;
    } else if (!preserveCenter) {
      viewport.scrollLeft = Math.min(viewport.scrollLeft, Math.max(0, innerWidth - baseWidth));
    }
  }

  function makeResizeObserver(containerEl, callback){
    if (!containerEl || typeof ResizeObserver === 'undefined') return null;
    let timer = null;
    const observer = new ResizeObserver(() => {
      if (timer) clearTimeout(timer);
      timer = setTimeout(callback, 150);
    });
    observer.observe(containerEl);
    return observer;
  }

  function setNoiseMode(mode){
    noiseMode = mode === 'solo' ? 'solo' : 'remove';
    if (noiseModeRemoveBtn) noiseModeRemoveBtn.classList.toggle('is-active', noiseMode === 'remove');
    if (noiseModeSoloBtn) noiseModeSoloBtn.classList.toggle('is-active', noiseMode === 'solo');
    if (noiseDepthRange) noiseDepthRange.disabled = noiseMode !== 'remove';
  }

  function setNoiseStatus(msg){
    if (noisePreviewStatus) noisePreviewStatus.textContent = msg || '';
  }

  function updateNoiseReadouts(selection){
    if (!noiseT0 || !noiseT1 || !noiseF0 || !noiseF1 || !noiseCenter || !noiseBandwidth) return;
    if (!selection) {
      noiseT0.textContent = '-';
      noiseT1.textContent = '-';
      noiseF0.textContent = '-';
      noiseF1.textContent = '-';
      noiseCenter.textContent = '-';
      noiseBandwidth.textContent = '-';
      return;
    }
    noiseT0.textContent = formatSeconds(selection.t0);
    noiseT1.textContent = formatSeconds(selection.t1);
    noiseF0.textContent = formatHz(selection.f0);
    noiseF1.textContent = formatHz(selection.f1);
    noiseCenter.textContent = formatHz((selection.f0 + selection.f1) * 0.5);
    noiseBandwidth.textContent = formatHz(selection.f1 - selection.f0);
  }

  function getActiveNoiseTarget(){
    if (noiseTargetProcessed && noiseTargetProcessed.checked && analysisContext.processed?.rel) {
      return analysisContext.processed;
    }
    return analysisContext.source;
  }

  function updateNoiseTargets(){
    const hasProcessed = Boolean(analysisContext.processed?.rel);
    if (noiseTargetProcessed) noiseTargetProcessed.disabled = !hasProcessed;
    if (!hasProcessed && noiseTargetSource) noiseTargetSource.checked = true;
  }

  function renderNoiseSpectrogram(preserveCenter){
    if (!spectrogramImg || !spectrogramViewport || !spectrogramInner) return;
    const target = getActiveNoiseTarget();
    if (!target || !target.rel) {
      spectrogramImg.removeAttribute('src');
      noiseSelection = null;
      lastNoiseTargetRel = null;
      updateNoiseReadouts(null);
      return;
    }
    if (lastNoiseTargetRel && lastNoiseTargetRel !== target.rel) {
      noiseSelection = null;
      updateNoiseReadouts(null);
    }
    lastNoiseTargetRel = target.rel;
    const heightPx = parseInt(
      (noiseSpectrogramHeight?.value || loadSetting(NOISE_HEIGHT_KEY, '384')),
      10
    ) || 384;
    const zoom = noiseZoomRange ? parseInt(noiseZoomRange.value || '1', 10) || 1 : 1;
    if (noiseZoomVal) noiseZoomVal.textContent = `${zoom}x`;
    const spec = {
      img: spectrogramImg,
      viewport: spectrogramViewport,
      inner: spectrogramInner,
      zoom: zoom,
      scale: 'log',
      drange: 120,
    };
    renderSpectrogramViewer(spec, target.rel, heightPx, preserveCenter, true);
    renderNoiseSelectionBox();
  }

  const analyzeSpectrograms = {
    source: {
      img: analysisSpectrogramSourceImg,
      viewport: analysisSpectrogramSourceViewport,
      inner: analysisSpectrogramSourceInner,
      scaleLog: analysisSourceScaleLog,
      scaleLin: analysisSourceScaleLin,
      range: analysisSourceRange,
      rangeVal: analysisSourceRangeVal,
      heightSelect: analysisSourceHeight,
      zoomRange: analysisSourceZoom,
      zoomVal: analysisSourceZoomVal,
      fitBtn: analysisSourceFitBtn,
      cursor: analysisSourceCursor,
      toNoise: analysisSourceToNoise,
      scaleKey: ANALYZE_SOURCE_SCALE_KEY,
      drangeKey: ANALYZE_SOURCE_DRANGE_KEY,
      heightKey: ANALYZE_SOURCE_HEIGHT_KEY,
      scale: 'log',
      drange: 120,
      height: 384,
      zoom: 1,
    },
    processed: {
      img: analysisSpectrogramProcessedImg,
      viewport: analysisSpectrogramProcessedViewport,
      inner: analysisSpectrogramProcessedInner,
      scaleLog: analysisProcessedScaleLog,
      scaleLin: analysisProcessedScaleLin,
      range: analysisProcessedRange,
      rangeVal: analysisProcessedRangeVal,
      heightSelect: analysisProcessedHeight,
      zoomRange: analysisProcessedZoom,
      zoomVal: analysisProcessedZoomVal,
      fitBtn: analysisProcessedFitBtn,
      cursor: analysisProcessedCursor,
      toNoise: analysisProcessedToNoise,
      scaleKey: ANALYZE_PROCESSED_SCALE_KEY,
      drangeKey: ANALYZE_PROCESSED_DRANGE_KEY,
      heightKey: ANALYZE_PROCESSED_HEIGHT_KEY,
      scale: 'log',
      drange: 120,
      height: 384,
      zoom: 1,
    },
  };

  function loadAnalyzeSpectrogramState(spec){
    spec.scale = loadSetting(spec.scaleKey, 'log');
    spec.drange = parseInt(loadSetting(spec.drangeKey, '120'), 10) || 120;
    spec.height = parseInt(loadSetting(spec.heightKey, '384'), 10) || 384;
    spec.zoom = 1;
    if (spec.range) spec.range.value = String(spec.drange);
    if (spec.rangeVal) spec.rangeVal.textContent = String(spec.drange);
    if (spec.heightSelect) spec.heightSelect.value = String(spec.height);
    if (spec.zoomRange) spec.zoomRange.value = String(spec.zoom);
    if (spec.zoomVal) spec.zoomVal.textContent = `${spec.zoom}x`;
    if (spec.scaleLog) spec.scaleLog.classList.toggle('is-active', spec.scale !== 'lin');
    if (spec.scaleLin) spec.scaleLin.classList.toggle('is-active', spec.scale === 'lin');
  }

  function effectiveAnalyzeHeight(kind, spec){
    const hasFocus = analysisFocus === kind;
    if (!analysisShowBoth && !hasFocus) return null;
    if (analysisShowBoth && !hasFocus) {
      return Math.min(spec.height || 256, 256);
    }
    return spec.height;
  }

  function renderAnalyzeSpectrogram(spec, relPath, heightPx, preserveCenter){
    if (!spec || !spec.img || !spec.viewport || !spec.inner) return;
    if (!relPath || !heightPx) {
      spec.img.removeAttribute('src');
      return;
    }
    renderSpectrogramViewer(spec, relPath, heightPx, preserveCenter, true);
  }

  function renderAnalyzeSpectrograms(preserveCenter){
    renderAnalyzeSpectrogram(
      analyzeSpectrograms.source,
      analysisContext.source?.rel,
      effectiveAnalyzeHeight('source', analyzeSpectrograms.source),
      preserveCenter
    );
    renderAnalyzeSpectrogram(
      analyzeSpectrograms.processed,
      analysisContext.processed?.rel,
      effectiveAnalyzeHeight('processed', analyzeSpectrograms.processed),
      preserveCenter
    );
  }

  function syncAnalyzeFocusUI(){
    const hasSource = Boolean(analysisContext.source?.rel);
    const hasProcessed = Boolean(analysisContext.processed?.rel);
    if (!hasProcessed && hasSource) {
      analysisFocus = 'source';
    } else if (!hasSource && hasProcessed) {
      analysisFocus = 'processed';
    }
    if (!hasSource || !hasProcessed) {
      analysisShowBoth = false;
    }
    if (analysisFocusProcessedBtn) {
      analysisFocusProcessedBtn.disabled = !hasProcessed;
      analysisFocusProcessedBtn.classList.toggle('is-active', analysisFocus === 'processed');
    }
    if (analysisFocusSourceBtn) {
      analysisFocusSourceBtn.disabled = !hasSource;
      analysisFocusSourceBtn.classList.toggle('is-active', analysisFocus === 'source');
    }
    if (analysisShowBothBtn) {
      analysisShowBothBtn.disabled = !(hasSource && hasProcessed);
      analysisShowBothBtn.classList.toggle('is-active', analysisShowBoth);
      analysisShowBothBtn.textContent = analysisShowBoth ? 'Hide secondary' : 'Show both';
    }
    if (analysisPanelProcessed) {
      const showProcessed = hasProcessed && (analysisShowBoth || analysisFocus === 'processed');
      analysisPanelProcessed.hidden = !showProcessed;
      analysisPanelProcessed.classList.toggle('analysis-panel-focus', analysisFocus === 'processed');
      analysisPanelProcessed.classList.toggle('analysis-panel-secondary', analysisShowBoth && analysisFocus !== 'processed');
    }
    if (analysisPanelSource) {
      const showSource = hasSource && (analysisShowBoth || analysisFocus === 'source');
      analysisPanelSource.hidden = !showSource;
      analysisPanelSource.classList.toggle('analysis-panel-focus', analysisFocus === 'source');
      analysisPanelSource.classList.toggle('analysis-panel-secondary', analysisShowBoth && analysisFocus !== 'source');
    }
    if (analysisSourceToNoise) {
      analysisSourceToNoise.disabled = !hasSource;
    }
    if (analysisProcessedToNoise) {
      analysisProcessedToNoise.disabled = !hasProcessed;
    }
    if (metricsGrid) {
      metricsGrid.dataset.focus = analysisFocus;
    }
  }

  function bindAnalyzeSpectrogramControls(spec, kind){
    if (spec.scaleLog) {
      spec.scaleLog.addEventListener('click', () => {
        spec.scale = 'log';
        saveSetting(spec.scaleKey, spec.scale);
        if (spec.scaleLog) spec.scaleLog.classList.add('is-active');
        if (spec.scaleLin) spec.scaleLin.classList.remove('is-active');
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), false);
      });
    }
    if (spec.scaleLin) {
      spec.scaleLin.addEventListener('click', () => {
        spec.scale = 'lin';
        saveSetting(spec.scaleKey, spec.scale);
        if (spec.scaleLin) spec.scaleLin.classList.add('is-active');
        if (spec.scaleLog) spec.scaleLog.classList.remove('is-active');
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), false);
      });
    }
    if (spec.range) {
      spec.range.addEventListener('input', () => {
        spec.drange = parseInt(spec.range.value || '120', 10) || 120;
        saveSetting(spec.drangeKey, spec.drange);
        if (spec.rangeVal) spec.rangeVal.textContent = String(spec.drange);
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), false);
      });
    }
    if (spec.heightSelect) {
      spec.heightSelect.addEventListener('change', () => {
        spec.height = parseInt(spec.heightSelect.value || '384', 10) || 384;
        saveSetting(spec.heightKey, spec.height);
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), false);
      });
    }
    if (spec.zoomRange) {
      spec.zoomRange.addEventListener('input', () => {
        spec.zoom = parseInt(spec.zoomRange.value || '1', 10) || 1;
        if (spec.zoomVal) spec.zoomVal.textContent = `${spec.zoom}x`;
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), true);
      });
    }
    if (spec.fitBtn) {
      spec.fitBtn.addEventListener('click', () => {
        spec.zoom = 1;
        if (spec.zoomRange) spec.zoomRange.value = '1';
        if (spec.zoomVal) spec.zoomVal.textContent = '1x';
        if (spec.viewport) spec.viewport.scrollLeft = 0;
        renderAnalyzeSpectrogram(spec, analysisContext[kind]?.rel, effectiveAnalyzeHeight(kind, spec), false);
      });
    }
    if (spec.toNoise) {
      spec.toNoise.addEventListener('click', () => {
        if (kind === 'processed' && noiseTargetProcessed && !noiseTargetProcessed.disabled) {
          noiseTargetProcessed.checked = true;
        } else if (noiseTargetSource) {
          noiseTargetSource.checked = true;
        }
        renderNoiseSpectrogram(false);
        if (noiseCleanupCard) {
          noiseCleanupCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
    }
  }

  function bindSpectrogramCursor(spec, kind){
    if (!spec || !spec.viewport || !spec.inner || !spec.cursor) return;
    const updateCursor = (evt) => {
      if (!analysisContext.duration) {
        spec.cursor.textContent = 't=--  f=--';
        return;
      }
      const rect = spec.inner.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      if (x < 0 || y < 0 || x > rect.width || y > rect.height) {
        spec.cursor.textContent = 't=--  f=--';
        return;
      }
      const time = (x / rect.width) * analysisContext.duration;
      const freq = yToFreqScaled(y, rect.height, spec.scale);
      spec.cursor.textContent = `t=${formatClock(time)}  f=${formatHz(freq)}`;
    };
    spec.viewport.addEventListener('mousemove', updateCursor);
    spec.viewport.addEventListener('mouseleave', () => {
      spec.cursor.textContent = 't=--  f=--';
    });
  }

  function renderStatus(){
    if (!statusList) return;
    statusList.textContent = statusLines.length ? statusLines.join('\n') : '(waiting)';
    statusList.scrollTop = statusList.scrollHeight;
  }

  function addStatusLine(message){
    if (!message) return;
    const ts = new Date().toLocaleTimeString();
    statusLines.push(`${ts} ${message}`);
    if (statusLines.length > 200) statusLines = statusLines.slice(-200);
    renderStatus();
  }

  function renderPills(payload, input, output){
    if (!summaryPills) return;
    summaryPills.innerHTML = '';
    const addPill = (text, title) => {
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      pill.textContent = text;
      if (title) pill.title = title;
      summaryPills.appendChild(pill);
    };
    if (payload?.source_name) {
      addPill(`Source: ${payload.source_name}`, payload.source_name);
    }
    if (payload?.processed_name) {
      addPill(`Processed: ${payload.processed_name}`, payload.processed_name);
    }
    if (analysisContext.duration) {
      addPill(`Duration: ${formatSeconds(analysisContext.duration)}`);
    }
    if (payload?.processed_label) {
      addPill(`Output: ${String(payload.processed_label).toUpperCase()}`);
    }
    if (!payload?.processed_url) {
      addPill('Tip: Run mastering to compare processed output.');
    }
    metricLabels.forEach(meta => {
      const outVal = output ? output[meta.key] : null;
      if (outVal === null || outVal === undefined) return;
      const delta = formatDelta(outVal, input ? input[meta.key] : null);
      addPill(`${meta.label}: ${fmt(outVal, 1)}${meta.suffix}${delta}`);
    });
  }

  function renderMetrics(input, output){
    if (!metricsGrid) return;
    metricsGrid.innerHTML = '';
    const headers = ['Metric', 'Source', 'Processed', 'Delta'];
    const colKeys = ['metric', 'source', 'processed', 'delta'];
    headers.forEach((label, idx) => {
      const cell = document.createElement('div');
      cell.className = `compare-cell compare-head col-${colKeys[idx]}`;
      cell.textContent = label;
      metricsGrid.appendChild(cell);
    });
    metricLabels.forEach(meta => {
      const inVal = input ? input[meta.key] : null;
      const outVal = output ? output[meta.key] : null;
      const row = [
        meta.label,
        inVal === null || inVal === undefined ? '-' : `${fmt(inVal, 1)}${meta.suffix}`,
        outVal === null || outVal === undefined ? '-' : `${fmt(outVal, 1)}${meta.suffix}`,
        formatDelta(outVal, inVal).replace(/[()]/g, '') || '-',
      ];
      row.forEach((val, idx) => {
        const cell = document.createElement('div');
        cell.className = `compare-cell col-${colKeys[idx]}`;
        cell.textContent = val;
        metricsGrid.appendChild(cell);
      });
    });
    metricsGrid.dataset.focus = analysisFocus;
  }

  function syncPreserveLinks(params){
    const search = params.toString();
    document.querySelectorAll('a[data-preserve-query="true"]').forEach((link) => {
      const href = link.getAttribute('href');
      if (!href) return;
      try {
        const url = new URL(href, window.location.origin);
        url.search = search;
        link.setAttribute('href', `${url.pathname}${url.search}`);
      } catch (_err) {
        return;
      }
    });
  }

  function updateUrl(params){
    const next = new URL(window.location.href);
    next.search = params.toString();
    window.history.pushState({}, '', next.toString());
    if (compareLink) {
      compareLink.href = `/compare${next.search}`;
    }
    syncPreserveLinks(params);
  }

  async function resolveRun(song, out, solo){
    const params = new URLSearchParams();
    params.set('song', song);
    if (out) params.set('out', out);
    if (solo) params.set('solo', '1');
    const res = await fetch(`/api/analyze-resolve?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  async function resolveFile(kind, rel){
    const params = new URLSearchParams();
    if (kind === 'source') {
      params.set('src', rel);
    } else if (kind === 'import') {
      params.set('imp', rel);
    }
    const res = await fetch(`/api/analyze-resolve-file?${params.toString()}`);
    if (!res.ok) throw new Error('resolve_failed');
    return res.json();
  }

  const NOISE_FREQ_MIN = 20;
  const NOISE_FREQ_MAX = 20000;

  function freqToY(freq, height){
    const safe = Math.max(NOISE_FREQ_MIN, Math.min(NOISE_FREQ_MAX, freq));
    const norm = (Math.log(safe) - Math.log(NOISE_FREQ_MIN)) / Math.log(NOISE_FREQ_MAX / NOISE_FREQ_MIN);
    return (1 - norm) * height;
  }

  function yToFreq(y, height){
    const norm = 1 - (y / height);
    return Math.exp(Math.log(NOISE_FREQ_MIN) + norm * Math.log(NOISE_FREQ_MAX / NOISE_FREQ_MIN));
  }

  function yToFreqScaled(y, height, scale){
    if (scale === 'lin') {
      const norm = 1 - (y / height);
      return NOISE_FREQ_MIN + norm * (NOISE_FREQ_MAX - NOISE_FREQ_MIN);
    }
    return yToFreq(y, height);
  }

  function renderNoiseSelectionBox(){
    if (!spectrogramSelection || !spectrogramOverlay) return;
    if (!noiseSelection || !analysisContext.duration) {
      spectrogramSelection.hidden = true;
      return;
    }
    const rect = spectrogramOverlay.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const t0 = Math.max(0, Math.min(noiseSelection.t0, noiseSelection.t1));
    const t1 = Math.max(0, Math.max(noiseSelection.t0, noiseSelection.t1));
    const f0 = Math.max(NOISE_FREQ_MIN, Math.min(noiseSelection.f0, noiseSelection.f1));
    const f1 = Math.max(NOISE_FREQ_MIN, Math.max(noiseSelection.f0, noiseSelection.f1));
    const x0 = (t0 / analysisContext.duration) * rect.width;
    const x1 = (t1 / analysisContext.duration) * rect.width;
    const y0 = freqToY(f1, rect.height);
    const y1 = freqToY(f0, rect.height);
    spectrogramSelection.hidden = false;
    spectrogramSelection.style.left = `${x0}px`;
    spectrogramSelection.style.top = `${y0}px`;
    spectrogramSelection.style.width = `${Math.max(2, x1 - x0)}px`;
    spectrogramSelection.style.height = `${Math.max(2, y1 - y0)}px`;
  }

  function bindSpectrogramSelection(){
    if (!spectrogramOverlay || !spectrogramSelection) return;
    const updateCrosshair = (evt) => {
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      spectrogramOverlay.style.setProperty('--cursor-x', `${x}px`);
      spectrogramOverlay.style.setProperty('--cursor-y', `${y}px`);
      spectrogramOverlay.classList.add('is-hovering');
    };
    let dragging = false;
    let startX = 0;
    let startY = 0;
    const onMove = (evt) => {
      if (!dragging) return;
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      const left = Math.min(startX, x);
      const top = Math.min(startY, y);
      const width = Math.abs(x - startX);
      const height = Math.abs(y - startY);
      spectrogramSelection.hidden = false;
      spectrogramSelection.style.left = `${left}px`;
      spectrogramSelection.style.top = `${top}px`;
      spectrogramSelection.style.width = `${Math.max(width, 2)}px`;
      spectrogramSelection.style.height = `${Math.max(height, 2)}px`;
      if (analysisContext.duration) {
        const right = left + Math.max(width, 2);
        const bottom = top + Math.max(height, 2);
        const t0 = (left / rect.width) * analysisContext.duration;
        const t1 = (right / rect.width) * analysisContext.duration;
        const f0 = yToFreq(bottom, rect.height);
        const f1 = yToFreq(top, rect.height);
        noiseSelection = { t0, t1, f0, f1 };
        updateNoiseReadouts(noiseSelection);
      }
      updateCrosshair(evt);
    };
    const onUp = (evt) => {
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      const rect = spectrogramOverlay.getBoundingClientRect();
      const x1 = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      const y1 = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      const left = Math.min(startX, x1);
      const right = Math.max(startX, x1);
      const top = Math.min(startY, y1);
      const bottom = Math.max(startY, y1);
      if (right - left < 4 || bottom - top < 4) {
        noiseSelection = null;
        spectrogramSelection.hidden = true;
        updateNoiseReadouts(null);
        return;
      }
      const duration = analysisContext.duration || 0;
      const toTime = (x) => (duration ? (x / rect.width) * duration : 0);
      const toFreq = (y) => {
        return yToFreq(y, rect.height);
      };
      const t0 = toTime(left);
      const t1 = toTime(right);
      const f0 = toFreq(bottom);
      const f1 = toFreq(top);
      noiseSelection = { t0, t1, f0, f1 };
      updateNoiseReadouts(noiseSelection);
    };
    spectrogramOverlay.addEventListener('mousedown', (evt) => {
      if (!analysisContext.duration || !spectrogramImg?.src) return;
      const rect = spectrogramOverlay.getBoundingClientRect();
      startX = Math.max(0, Math.min(rect.width, evt.clientX - rect.left));
      startY = Math.max(0, Math.min(rect.height, evt.clientY - rect.top));
      dragging = true;
      updateCrosshair(evt);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
    spectrogramOverlay.addEventListener('mousemove', (evt) => {
      if (!dragging) updateCrosshair(evt);
    });
    spectrogramOverlay.addEventListener('mouseleave', () => {
      spectrogramOverlay.classList.remove('is-hovering');
    });
  }

  function collectNoisePayload(){
    const target = getActiveNoiseTarget();
    if (!target || !target.rel) return null;
    if (!noiseSelection) return null;
    const bandDepth = noiseDepthRange ? parseFloat(noiseDepthRange.value || '-18') : -18;
    const strength = noiseAfftdnRange ? parseFloat(noiseAfftdnRange.value || '0') : 0;
    const hp = noiseHpToggle?.checked ? parseFloat(noiseHpValue?.value || '') : null;
    const lp = noiseLpToggle?.checked ? parseFloat(noiseLpValue?.value || '') : null;
    return {
      path: target.rel,
      start_sec: noiseSelection.t0,
      end_sec: noiseSelection.t1,
      f_low: noiseSelection.f0,
      f_high: noiseSelection.f1,
      mode: noiseMode,
      band_depth_db: bandDepth,
      afftdn_strength: strength,
      hp_hz: Number.isFinite(hp) ? hp : null,
      lp_hz: Number.isFinite(lp) ? lp : null,
      preview_len_sec: 10,
    };
  }

  async function previewNoise(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to preview.');
      return;
    }
    setNoiseStatus('Previewing...');
    try {
      const res = await fetch('/api/analyze/noise/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'preview_failed');
      }
      const data = await res.json();
      if (noisePreviewAudio && data.url) {
        noisePreviewAudio.src = data.url;
        noisePreviewAudio.play().catch(() => {});
      }
      const startText = typeof data.preview_start === 'number' ? data.preview_start.toFixed(2) : '-';
      setNoiseStatus(`Preview starts at ${startText}s`);
    } catch (_err) {
      setNoiseStatus('Preview failed.');
    }
  }

  async function renderNoise(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to render.');
      return;
    }
    setNoiseStatus('Rendering full file...');
    try {
      const res = await fetch('/api/analyze/noise/render', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'render_failed');
      }
      const data = await res.json();
      if (typeof showToast === 'function') {
        showToast(`Cleaned copy ready: ${data.output_name || 'output'}`);
      }
      setNoiseStatus('Render complete.');
    } catch (_err) {
      setNoiseStatus('Render failed.');
    }
  }

  async function loadNoisePresets(){
    if (!noisePresetSelect) return;
    noisePresetSelect.innerHTML = '<option value="">No preset</option>';
    noisePresets = new Map();
    try {
      const res = await fetch('/api/library/noise_filters?origin=user', { cache: 'no-store' });
      if (!res.ok) throw new Error('preset_failed');
      const data = await res.json();
      const items = data.items || [];
      items.forEach((item) => {
        const title = item.meta?.title || item.id || 'Noise Filter';
        const option = document.createElement('option');
        option.value = item.id || '';
        option.textContent = title;
        noisePresetSelect.appendChild(option);
        noisePresets.set(option.value, item);
      });
    } catch (_err) {
      addStatusLine('Failed to load noise presets.');
    }
  }

  function applyNoisePreset(id){
    const item = noisePresets.get(id);
    if (!item || !item.noise) return;
    const noise = item.noise;
    if (noiseDepthRange && typeof noise.band_depth_db === 'number') {
      noiseDepthRange.value = String(noise.band_depth_db);
      if (noiseDepthVal) noiseDepthVal.textContent = String(noise.band_depth_db);
    }
    if (noiseAfftdnRange && typeof noise.afftdn_strength === 'number') {
      noiseAfftdnRange.value = String(noise.afftdn_strength);
      if (noiseAfftdnVal) noiseAfftdnVal.textContent = String(noise.afftdn_strength);
    }
    if (noiseHpToggle && noiseHpValue) {
      noiseHpToggle.checked = typeof noise.hp_hz === 'number';
      if (typeof noise.hp_hz === 'number') noiseHpValue.value = String(noise.hp_hz);
    }
    if (noiseLpToggle && noiseLpValue) {
      noiseLpToggle.checked = typeof noise.lp_hz === 'number';
      if (typeof noise.lp_hz === 'number') noiseLpValue.value = String(noise.lp_hz);
    }
    if (noise.mode) setNoiseMode(noise.mode);
    if (noise.f_low && noise.f_high && analysisContext.duration) {
      noiseSelection = {
        t0: noiseSelection?.t0 || 0,
        t1: noiseSelection?.t1 || Math.min(analysisContext.duration, 2),
        f0: noise.f_low,
        f1: noise.f_high,
      };
      updateNoiseReadouts(noiseSelection);
      renderNoiseSelectionBox();
    }
  }

  async function saveNoisePreset(){
    const payload = collectNoisePayload();
    if (!payload) {
      setNoiseStatus('Select a region to save.');
      return;
    }
    const title = prompt('Noise filter name', 'Noise Cleanup');
    if (!title) return;
    setNoiseStatus('Saving preset...');
    try {
      const res = await fetch('/api/analyze/noise/preset/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title,
          target_kind: 'noise_filter',
          settings: {
            f_low: payload.f_low,
            f_high: payload.f_high,
            band_depth_db: payload.band_depth_db,
            afftdn_strength: payload.afftdn_strength,
            hp_hz: payload.hp_hz,
            lp_hz: payload.lp_hz,
            mode: payload.mode,
          },
          source_hint: { from_file: getActiveNoiseTarget()?.name || '' },
        }),
      });
      if (!res.ok) {
        const err = await res.text();
        throw new Error(err || 'save_failed');
      }
      await res.json();
      setNoiseStatus('Preset saved.');
      loadNoisePresets();
    } catch (_err) {
      setNoiseStatus('Preset save failed.');
    }
  }

  async function applyData(payload){
    if (!payload) return;
    const input = payload.metrics?.input || null;
    const output = payload.metrics?.output || null;
    if (sourceName) sourceName.textContent = payload.source_name || 'Source';
    if (processedName) processedName.textContent = payload.processed_name || '-';
    if (emptyState) emptyState.hidden = true;
    if (loadedState) loadedState.hidden = false;
    const durationFallback = payload.duration_s ?? output?.duration_sec ?? input?.duration_sec ?? null;
    analysisContext = {
      duration: durationFallback,
      source: payload.source_rel ? { rel: payload.source_rel, name: payload.source_name || 'Source' } : null,
      processed: payload.processed_rel ? { rel: payload.processed_rel, name: payload.processed_name || 'Processed' } : null,
    };
    if (analysisContext.processed?.rel) {
      analysisFocus = 'processed';
    } else if (analysisContext.source?.rel) {
      analysisFocus = 'source';
    }
    analysisShowBoth = false;
    renderPills(payload, input, output);
    renderMetrics(input, output);
    updateNoiseTargets();
    syncAnalyzeFocusUI();
    renderNoiseSpectrogram(false);
    renderAnalyzeSpectrograms(false);
  }

  async function selectAndLoad(item, node, shouldPush){
    if (!item) return;
    if (node && analyzeBrowser) {
      analyzeBrowser.querySelectorAll('.browser-item.active').forEach(el => el.classList.remove('active'));
      node.classList.add('active');
    }
    try {
      if (item.kind === 'mastering_output') {
        addStatusLine(`Loading run ${item.song}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (item.out) params.set('out', item.out);
        if (item.solo) params.set('solo', '1');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', item.solo);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'mastering_run') {
        addStatusLine(`Loading run ${item.song || item.id}...`);
        const params = new URLSearchParams();
        params.set('song', item.song || item.id || '');
        if (shouldPush) updateUrl(params);
        const data = await resolveRun(item.song || item.id, item.out || '', false);
        await applyData(data);
        addStatusLine('Analysis ready');
      } else if (item.kind === 'source' || item.kind === 'import') {
        addStatusLine(`Loading ${item.kind}...`);
        const params = new URLSearchParams();
        params.set(item.kind === 'source' ? 'src' : 'imp', item.rel);
        if (shouldPush) updateUrl(params);
        const data = await resolveFile(item.kind, item.rel);
        await applyData(data);
        addStatusLine('Analysis ready');
      }
    } catch (_err) {
      if (typeof showToast === 'function') showToast('Analyze data unavailable');
      addStatusLine('Analysis failed');
    }
  }

  if (compareLink && window.location.search) {
    compareLink.href = `/compare${window.location.search}`;
  }

  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  const out = params.get('out');
  const solo = params.get('solo');
  const src = params.get('src');
  const imp = params.get('imp');
  if (song) {
    selectAndLoad(
      out
        ? { kind: 'mastering_output', id: `${song}::${out}`, song, out, solo: solo === '1' || solo === 'true' }
        : { kind: 'mastering_run', id: song, song },
      null,
      false
    );
  } else if (src) {
    selectAndLoad({ kind: 'source', rel: src }, null, false);
  } else if (imp) {
    selectAndLoad({ kind: 'import', rel: imp }, null, false);
  }

  if (analyzeBrowser) {
    analyzeBrowser.addEventListener('click', (evt) => {
      const itemNode = evt.target.closest('.browser-item');
      if (!itemNode || itemNode.disabled) return;
      const kind = itemNode.dataset.kind || '';
      const id = itemNode.dataset.id || '';
      let meta = {};
      if (itemNode.dataset.meta) {
        try {
          meta = JSON.parse(itemNode.dataset.meta || '{}');
        } catch (_err) {
          meta = {};
        }
      }
      if (kind === 'mastering_output') {
        const song = meta.song || '';
        if (!song) return;
        evt.preventDefault();
        evt.stopPropagation();
        const item = { kind, id, song, out: meta.out || '', solo: Boolean(meta.solo) };
        selectAndLoad(item, itemNode, true);
        return;
      }
      if (kind === 'import') {
        const rel = meta.rel || id;
        if (!rel) return;
        evt.preventDefault();
        evt.stopPropagation();
        const item = { kind, id, rel };
        selectAndLoad(item, itemNode, true);
        return;
      }
      if (kind !== 'mastering_run') return;
      evt.preventDefault();
      evt.stopPropagation();
      const item = { kind, id, song: id };
      selectAndLoad(item, itemNode, true);
    });
  }

  loadAnalyzeSpectrogramState(analyzeSpectrograms.source);
  loadAnalyzeSpectrogramState(analyzeSpectrograms.processed);
  bindAnalyzeSpectrogramControls(analyzeSpectrograms.source, 'source');
  bindAnalyzeSpectrogramControls(analyzeSpectrograms.processed, 'processed');
  bindSpectrogramCursor(analyzeSpectrograms.source, 'source');
  bindSpectrogramCursor(analyzeSpectrograms.processed, 'processed');
  if (analysisFocusProcessedBtn) {
    analysisFocusProcessedBtn.addEventListener('click', () => {
      analysisFocus = 'processed';
      syncAnalyzeFocusUI();
      renderAnalyzeSpectrograms(false);
    });
  }
  if (analysisFocusSourceBtn) {
    analysisFocusSourceBtn.addEventListener('click', () => {
      analysisFocus = 'source';
      syncAnalyzeFocusUI();
      renderAnalyzeSpectrograms(false);
    });
  }
  if (analysisShowBothBtn) {
    analysisShowBothBtn.addEventListener('click', () => {
      analysisShowBoth = !analysisShowBoth;
      syncAnalyzeFocusUI();
      renderAnalyzeSpectrograms(true);
    });
  }
  makeResizeObserver(analysisSpectrogramSourceViewport, () => {
    renderAnalyzeSpectrograms(true);
  });
  makeResizeObserver(analysisSpectrogramProcessedViewport, () => {
    renderAnalyzeSpectrograms(true);
  });
  makeResizeObserver(spectrogramViewport, () => {
    renderNoiseSpectrogram(true);
  });

  if (noiseModeRemoveBtn) {
    noiseModeRemoveBtn.addEventListener('click', () => setNoiseMode('remove'));
  }
  if (noiseModeSoloBtn) {
    noiseModeSoloBtn.addEventListener('click', () => setNoiseMode('solo'));
  }
  if (noiseDepthRange) {
    noiseDepthRange.addEventListener('input', () => {
      if (noiseDepthVal) noiseDepthVal.textContent = noiseDepthRange.value;
    });
  }
  if (noiseAfftdnRange) {
    noiseAfftdnRange.addEventListener('input', () => {
      if (noiseAfftdnVal) noiseAfftdnVal.textContent = noiseAfftdnRange.value;
    });
  }
  if (noiseSpectrogramHeight) {
    const savedHeight = parseInt(loadSetting(NOISE_HEIGHT_KEY, '384'), 10) || 384;
    noiseSpectrogramHeight.value = String(savedHeight);
    noiseSpectrogramHeight.addEventListener('change', () => {
      const value = parseInt(noiseSpectrogramHeight.value || '384', 10) || 384;
      saveSetting(NOISE_HEIGHT_KEY, value);
      renderNoiseSpectrogram(true);
    });
  }
  if (noiseZoomRange) {
    noiseZoomRange.addEventListener('input', () => {
      if (noiseZoomVal) noiseZoomVal.textContent = `${noiseZoomRange.value}x`;
      renderNoiseSpectrogram(true);
    });
    if (noiseZoomVal) noiseZoomVal.textContent = `${noiseZoomRange.value}x`;
  }
  if (noiseFitBtn) {
    noiseFitBtn.addEventListener('click', () => {
      if (noiseZoomRange) noiseZoomRange.value = '1';
      if (noiseZoomVal) noiseZoomVal.textContent = '1x';
      if (spectrogramViewport) spectrogramViewport.scrollLeft = 0;
      renderNoiseSpectrogram(false);
    });
  }
  if (noiseClearBtn) {
    noiseClearBtn.addEventListener('click', () => {
      noiseSelection = null;
      if (spectrogramSelection) spectrogramSelection.hidden = true;
      updateNoiseReadouts(null);
    });
  }
  if (noiseTargetSource) {
    noiseTargetSource.addEventListener('change', () => renderNoiseSpectrogram(false));
  }
  if (noiseTargetProcessed) {
    noiseTargetProcessed.addEventListener('change', () => renderNoiseSpectrogram(false));
  }
  if (noisePresetSelect) {
    noisePresetSelect.addEventListener('change', () => {
      const id = noisePresetSelect.value;
      if (id) applyNoisePreset(id);
    });
  }
  if (noisePreviewBtn) noisePreviewBtn.addEventListener('click', previewNoise);
  if (noiseRenderBtn) noiseRenderBtn.addEventListener('click', renderNoise);
  if (noiseSaveBtn) noiseSaveBtn.addEventListener('click', saveNoisePreset);

  bindSpectrogramSelection();
  syncAnalyzeFocusUI();
  setNoiseMode('remove');
  loadNoisePresets();
})();
</script>
{% endblock %}
